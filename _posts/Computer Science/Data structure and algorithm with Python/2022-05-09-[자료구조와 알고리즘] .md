---
layout: single
title: "[자료구조와 알고리즘] Heaps"
categories: ['Computer Science', 'Data structures and algorithms with Python']
tag: ['Heap']
---

<br>

# Heaps

10-2

## Complete binary tree

- Complete binary tree has the maximum number of entries for its height

![image](https://user-images.githubusercontent.com/79521972/167300113-d35abb84-664e-4c4c-ac53-6ecf903b8047.png)

- Binary tree is nearly complete if 
  - it has the minimum height for its nodes and 
  - all nodes in the last level are found on the left

![image](https://user-images.githubusercontent.com/79521972/167300125-1c72f55f-3316-40f6-bb8f-d45afd096c5a.png)

---

10-3

## Properties of Nearly complete binary trees

![image](https://user-images.githubusercontent.com/79521972/167300148-0429f4e3-679b-4846-a689-7e171f003d00.png)



- h = [log2N], where N is the number of nodes and h is the height of the tree 
- Leaf nodes are [N/2] + 1, [N/2] + 2, ..., N 
- In a complete binary tree, N = 2h+1 – 1



---

10-4

## 6.1 Heaps

- Heap is a nearly complete binary tree that satisfies the heap property

There are two kinds of binary heaps: max-heaps and min-heaps. In both kinds, the values in the nodes satisfy a heap property, the specifics of which depend on the kind of heap.

In a max-heap, the max-heap property is that for every node i other than the root,

A[Parent(i)] >= A[i],

that is, the value of a node is at most the value of its parent. Thus, the largest element in a max-heap is stored at the root

A min-heap is organized in the opposite way;

- The smallest element in a min-heap is at the root



---

10-5

![image](https://user-images.githubusercontent.com/79521972/167300306-457026bd-a6f9-4229-a2fc-f7258b273ca8.png)

![image](https://user-images.githubusercontent.com/79521972/167300315-946e7269-6d4f-477b-aad4-caa62e8a1906.png)



---

10-6

## 6.2 Maintaining the heap property

In order to maintain the max-heap property, we call the procedure MAX-HEAPIFY.

Its inputs are an array A and an index i into the array. When it is called, MAX-HEAPIFY assumes that the binary trees rooted at LEFT(i) and RIGHT(i) are max-heaps, but that A[i] might be smaller than its children, thus violating the max-heap property.

MAX-HEAPIFY lets the value at A[i] "float down" in the max-heap so that the subtree rooted at index i obeys the max-heap property.

![image](https://user-images.githubusercontent.com/79521972/167300447-78a21085-bce8-4c49-8b77-002f53ed59a9.png)

---

10-7



![image](https://user-images.githubusercontent.com/79521972/167300468-35df6012-9e96-4b3e-b9bf-68de9bbb29d8.png)

---

10-8

## 6.3 Building a heap

We can use the procedure MAX-HEAPIFY in a bottom-up manner to convert an array A[1 .. n]

- where n = A.length, into a max-heap.

![image](https://user-images.githubusercontent.com/79521972/167300567-596b4767-3f2e-4054-8705-b68d851a96ba.png)



---

10-9

![image](https://user-images.githubusercontent.com/79521972/167300619-26c4287d-dfee-4f94-a2cd-89ee72a8ec89.png)





---

10-10

## Implementation of Max Heap

```python
class MaxHeap:  # 1
    def __init__(self, data_list = None):
        self.h = [0]	# the heap
        if data_list is not None:
            self.h.extend(data_list)
            
        # 7; build the max heap
        # apply max_heapify() only for internal nodes
        for i in range(self.size() // 2, 0, -1):
            self.max_heapify(i)
            
```

```python
a = [4, 8, 7, 2, 9, 10, 5, 1, 3, 6] # 66
h1 = MaxHeap(a)
print(h1.h)
```

![image](https://user-images.githubusercontent.com/79521972/167300742-03d3946c-db5d-4185-9320-b234eb8c7360.png)



---

10-11

```python
	# 12; return the current size of the heap
    def size(self):
        return len(self.h) - 1
    
    # 16; move item k as down as possible
    def max_heapify(self, k): # 17
        left = k * 2
        right = k * 2 + 1
        
        largest = k # 21
        if left <= self.size() and self.h[left] > self.h[largest]:
            largest = left
        if right <= self.size() and self.h[right] > self.h[largest]:
            largest = right
         
        if largest != k: # 27
            self.h[k], self.h[largest] = self.h[largest], self.h[k]
            self.max_heapify(largest)
```



---

10-12

## 6.4 The heapsort algorithm

![image](https://user-images.githubusercontent.com/79521972/167300936-6822d9df-46c3-4617-b777-5122c1a7cdba.png)

![image](https://user-images.githubusercontent.com/79521972/167300950-090e7606-87ca-4657-acb9-28be9cf7b0c0.png)



---

10-13

![image](https://user-images.githubusercontent.com/79521972/167300959-e0351038-43ac-4834-9af1-9a70e181a3d0.png)

![image](https://user-images.githubusercontent.com/79521972/167300968-55c758d1-16b3-4bfc-93b7-f883de690c14.png)



---

10-14

```python
	def heap_sort(self): # 31
        save = self.h[:] # shallow copy
        sorted_list = self.h[1:]
        
        for i in range(self.size(), 0, -1): # 35 
            self.h[1], self.h[i] = self.h[i], self.h[1]
            sorted_list[i - 1] = self.h[i]
            self.h.pop()
            self.max_heapify(1) # 39
            
        self.h = save # 41
        return sorted_list
```

```python
print(h1.heap_sort())
print(h1.h)
```

![image](https://user-images.githubusercontent.com/79521972/167301108-705059c6-2c98-424e-8474-dfeffdf7f13d.png)





---

10-15

## 6.5 Priority queues

In this section, we present one of the most popular applications of a heap: as an efficient priority queue. As with heaps, priority queues come in two forms: max-priority queues and min-priority queues.

A priority queue is a data structure for maintaining a set S of elements, each with an associated value called a key. A max-priority queue supports the following operation:

INSERT(S, x) inserts the element x into the set S, which is equivalent to the operation

![image](https://user-images.githubusercontent.com/79521972/167301223-ed64658b-d17a-4801-9938-3df204a46113.png)

MAXIMUM(S) returns the element of S with the largest key.

EXTRACT-MAX(S) removes and returns the element of S with the largest key.

---

10-16

procedure  HEAP-EXTRACT-MAX

> HEAP-EXTRACT-MAX(A)

```python
if A.heap-size < 1:
    error "heap underflow"
max = A[1]
A[1] = A[A.heap-size]
A.heap-size = A.heap-size - 1
MAX-HEAPIFY(A, 1)
return max
```

![image](https://user-images.githubusercontent.com/79521972/167301344-07df31c9-5fbd-43fc-9e71-44af92dbcb4d.png)



---

10-17

```python
	def pop(self):
        if self.size() == 0:
            return None
        
        item = self.h[1]
        # copy the last item to root and remove it
        self.h[1] = self.h[self.size()]
        self.h.pop()
        self.max_heapify(1)
        
        return item
```



```python
for _ in range(h1.size()):
    print(h1.pop(), end=' ')
print()
print(h1.h)
```

![image](https://user-images.githubusercontent.com/79521972/167301444-3d2cfa76-682a-4e09-b0ee-53caaf3f3765.png)



---

10-18

procedure MAX-HEAP-INSERT

![image](https://user-images.githubusercontent.com/79521972/167301460-430e65dd-16ec-41b6-bca1-52b2769ba409.png)



---

10-19

```python
	def insert(self, item): # 56
        self.h.append(item)
        
        # move up the item to keep the max-heap property
        k = self.size() # 60
        while k > 1 and self.h[k] > self.h[k//2]:
            self.h[k], self.[k//2] = self.h[k//2], self.h[k]
            k //= 2
```

```python
h1 = MaxHeap()
for d in (4, 8, 7, 2, 9, 10, 5, 1, 3, 6):
    h1.insert(d)
print(h1.h)
```

![image](https://user-images.githubusercontent.com/79521972/167301573-6db7945d-9006-441d-88b2-76273d12a5f9.png)



---

10-20

## Time Complexity of Building a Heap

Each call to MAX-HEAPIFY costs O(logn) time, and BUILD-MAX-HEAP makes O(n) such calls. Thus, the running time is O(nlogn). 

This upper bound, though correct, is not asymptotically tight.

We can derive a tighter bound by observing that the time for MAX-HEAPIFY to run at a node varies with the height of the node in the tree,  and the heights of most nodes are small. 

Out tighter analysis relies on the properties that an n-element heap has height [logn] and at most 
[n/2<sup>h+1</sup>]nodes  of any height h

![image](https://user-images.githubusercontent.com/79521972/167301709-6b45a8b9-fabd-4c5f-be5b-f7a145e4b365.png)



---

10-21

The time required by MAX-HEAPIFY when called on a node of height h is O(h), and so we can express the total cost of BUILD-MAX-HEAP as being bounded from above by

![image](https://user-images.githubusercontent.com/79521972/167301744-17e9fc6b-2a1a-4d92-af28-8802114dd8a0.png)

We evaluate the last summation by substituting x = 1/2 in the formula (A.8), yielding

![image](https://user-images.githubusercontent.com/79521972/167301805-612e2773-f69f-42e4-a40b-79af19ebe0d2.png) ![image](https://user-images.githubusercontent.com/79521972/167301814-6a46139c-594f-4d36-a70e-6e8491b2fef7.png)

![image](https://user-images.githubusercontent.com/79521972/167301820-f66a7a09-fbe8-4d9d-9fd1-bf0ceec3406a.png)

---

10-22

## Why should one ever use a heap instead of a sorted array?

Thus, we can bound the running time of BUILD-MAX-HEAP as 

![image](https://user-images.githubusercontent.com/79521972/167301858-f9db4687-48c6-4482-8fa2-0339e357edde.png)

Yes, building a heap takes linear time and inserts/deletes take O(logn). While peeking the heap, which means finding the min/max stored element is, of course, O(1), popping the head is O(logn).

The answer is simple. In some use cases, you don't care about sorting all of your data, but you do care about constantly maintaining the smallest/largest element, which corresponds to a Priority Queue, a concept that is used extensively and in many applications.

---

10-23

## heapq - HEAP queue algorithm

heapq.heappush(heap, item)

- Push the value item onto the heap, maintaining the heap invariant

heapq.heappop(heap)

- Pop and return the smallest item from the heap, maintaining the heap invariant. If the heap is empty, `IndexError` is raised. To access the smallest item without popping it, use heap[0].

heapq.heappushpop(heap, item)

- Push item on the heap, then pop and return the smallest item from the heap. The combined action runs more efficiently than heappush() followed by a separate call to heappop().

heapq.heapify(x)

- Transform list x into a heapm, in-place, in linear time.



[https://docs.python.org/3.8/library/heapq.html](https://docs.python.org/3.8/library/heapq.html)

---

10-24

```python
import heapq # 1


# A heap sort algorithm
def heapsort(iterable): # 5
    h = []
    for value in iterable:
        heapq.heappush(h, value)
    return [heapq.heappop(h) for _ in range(len(h))]


# You can transform a populated list into a heap
a = [3, 5, 1, 2, 6, 8, 7] # 13 
heapq.heapify(a)
print(a)
print(heapsort(a))

# Or use a list initialized to []
# Heap elements can be tuples.
b = [] # 20
heapq.heappush(b, (5, 'write code'))
heapq.heappush(b, (7, 'release product'))
heapq.heappush(b, (1, 'write spec'))
print(heapq.heappop(b)) # 24
```



---

10-25

![image](https://user-images.githubusercontent.com/79521972/167302249-4656f34c-a3f1-4470-87b3-f79a3f0b2d0d.png)

[https://www.acmicpc.net/problem/14235](https://www.acmicpc.net/problem/14235)



---

10-26

![image](https://user-images.githubusercontent.com/79521972/167302271-0321e0f1-966e-4253-9cb7-52e3ef9b5ec9.png)



---

10-27

![image](https://user-images.githubusercontent.com/79521972/167302321-70d1219b-ed04-45b8-80b8-ca182e934363.png)

[https://www.acmicpc.net/problem/14241](https://www.acmicpc.net/problem/14241)

---

10-28

![image](https://user-images.githubusercontent.com/79521972/167302355-1a03a64e-83e9-4600-9305-ebbb405472a2.png)

