---
layout: single
title: "[자료구조와 알고리즘] Sorting"
categories: ['Computer Science', 'Data structures and algorithms with Python']
tag: ['Data structures and algorithms', 'Sorting']
---



# Sorting



## Sorting Algorithms

- Bubble sort
- Insertion sort
- Quick sort

<br>

Sorting이란 크기 순으로 오름차순 정렬된 리스트로 모든 아이템을 배치하는 것을 말한다.

![image](https://user-images.githubusercontent.com/79521972/160319901-8ead70a4-2cb0-4bba-a87d-2097226e2aee.png)

숫자가 212인 item이 여러개가 있기 때문에 숫자를 key값으로 sorting하게 되면 이들 간의 순서를 정하기가 모호하다.

이 때 같은 numeric key에 대한 item들이 unstorted data에서 정렬된 순서가 sorted data에 반영된 순서로 정렬되면 <mark>Stable sort</mark>, 그렇지 않으면 <mark>Unstable sort</mark>라고 한다.

**Stable sort**

- 같은 key를 갖는 데이터가 그들의 ***relative input order***를 output에서 유지하는 방식



<br>



![image](https://user-images.githubusercontent.com/79521972/160320119-af0351d6-dc0a-444f-a4f3-4eb0abffccbb.png)



복잡하고 성능이 좋은 sort는 O(nlogn)의 시간복잡도를 갖는다.

quick sort는 O(n<sup>2</sup>)의 시간복잡도를 갖는데 어느 경우에 n<sup>2</sup>을 갖는데 굉장히 희박하게 갖는 것이기 때문에 quick sort는 코드를 조금만 바꾸면 nlong의 시간복잡도를 가져서 사실상 O(nlogn)으로 생각해도 큰 문제가 없다.



실제 시스템에 적용했을 때 속도가 빠른 sort는 quick sort이다. 같은 nlon이지만 실제 적용했을 때 heap이나 merge에 비해서 평균적으로 더 빠르기 때문에 quick sort를 굉장히 많이 사용한다. 프로그램 언어마다 sorting을 해주는 라이브러리를 만들어 놨는데 c++,java의 sorting 알고리즘에서 quick sort를 사용한 것이고 파이썬의 내장 sort 함수들은 merge sort를 사용한 것이다.



binary search를 할 때에도 

<br>

## Bubble sort algorithms

리스트에서 <mark>인접한 element들을 비교</mark>한 후에 크기 순으로 올바르게 배치하는 방식이다.

리스트 안의 item들이 올바르지 않은 순서라면, 각각의 인접한 item들을 swapping하면서 작동한다. 

- n개의 item이 있다면 n-1 번 동안 process가 반복된다.(맨 마지막에 하나 남은 경우는 당연히 제일 작은 값일 것이기 때문에 할 필요가 없어서 sorting이 그대로 끝나기 때문에 n-1번의 process가 진행되는 것)



**The 1st iteration**

![image-20220328122013917](C:\Users\c_dragon\AppData\Roaming\Typora\typora-user-images\image-20220328122013917.png)

6개의 데이터를 왼쪽부터 시작하여 쭉 비교하면서 제일 큰 값을 맨 오른쪽에 넣은 모습을 볼 수있다.

그러면 맨 끝 값은 sorting이 완료되었다고 보고 다시 남은 5개의 item에 대해서 sort(iteration)를 진행하는 것이다.



**Why Bubble?**

첫 값인 45인 값이 bubble과 같이 솟아올라 오른쪽으로 흘러간다. 흘러가면서 비교하다가 현재 bubble보다 더 큰 값이 나오면 해당 bubble이 툭 튀어올라서 해당 bubble이 오른쪽으로 흘러가게 된다.

이처럼 값이 정렬되는 방식이 bubble과 같이 보인다 하여 bubble sort라는 이름이 붙여지게 되었다.

<br>

**The 2nd iteration**

![image](https://user-images.githubusercontent.com/79521972/160321358-523dc934-c480-4008-9ce2-5369f1bde240.png)



**The 3rd iteration**

![image](https://user-images.githubusercontent.com/79521972/160321383-b71cd0f7-ce52-4cbd-a1c0-892748629d88.png)



**The 4th iteration**

![image](https://user-images.githubusercontent.com/79521972/160321420-f415ee67-170c-4385-8ff5-8933b0eda88e.png)



**The 5th iteration**

![image](https://user-images.githubusercontent.com/79521972/160321442-6f86ccf0-69d8-46c4-94af-e9483dc8b04b.png)



<br>

최대 operation의 횟수는 n-1번이고 n/2번 반복하기 때문에 (n-1) * n/2 라서 O(n<sup>2</sup>)의 시간복잡도를 갖는 것이다.





**코드로 구현**

```python
def bubble_sort(unordered):
    iteration = len(unordered)-1    # n-1
    for i in range(iteration):		# 0~n-2
        for j in range(iteration - i): #각 iteration에서 뒤져봐야 되는 index의 범위 
            if unordered[j] > unordered[j+1]:
                unordered[j], unordered[j+1] = unordered[j+1], unordered[j]
                
                
test = [45, 23, 87, 12, 32, 4]
bubble_sort(test)
print(test)
# [4, 12, 23, 32, 45, 87]
```



<br>

## Insertion sort algorithms

![image](https://user-images.githubusercontent.com/79521972/160323021-ef7b07ba-2682-4a3a-aaff-0b158a0b13f4.png)

**삽입 정렬 알고리즘**은 항상 정렬된 상태의  서브 리스트를 유지하고, 다른 나머지 비율은 정렬되지 않은 상태로 남아있다.

방식은 정렬되지 않는 서브 리스트로부터 element를 한 개씩 취하여 정렬된 서브 리스트의 알맞은 위치에 그 element들을 삽입하는 방식이다. 

그래서 서브리스트는 정렬된 채로 남아있는 것이다.

<br>

다음과 같은 배열을 생각해 보자.

![image](https://user-images.githubusercontent.com/79521972/160323065-124ebf66-03b3-4de2-99f8-e62161d1997b.png)



<br>

알고리즘은 1번과 4번 인덱스들 사이를 돌기위해 for loop를 사용하면서 시작한다. 

![image](https://user-images.githubusercontent.com/79521972/160323564-4db888e9-ba60-427f-afad-4cc927ed5e6b.png)

핵심 아이디어는 0번 인덱스는 이미 정렬된 상태의 서브리스트로 보는 것이다. 그렇기 때문에 1번 index부터 시작할 것이다. 

즉, 0번 index의 5번 카드를 쥐고 있다고 생각하면 이를 정렬할 필요가 없다는 의미인 것이다.



![image](https://user-images.githubusercontent.com/79521972/160323592-606feb91-0501-4470-b287-1d497ac1d467.png)

그런데 딜러가 다음 카드인 1번 인덱스의 1이라는 카드를 주었다. 그러면 이 때는 sorting된 상태를 유지하면서 내 손에 가진 덱의 가장 마지막 값부터 비교하여 알맞은 위치에 삽입시킬 것이다. 1과 5를 비교했을 때 1이 5보다 작기 때문에 5의 왼쪽에 삽입하였다.



이와 같은 과정을 모든 element에 대해서 진행한다.

![image](https://user-images.githubusercontent.com/79521972/160323626-b4efa32b-64fd-40a7-8a81-5e70cd094003.png)



딜러가 주는 카드덱(오른쪽 서브리스트)에서 한 장씩 카드를 나에게 주는데 내 손에 있는 카드덱의 가장 큰 것부터 비교하기 때문에 my<dealer 일 때까지 swapping을 하는 것이다.

n-1번의 iteration을 평균 n/2번 진행한다.

<br>

**코드로 구현**

```python
def insertion_sort(unordered):
    for i in range(1, len(unordered)):
        key = unordered[i] #딜러한테 새로 받는 카드
        
        j = i # 이 순간 받은 카드도 내 손의 카드에 속하게 된다.
        
        while j > 0 and unordered[j-1] > key: #내 손의 카드의 가장 마지막 값부터 시작하여 비교
            unordered[j] = unordered[j-1]
            j-=1  # 그 다음 값으로 이동
        unordered[j] = key # while문이 통과되면 key값이 제 자리(j)를 찾은 것이므로 삽입
                                  
                            
test = [45, 23, 87, 12, 32, 4]
insertion_sort(test)
print(test)
```

```
[4, 12, 23, 32, 45, 87]
```



<br>

























