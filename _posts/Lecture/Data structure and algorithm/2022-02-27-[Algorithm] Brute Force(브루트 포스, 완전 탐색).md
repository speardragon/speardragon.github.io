---
layout: single
title: "[Algorithm] Brute Force(브루트 포스, 완전 탐색)"
categories: ['Lecture', 'Data structure and algorithms', 'Algorithm', 'BruteForce']
tag: ['Data structure', 'Algorithm', 'BruteForce', '브루트 포스', '완전 탐색']
toc: false
toc_sticky: true
---

이번 시간에는 완전 탐색(브루트 포스)에 대해서 배워보도록 할 것이다.

<br>

### 1. 완전 탐색 알고리즘이란?

한때 유명했던 초등 학교 수학 문제 풀이가 있다.

![image](https://user-images.githubusercontent.com/79521972/155886472-8a400527-609c-4a47-93d2-3dbb656ef62c.png)

문제가 의도한 대로 푼 풀이는 아니지만 문제가 원하는 답을 얻기 위해서 푼 과정은 꼭 틀리다고 볼 수는 없다.(~~답은 틀렸다는 것은 함정~~)

<br>

이처럼 완전 탐색은 모든 경우의 수를 전부 다 체크해서 정답을 찾는 방법이다. 즉, 다시 말해서 무식하게 모든 경우의 수를 하나하나 다 해보겠다는 방법인 것이다.

이러한 방식이 굉장히 무식하다고 하여 "Brute Force"라는 이름이 붙여졌고 모든 알고리즘 중에서 가장 단순하고 직관적인 방법이라고 할 수 있다.

<br>
예를 들어, 금고의 4자리 비밀번호를 풀려고 할 때, 이 알고리즘으로 푸는 방법은 0000부터 9999까지 모두 시도해 보는 것이다. 그러면 최대 10000번의 시도를 하게 되고 그 안에는 반드시 해결이 되는 것이다.

그렇지만 만약 4자리가 아니라 8자리라면...? 16자리라면...? (머리가 벌써 아파진다.)

<br>

그렇기 때문에 Computer Science(CS)에서 문제 해결 알고리즘을 사용할 때는 다음과 같은 2가지 규칙을 준수한다.

1. 사용되는 알고리즘이 적절한 방법인가?(제한 조건 내에서 해결될 수 있는가)
2. 효율적으로 동작하는가?

위 2가지 규칙 중에서 1번은 충분히 만족할 수 있을 것이다. (어떻게든 풀어내면 되는 것이기 때문에)

하지만 2번 규칙은 사용하는데 제한이 따른다.

<br>

예를 들어, 다이나믹 프로그래밍으로 해결할 수 있는 문제에서 O(N)의 시간 복잡도가 소모되었다고 하자.

이를 완전 탐색으로 진행한다면 각 위치 N에 대해 이전의 경우의 수를 모두 따져봐야 하기 때문에 2중 반복문으로 인해 O(n<sup>2</sup>)의 시간 복잡도를 갖게 된다.

<br>

백준이나 프로그래머스 같은 코딩 문제 사이트에서는 입력 값의 범위를 제한한다. 그런데 만약 범위가 100,000이 된다면 (혹은 그 이상) 위 문제를 주어진 시간 이내에 절대 풀어낼 수없는 경우가 생길 수 있는 것이다.

따라서, 브루트 포스는 사용할 때에 해당 문제에 대한 파악이 제일 중요하다.

<br>

### 브루트 포스 사용법

브루트 포스, 즉 완전 탐색을 할 때에는 다음과 같은 것들이 고려되어야 한다.

1. 해결하고자 하는 문제의 가능한 경우의 수를 대략적으로 계산한다.
2. 가능한 모든 방법을 다 고려한다.
3. 실제 답을 구할 수 있는지 적용한다.

<br>

위의 2번 방법들에는 다음과 같은 것들이 있다.

① Broute Force 기법 - 반복문 or 조건문을 활용하여 모두 테스트 하는 방법

② 순열(Permutation) - n개의 원소 중에서 r개의 원소를 중복 허용 없이 나열하는 방법

③ 재귀 호출

④ 비트 마스크 - 2진수 표현 기법을 활용하는 방법

⑤ BFS, DFS를 활용하는 방법

<br>



### ① Broute Force 기법

이 방법은 반복문과 조건문을 마구 써서 어떻게 해서든지 모든 방법을 전부 다 해 보는 방법이다. 위의 자물쇠 예시와 같은 방법이다.

<br>



### ② 순열(Permutation) 

순열은 임의의 수열에 대하여 다른 순서로 연산하는 방법을 의미한다.

즉, 순서가 중요한 것으로 만약, 수열에서 숫자 {1, 2, 3}이 있다면 이것을 보는 순서에 따라 {1, 2, 3}과 {3, 2, 1}는 서로 순서에 차이가 있기 때문에 다른 수열로 보는 것을 의미한다.

<br>

그래서 만약 n개의 서로 다른 데이터가 있고 이를 순열로 나타낸다 하면 전체 순열의 가지 수는 n!개 가 되는 것이다.

<br>

순열을 구현하는 방법은 다음과 같다.

1. A[i-1] <= A[i]를 만족하는 i 중 가장 큰 값을 찾는다.(혹은 뒤에서부터 찾는 경우 A[i-1] >= A[i] 중 가장 작은 i를 찾는다.)

   - → 현재 i값을 기준으로 이후는 모두 내림차순으로 되는 경우를 찾는 다는 것이다. 

   - 현재 기준 최종 순열을 찾음

   - A배열을 보면 A[i-1] < A[i]가 되는 가장 큰 i는 6인 3번째(0부터 시작)이다. 즉, i=3이 된다.

2. j >= i 중, A[j] > A[i-1]을 만족하는 가장 큰 j의 값을 찾는다.

   - → 현재가 최종 순열 상태이므로 i-1번째 숫자를 변경하여 최초 순열을 찾아야 한다.

   - A배열을 기준으로 i-1번째 숫자는 3으로 3보다 큰 경우는 6, 5, 4이나 그 중 j 값이 가장 큰 경우는 4이다.

3. A[i-1]과 A[j]를 Swap한다.

   - → i-1인 2번째 숫자 3과 j인 5번째 숫자 4를 변경한다. 

   - A 배열은 다음과 같이 변경된다.
     - *A={7, 2, 4, 6, 5, 3, 1}* 

4. i이후의 순열을 모두 뒤집는다.

   - → 최초 순열 상태로 만들어야 하므로 i번째부터는 오름차순으로 만들어야 한다. 

   - 배열은 다음과 같이 변경된다.
     - *A={7, 2, 4, 1, 3, 5, 6}*















































































