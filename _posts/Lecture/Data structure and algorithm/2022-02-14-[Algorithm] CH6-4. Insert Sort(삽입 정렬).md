---
layout: single
title: "[Algorithm] CH6-4. Insert Sort(삽입 정렬)"
categories: ['Lecture', 'Data structure and algorithms', 'Algorithm', 'Sorting']
tag: ['Data structure', 'Algorithm', 'Insert Sort', '삽입 정렬', '정렬', 'Sorting']
toc: true
toc_sticky: true
---

<br>

# 삽입 정렬(Insertion Sorting)

이번 시간에는 삽입정렬에 대해 배워 보도록 하겠습니다.

삽입정렬은 리스트의 앞에서부터 이미 정렬된 서브 리스트의 값들과 비교하여 자신의 위치에 삽입하는 방식입니다. 이때 서브리스트는 이미 정렬이 되어있으므로 서브리스트 안에서도 자신이 삽이 되어야 할 위치가 정해져 있겠죠? 그 위치에 데이터를 삽입하는 것을 삽입정렬이라고 합니다.

이에 대한 예로는 

- 손안의 카드를 정렬하는 방법과 유사하다고 생각할 수 있습니다.
  - 새로운 카드를 기존의 정렬된 카드 더미에서의 올바른 자리를 찾아 삽입하고 새로 삽입될 카드의 수만큼 반복하게 되면서 전체 카드가 정렬됩니다.

그렇다면 이런 의문을 가질 수 있습니다.

> 정렬되지 않는 리스트를 정렬하고 싶은 것인데 이미 정렬된 서브 리스트는 어디서 부터 나오는 것인가?

만약 사이즈가 1인 배열이 있다고 생각해 봅시다. 그렇다면 그 배열은 어떤 값이 들어있더라고 정렬된 상태라고 할 수 있을 것입니다. 아래와 같이 말이죠.

![image](https://user-images.githubusercontent.com/79521972/153825575-8091f7cd-0caf-4206-9d3c-92241929eb45.png)

그래서 삽입 정렬은 이 아이디어에서 출발하는 겁니다.

<br>

가장 맨 앞의 데이터를 정렬된 서브 리스트로 보고 시작합시다. 

![image](https://user-images.githubusercontent.com/79521972/153825928-353f05ad-6a9f-4d57-be3d-5a567e3294cb.png)

그렇기 때문에 실질적으로는 두 번째 값 index로는 1부터 정렬을 시작하게 되는 것입니다.

위의 예에서는 '4'라는 값을 가진 데이터는 숫자 '5' 하나만 가진 리스트에 순서에 맞게 삽입해야 합니다. 그렇다면 4는 5보다 작기 때문에 0번의 인덱스에 4가 추가됩니다.

![image](https://user-images.githubusercontent.com/79521972/153826222-323ead0f-c09a-4de0-a2e7-7071c6b0acb3.png)

그러면 사이즈가 2인 서브리스트가 생성이 되는 것이죠.

<br>

그 이후에는 뻔합니다.  그 다음 값이 1을 가지고 4와 5가 존재하는 리스트의 어느 부분에 삽입할 지를 결정합니다. 마찬가지로 0이므로 

![image](https://user-images.githubusercontent.com/79521972/153832179-1e16fa2f-71d9-4de0-a467-c7e88b29f562.png)

그림과 같이 또 정렬된 서브 리스트가 만들어지게 되는 것입니다.

위의 과정을 반복하여 서브 리스트에 점점 값이 정렬되어 들어오게 되면서 완전히 오름차순으로 정렬된 리스트가 되는 것입니다. 아래에 그 과정이 그림으로 나타나져 있습니다.

![image](https://user-images.githubusercontent.com/79521972/153827043-5e9d12e9-eb70-48e6-a405-ba93c9492f80.png)



### 삽입 정렬의 특징

- 안정 정렬이다.
- 버블 정렬과 마찬가지로 단순한 알고리즘으로 이루어져 있다.
- 데이터의 이동이 많다.
  - 리스트 내의 데이터가 어느 정도 정렬이 되었다면 데이터의 이동이 적어진다.



### 시간복잡도

- 평균적으로는 : O(n^2)
- 최선의 경우 모두 정렬이 되어있는 경우 : O(n)
- 최악의 경우 역으로 정렬되어 있는 경우 : O(n^2)



### 삽입 정렬 (Insertion Sorting) 구현

삽입 정렬을 코드로 구현해 보겠습니다.

```java
package sort;

public class InsertionSort implements ISort {
    @Override
    public void sort(int[] arr) {
        for (int i = 1; i < arr.length ;i++) {
            int key = arr[i]; // 삽입 위치를 찾아줄 데이터
            int j = i - 1; // 0 - j 정렬된 서브 리스트
            while(j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j = j - 1;
            }
            arr[j + 1] = key;
        }
    }
}
```

위에서 설명했듯이 가장 맨 앞의 데이터를 서브 리스트로 생각하고 그 다음 데이터 부터 정렬을 진행하기 때문에 for문의 초기 시작은 1부터 시작합니다. 

**for 반복문**

- key라는 변수에 삽입을 할 데이터를 받습니다.
  - 삽입 할 데이터는 서브 리스트의 바로 다음 값입니다.

- j라는 변수는 서브 리스트의 크기를 의미하는 인덱스로 서브리스트는 0부터 시작하여 1씩 커지기 때문에 i - 1로 지정한 것입니다.
- while 반복문
  - 삽입 정렬이 된 서브 리스트의 마지막 인덱스(j)에는 가장 큰 값이 들어가있습니다.
  - 그렇기 때문에 arr[j] (서브 리스트 마지막 값)가 key(삽입 데이터)값보다 작으면 key값은 서브 리스트의 가장 마지막에 들어가야 합니다.
  - 반복 구간: j가 음수가 아니면서 서브 리스트의 마지막 값이 key 값보다 크면 반복
    - 서브 리스트의 마지막값부터 처음 값까지 key값과 비교하면서 진행 되므로 j는 하나씩 줄어듭니다. 
  - 만약 key값이 서브 리스트 마지막 인덱스의 값보다 작으면 서브 리스트는 key가 들어갈 공간을 하나씩 뒤로 밀어가며 비교하여 알맞은 j값을 찾습니다.
- 알맞은 j값을 찾았으면 해당 데이터는 key값보다 작은 것이므로 j + 1에 key를 넣어줍니다.





## 삽입 정렬의 시간 복잡도

**최선의 경우**

-  비교 횟수 : 이동없이 1번의 비교만 이루어진다.
  - 루프 횟수 : (n - 1) 번
- O(N)

**최악의 경우**

- 비교 횟수 : 외부 루프 안의 각 반복마다 i번의 비교 수행
  - 루프 횟수 : (n - 1) + (n - 2) + (n - 3) + ... + 2 + 1 = n(n - 1) / 2
  - O(N^2)
- 교환 횟수
  - 외부 루프의 단계에서 (i + 2)번의 이동 발생
  - O(N^2)
- O(N^2)





## 정렬 알고리즘 별 시간복잡도 비교

![image](https://user-images.githubusercontent.com/79521972/153831460-b472e26d-a089-44c4-9c19-1cb1158a75dc.png)

- 단순하지만 비효율적인 방법에는
  - 삽입 정렬, 선택 정렬, 버블 정렬
- 복잡하지만 효율적인 방법에는
  - 퀵 정렬, 힙 정렬 ,합병 정렬, 기수 정렬

이 있습니다.

<br>





















