<!DOCTYPE html> <html lang="en" class="no-js"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title>[System Programming] 9-1장. 프로세스 제어 | Jekflix</title> <meta name="description" content="Jekflix is a template for Jekyll inspired by Netflix and made by Thiago Rossener."> <meta name="keywords" content="Process control"> <!-- Social: Twitter --> <meta name="twitter:card" content="summary_large_image"> <meta name="twitter:title" content="[System Programming] 9-1장. 프로세스 제어 | Jekflix"> <meta name="twitter:description" content="Jekflix is a template for Jekyll inspired by Netflix and made by Thiago Rossener."> <meta property="twitter:image" content="http://localhost:4000/assets/img/blog-image.png"> <meta name="twitter:site" content="@twitter_username"> <!-- Social: Facebook / Open Graph --> <meta property="og:url" content="http://localhost:4000/System-Programming-9-1%EC%9E%A5.-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%A0%9C%EC%96%B4/"> <meta property="og:title" content="[System Programming] 9-1장. 프로세스 제어 | Jekflix"> <meta property="og:image" content="http://localhost:4000/assets/img/blog-image.png"> <meta property="og:description" content="Jekflix is a template for Jekyll inspired by Netflix and made by Thiago Rossener."> <meta property="og:site_name" content="Jekflix | A blog theme for Jekyll"> <!-- Favicon --> <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" /> <!-- Apple Touch Icons --> <link rel="apple-touch-icon" href="/assets/img/icons/apple-touch-icon.png" /> <link rel="apple-touch-icon" sizes="57x57" href="/assets/img/icons/apple-touch-icon-57x57.png" /> <link rel="apple-touch-icon" sizes="72x72" href="/assets/img/icons/apple-touch-icon-72x72.png" /> <link rel="apple-touch-icon" sizes="114x114" href="/assets/img/icons/apple-touch-icon-114x114.png" /> <link rel="apple-touch-icon" sizes="144x144" href="/assets/img/icons/apple-touch-icon-144x144.png" /> <link rel="apple-touch-icon" sizes="60x60" href="/assets/img/icons/apple-touch-icon-60x60.png" /> <link rel="apple-touch-icon" sizes="120x120" href="/assets/img/icons/apple-touch-icon-120x120.png" /> <link rel="apple-touch-icon" sizes="76x76" href="/assets/img/icons/apple-touch-icon-76x76.png" /> <link rel="apple-touch-icon" sizes="152x152" href="/assets/img/icons/apple-touch-icon-152x152.png" /> <!-- Windows 8 Tile Icons --> <meta name="application-name" content="Jekflix"> <meta name="msapplication-TileColor" content="#141414"> <meta name="msapplication-square70x70logo" content="smalltile.png" /> <meta name="msapplication-square150x150logo" content="mediumtile.png" /> <meta name="msapplication-wide310x150logo" content="widetile.png" /> <meta name="msapplication-square310x310logo" content="largetile.png" /> <!-- Android Lolipop Theme Color --> <meta name="theme-color" content="#141414"> <!-- Fonts --> <link href="https://fonts.googleapis.com/css?family=Titillium+Web:300,400,700" rel="stylesheet"> <link rel="stylesheet" href="/assets/css/styles.css"> <link rel="canonical" href="http://localhost:4000/System-Programming-9-1%EC%9E%A5.-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%A0%9C%EC%96%B4/"> <link rel="alternate" type="application/rss+xml" title="Jekflix | A blog theme for Jekyll" href="http://localhost:4000/feed.xml" /> <!-- Include extra styles --> <!-- JavaScript enabled/disabled --> <script> document.querySelector('html').classList.remove('no-js'); </script> </head> <body class="has-push-menu"> <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" display="none" version="1.1"><defs><symbol id="icon-menu" viewBox="0 0 1024 1024"><path class="path1" d="M128 213.333h768q17.667 0 30.167 12.5t12.5 30.167-12.5 30.167-30.167 12.5h-768q-17.667 0-30.167-12.5t-12.5-30.167 12.5-30.167 30.167-12.5zM128 725.333h768q17.667 0 30.167 12.5t12.5 30.167-12.5 30.167-30.167 12.5h-768q-17.667 0-30.167-12.5t-12.5-30.167 12.5-30.167 30.167-12.5zM128 469.333h768q17.667 0 30.167 12.5t12.5 30.167-12.5 30.167-30.167 12.5h-768q-17.667 0-30.167-12.5t-12.5-30.167 12.5-30.167 30.167-12.5z"/></symbol><symbol id="icon-search" viewBox="0 0 951 1024"><path class="path1" d="M658.286 475.429q0-105.714-75.143-180.857t-180.857-75.143-180.857 75.143-75.143 180.857 75.143 180.857 180.857 75.143 180.857-75.143 75.143-180.857zM950.857 950.857q0 29.714-21.714 51.429t-51.429 21.714q-30.857 0-51.429-21.714l-196-195.429q-102.286 70.857-228 70.857-81.714 0-156.286-31.714t-128.571-85.714-85.714-128.571-31.714-156.286 31.714-156.286 85.714-128.571 128.571-85.714 156.286-31.714 156.286 31.714 128.571 85.714 85.714 128.571 31.714 156.286q0 125.714-70.857 228l196 196q21.143 21.143 21.143 51.429z"/></symbol><symbol id="icon-close" viewBox="0 0 1000 1000"><path d="M969.8,870.3c27,27.7,27,71.8,0,99.1C955.7,983,937.9,990,920,990c-17.9,0-35.7-7-49.7-20.7L500,599L129.6,969.4C115.6,983,97.8,990,79.9,990s-35.7-7-49.7-20.7c-27-27.3-27-71.4,0-99.1L400.9,500L30.3,129.3c-27-27.3-27-71.4,0-99.1c27.3-27,71.8-27,99.4,0L500,400.9L870.4,30.2c27.7-27,71.8-27,99.4,0c27,27.7,27,71.8,0,99.1L599.1,500L969.8,870.3z"/></symbol><symbol id="icon-twitter" viewBox="0 0 951 1024"><path class="path1" d="M925.714 233.143q-38.286 56-92.571 95.429 0.571 8 0.571 24 0 74.286-21.714 148.286t-66 142-105.429 120.286-147.429 83.429-184.571 31.143q-154.857 0-283.429-82.857 20 2.286 44.571 2.286 128.571 0 229.143-78.857-60-1.143-107.429-36.857t-65.143-91.143q18.857 2.857 34.857 2.857 24.571 0 48.571-6.286-64-13.143-106-63.714t-42-117.429v-2.286q38.857 21.714 83.429 23.429-37.714-25.143-60-65.714t-22.286-88q0-50.286 25.143-93.143 69.143 85.143 168.286 136.286t212.286 56.857q-4.571-21.714-4.571-42.286 0-76.571 54-130.571t130.571-54q80 0 134.857 58.286 62.286-12 117.143-44.571-21.143 65.714-81.143 101.714 53.143-5.714 106.286-28.571z"/></symbol><symbol id="icon-facebook" viewBox="0 0 585 1024"><path class="path1" d="M548 6.857v150.857h-89.714q-49.143 0-66.286 20.571t-17.143 61.714v108h167.429l-22.286 169.143h-145.143v433.714h-174.857v-433.714h-145.714v-169.143h145.714v-124.571q0-106.286 59.429-164.857t158.286-58.571q84 0 130.286 6.857z"/></symbol><symbol id="icon-clock" viewBox="0 0 1000 1000"><path d="M500,10C229.8,10,10,229.8,10,500c0,270.2,219.8,490,490,490c270.2,0,490-219.8,490-490C990,229.8,770.2,10,500,10z M500,910.2c-226.2,0-410.2-184-410.2-410.2c0-226.2,184-410.2,410.2-410.2c226.2,0,410.2,184,410.2,410.2C910.2,726.1,726.2,910.2,500,910.2z M753.1,374c8.2,11.9,5.2,28.1-6.6,36.3L509.9,573.7c-4.4,3.1-9.6,4.6-14.8,4.6c-4.1,0-8.3-1-12.1-3c-8.6-4.5-14-13.4-14-23.1V202.5c0-14.4,11.7-26.1,26.1-26.1c14.4,0,26.1,11.7,26.1,26.1v300l195.6-135.1C728.7,359.2,744.9,362.1,753.1,374z"/></symbol><symbol id="icon-calendar" viewBox="0 0 1000 1000"><path d="M920,500v420H80V500H920 M990,430H10v490c0,38.7,31.3,70,70,70h840c38.7,0,70-31.3,70-70V430L990,430z"/><path d="M850,80v105c0,57.9-47.2,105-105,105c-58,0-105-47.1-105-105V80H360v105c0,57.9-47.2,105-105,105c-58,0-105-47.1-105-105V80C72.8,80,10,142.7,10,220v140h980V220C990,142.7,927.2,80,850,80z"/><path d="M255,10c-19.3,0-35,15.8-35,35v140c0,19.2,15.7,35,35,35c19.3,0,35-15.8,35-35V45C290,25.8,274.3,10,255,10z"/><path d="M745,10c-19.3,0-35,15.8-35,35v140c0,19.2,15.7,35,35,35c19.3,0,35-15.8,35-35V45C780,25.8,764.3,10,745,10z"/></symbol><symbol id="icon-github" viewBox="0 0 12 14"><path d="M6 1q1.633 0 3.012 0.805t2.184 2.184 0.805 3.012q0 1.961-1.145 3.527t-2.957 2.168q-0.211 0.039-0.312-0.055t-0.102-0.234q0-0.023 0.004-0.598t0.004-1.051q0-0.758-0.406-1.109 0.445-0.047 0.801-0.141t0.734-0.305 0.633-0.52 0.414-0.82 0.16-1.176q0-0.93-0.617-1.609 0.289-0.711-0.062-1.594-0.219-0.070-0.633 0.086t-0.719 0.344l-0.297 0.187q-0.727-0.203-1.5-0.203t-1.5 0.203q-0.125-0.086-0.332-0.211t-0.652-0.301-0.664-0.105q-0.352 0.883-0.062 1.594-0.617 0.68-0.617 1.609 0 0.664 0.16 1.172t0.41 0.82 0.629 0.523 0.734 0.305 0.801 0.141q-0.305 0.281-0.383 0.805-0.164 0.078-0.352 0.117t-0.445 0.039-0.512-0.168-0.434-0.488q-0.148-0.25-0.379-0.406t-0.387-0.187l-0.156-0.023q-0.164 0-0.227 0.035t-0.039 0.090 0.070 0.109 0.102 0.094l0.055 0.039q0.172 0.078 0.34 0.297t0.246 0.398l0.078 0.18q0.102 0.297 0.344 0.48t0.523 0.234 0.543 0.055 0.434-0.027l0.18-0.031q0 0.297 0.004 0.691t0.004 0.426q0 0.141-0.102 0.234t-0.312 0.055q-1.812-0.602-2.957-2.168t-1.145-3.527q0-1.633 0.805-3.012t2.184-2.184 3.012-0.805zM2.273 9.617q0.023-0.055-0.055-0.094-0.078-0.023-0.102 0.016-0.023 0.055 0.055 0.094 0.070 0.047 0.102-0.016zM2.516 9.883q0.055-0.039-0.016-0.125-0.078-0.070-0.125-0.023-0.055 0.039 0.016 0.125 0.078 0.078 0.125 0.023zM2.75 10.234q0.070-0.055 0-0.148-0.062-0.102-0.133-0.047-0.070 0.039 0 0.141t0.133 0.055zM3.078 10.562q0.062-0.062-0.031-0.148-0.094-0.094-0.156-0.023-0.070 0.062 0.031 0.148 0.094 0.094 0.156 0.023zM3.523 10.758q0.023-0.086-0.102-0.125-0.117-0.031-0.148 0.055t0.102 0.117q0.117 0.047 0.148-0.047zM4.016 10.797q0-0.102-0.133-0.086-0.125 0-0.125 0.086 0 0.102 0.133 0.086 0.125 0 0.125-0.086zM4.469 10.719q-0.016-0.086-0.141-0.070-0.125 0.023-0.109 0.117t0.141 0.062 0.109-0.109z"></path></symbol><symbol id="icon-medium" viewBox="0 0 1000 1000"><path d="M336.5,240.2v641.5c0,9.1-2.3,16.9-6.8,23.2s-11.2,9.6-20,9.6c-6.2,0-12.2-1.5-18-4.4L37.3,782.7c-7.7-3.6-14.1-9.8-19.4-18.3S10,747.4,10,739V115.5c0-7.3,1.8-13.5,5.5-18.6c3.6-5.1,8.9-7.7,15.9-7.7c5.1,0,13.1,2.7,24.1,8.2l279.5,140C335.9,238.6,336.5,239.5,336.5,240.2L336.5,240.2z M371.5,295.5l292,473.6l-292-145.5V295.5z M990,305.3v576.4c0,9.1-2.6,16.5-7.7,22.1c-5.1,5.7-12,8.5-20.8,8.5s-17.3-2.4-25.7-7.1L694.7,784.9L990,305.3z M988.4,239.7c0,1.1-46.8,77.6-140.3,229.4C754.6,621,699.8,709.8,683.8,735.7L470.5,389l177.2-288.2c6.2-10.2,15.7-15.3,28.4-15.3c5.1,0,9.8,1.1,14.2,3.3l295.9,147.7C987.6,237.1,988.4,238.2,988.4,239.7L988.4,239.7z"/></symbol><symbol id="icon-instagram" viewBox="0 0 489.84 489.84"><path d="M249.62,50.46c65.4,0,73.14.25,99,1.43C372.47,53,385.44,57,394.07,60.32a75.88,75.88,0,0,1,28.16,18.32,75.88,75.88,0,0,1,18.32,28.16c3.35,8.63,7.34,21.6,8.43,45.48,1.18,25.83,1.43,33.57,1.43,99s-0.25,73.14-1.43,99c-1.09,23.88-5.08,36.85-8.43,45.48a81.11,81.11,0,0,1-46.48,46.48c-8.63,3.35-21.6,7.34-45.48,8.43-25.82,1.18-33.57,1.43-99,1.43s-73.15-.25-99-1.43c-23.88-1.09-36.85-5.08-45.48-8.43A75.88,75.88,0,0,1,77,423.86,75.88,75.88,0,0,1,58.69,395.7c-3.35-8.63-7.34-21.6-8.43-45.48-1.18-25.83-1.43-33.57-1.43-99s0.25-73.14,1.43-99c1.09-23.88,5.08-36.85,8.43-45.48A75.88,75.88,0,0,1,77,78.64a75.88,75.88,0,0,1,28.16-18.32c8.63-3.35,21.6-7.34,45.48-8.43,25.83-1.18,33.57-1.43,99-1.43m0-44.13c-66.52,0-74.86.28-101,1.47s-43.87,5.33-59.45,11.38A120.06,120.06,0,0,0,45.81,47.44,120.06,120.06,0,0,0,17.56,90.82C11.5,106.4,7.36,124.2,6.17,150.27s-1.47,34.46-1.47,101,0.28,74.86,1.47,101,5.33,43.87,11.38,59.45a120.06,120.06,0,0,0,28.25,43.38,120.06,120.06,0,0,0,43.38,28.25c15.58,6.05,33.38,10.19,59.45,11.38s34.46,1.47,101,1.47,74.86-.28,101-1.47,43.87-5.33,59.45-11.38a125.24,125.24,0,0,0,71.63-71.63c6.05-15.58,10.19-33.38,11.38-59.45s1.47-34.46,1.47-101-0.28-74.86-1.47-101-5.33-43.87-11.38-59.45a120.06,120.06,0,0,0-28.25-43.38,120.06,120.06,0,0,0-43.38-28.25C394.47,13.13,376.67,9,350.6,7.8s-34.46-1.47-101-1.47h0Z" transform="translate(-4.7 -6.33)" /><path d="M249.62,125.48A125.77,125.77,0,1,0,375.39,251.25,125.77,125.77,0,0,0,249.62,125.48Zm0,207.41a81.64,81.64,0,1,1,81.64-81.64A81.64,81.64,0,0,1,249.62,332.89Z" transform="translate(-4.7 -6.33)"/><circle cx="375.66" cy="114.18" r="29.39" /></symbol><symbol id="icon-linkedin" viewBox="0 0 12 14"><path d="M2.727 4.883v7.742h-2.578v-7.742h2.578zM2.891 2.492q0.008 0.57-0.395 0.953t-1.059 0.383h-0.016q-0.641 0-1.031-0.383t-0.391-0.953q0-0.578 0.402-0.957t1.051-0.379 1.039 0.379 0.398 0.957zM12 8.187v4.437h-2.57v-4.141q0-0.82-0.316-1.285t-0.988-0.465q-0.492 0-0.824 0.27t-0.496 0.668q-0.086 0.234-0.086 0.633v4.32h-2.57q0.016-3.117 0.016-5.055t-0.008-2.313l-0.008-0.375h2.57v1.125h-0.016q0.156-0.25 0.32-0.438t0.441-0.406 0.68-0.34 0.895-0.121q1.336 0 2.148 0.887t0.813 2.598z"></path></symbol><symbol id="icon-heart" viewBox="0 0 34 30"><path d="M17,29.7 L16.4,29.2 C3.5,18.7 0,15 0,9 C0,4 4,0 9,0 C13.1,0 15.4,2.3 17,4.1 C18.6,2.3 20.9,0 25,0 C30,0 34,4 34,9 C34,15 30.5,18.7 17.6,29.2 L17,29.7 Z M9,2 C5.1,2 2,5.1 2,9 C2,14.1 5.2,17.5 17,27.1 C28.8,17.5 32,14.1 32,9 C32,5.1 28.9,2 25,2 C21.5,2 19.6,4.1 18.1,5.8 L17,7.1 L15.9,5.8 C14.4,4.1 12.5,2 9,2 Z" id="Shape"></path></symbol><symbol id="icon-arrow-right" viewBox="0 0 25.452 25.452"><path d="M4.471,24.929v-2.004l12.409-9.788c0.122-0.101,0.195-0.251,0.195-0.411c0-0.156-0.073-0.31-0.195-0.409L4.471,2.526V0.522c0-0.2,0.115-0.384,0.293-0.469c0.18-0.087,0.396-0.066,0.552,0.061l15.47,12.202c0.123,0.1,0.195,0.253,0.195,0.409c0,0.16-0.072,0.311-0.195,0.411L5.316,25.34c-0.155,0.125-0.372,0.147-0.552,0.061C4.586,25.315,4.471,25.13,4.471,24.929z"/></symbol><symbol id="icon-star" viewBox="0 0 48 48"><path fill="currentColor" d="M44,24c0,11.045-8.955,20-20,20S4,35.045,4,24S12.955,4,24,4S44,12.955,44,24z"/><path fill="#ffffff" d="M24,11l3.898,7.898l8.703,1.301l-6.301,6.102l1.5,8.699L24,30.898L16.199,35l1.5-8.699l-6.301-6.102 l8.703-1.301L24,11z"/></symbol><symbol id="icon-read" viewBox="0 0 32 32"><path fill="currentColor" d="M29,4H3C1.343,4,0,5.343,0,7v18c0,1.657,1.343,3,3,3h10c0,0.552,0.448,1,1,1h4c0.552,0,1-0.448,1-1h10 c1.657,0,3-1.343,3-3V7C32,5.343,30.657,4,29,4z M29,5v20H18.708c-0.618,0-1.236,0.146-1.789,0.422l-0.419,0.21V5H29z M15.5,5 v20.632l-0.419-0.21C14.528,25.146,13.91,25,13.292,25H3V5H15.5z M31,25c0,1.103-0.897,2-2,2H18v1h-4v-1H3c-1.103,0-2-0.897-2-2V7 c0-0.737,0.405-1.375,1-1.722V25c0,0.552,0.448,1,1,1h10.292c0.466,0,0.925,0.108,1.342,0.317l0.919,0.46 c0.141,0.07,0.294,0.106,0.447,0.106c0.153,0,0.306-0.035,0.447-0.106l0.919-0.46C17.783,26.108,18.242,26,18.708,26H29 c0.552,0,1-0.448,1-1V5.278C30.595,5.625,31,6.263,31,7V25z M6,12.5C6,12.224,6.224,12,6.5,12h5c0.276,0,0.5,0.224,0.5,0.5 S11.776,13,11.5,13h-5C6.224,13,6,12.776,6,12.5z M6,14.5C6,14.224,6.224,14,6.5,14h5c0.276,0,0.5,0.224,0.5,0.5S11.776,15,11.5,15 h-5C6.224,15,6,14.776,6,14.5z M6,16.5C6,16.224,6.224,16,6.5,16h5c0.276,0,0.5,0.224,0.5,0.5S11.776,17,11.5,17h-5 C6.224,17,6,16.776,6,16.5z M20,12.5c0-0.276,0.224-0.5,0.5-0.5h5c0.276,0,0.5,0.224,0.5,0.5S25.776,13,25.5,13h-5 C20.224,13,20,12.776,20,12.5z M20,14.5c0-0.276,0.224-0.5,0.5-0.5h5c0.276,0,0.5,0.224,0.5,0.5S25.776,15,25.5,15h-5 C20.224,15,20,14.776,20,14.5z M20,16.5c0-0.276,0.224-0.5,0.5-0.5h5c0.276,0,0.5,0.224,0.5,0.5S25.776,17,25.5,17h-5 C20.224,17,20,16.776,20,16.5z"></path></symbol></defs></svg> <header class="bar-header"> <a id="menu" role="button"> <svg id="open" class="icon-menu"><use xlink:href="#icon-menu"></use></svg> </a> <h1 class="logo"> <a href="/"> Jekflix <span class="version">v3.1.2</span> </a> </h1> <a id="search" class="dosearch" role="button"> <svg class="icon-search"><use xlink:href="#icon-search"></use></svg> </a> <a href="https://github.com/thiagorossener/jekflix-template" class="get-theme" role="button"> Get this theme! </a> </header> <div id="mask" class="overlay"></div> <aside class="sidebar" id="sidebar"> <nav id="navigation"> <h2>Menu</h2> <ul> <li> <a href="http://localhost:4000/">Home</a> </li> <li> <a href="http://localhost:4000/about">About</a> </li> <li> <a href="http://localhost:4000/contact">Contact</a> </li> <li> <a href="http://localhost:4000/feed.xml">Feed</a> </li> </ul> </nav> </aside> <div class="search-wrapper"> <div class="search-form"> <input type="text" class="search-field" placeholder="Search"> <svg class="icon-remove-sign"><use xlink:href="#icon-close"></use></svg> <ul class="search-results search-list"></ul> </div> </div> <section class="content"> <div id="main" role="main"> <article class="page h-entry" itemscope itemtype="https://schema.org/CreativeWork"> <meta itemprop="headline" content="[System Programming] 9-1장. 프로세스 제어"> <meta itemprop="description" content=""> <meta itemprop="datePublished" content="2022-05-11T00:00:00+09:00"> <div class="page__inner-wrap"> <header> <h1 id="page-title" class="page__title p-name" itemprop="headline"> <a href="http://localhost:4000/System-Programming-9-1%EC%9E%A5.-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%A0%9C%EC%96%B4/" class="u-url" itemprop="url">[System Programming] 9-1장. 프로세스 제어 </a> </h1> </header> <section class="page__content e-content" itemprop="text"> <p><br /></p> <h2 id="set-user-id-실행파일-review">set-user-id 실행파일 (Review)</h2> <ul> <li>특별한 실행권한 set-user-id(set user ID upon execution) <ul> <li>set-user-id 설정된 실행파일을 실행하면</li> <li>이 프로세스의 유효 사용자 ID는 그 실행파일의 소유자로 바뀜. <ul> <li>프로세스의 실제 사용자 ID (real user ID)는 그 프로세스를 실행한 원래 사용자의 사용자 ID로 설정된다.</li> <li>예를 들어 chang이라는 사용자 ID로 로그인하여 어떤 프로그램을 실행 시키면 그 프로세스의 실제 사용자 ID는 chang이 된다. <ul> <li>effective ID는 chang이 아니라 그 파일의 소유자</li> </ul> </li> </ul> </li> <li>이 프로세스는 실행되는 동안 그 파일의 소유자 권한을 갖게 됨.</li> </ul> </li> <li>예 : /usr/bin/passwd 명령어 실행 파일 <ul> <li>set-user-id 실행권한이 설정된 실행파일이며 소유자는 root</li> <li>일반 사용자가 쉘에서 이 파일을 실행하게 되면, 이 프로세스의 유효 사용자 ID는 root가 됨.</li> <li>/etc/passwd처럼 root만 수정할 수 있는 파일의 접근 및 수정 가능</li> </ul> </li> </ul> <p><br /></p> <h2 id="set-user-id-and-set-group-id-review">Set-user-ID and set-group-ID (Review)</h2> <ul> <li>passwd program를 이용하여 password를 바꿀 경우 <ul> <li>passwd program을 실행하는 도중 잠정적으로 root의 권한을 부여받음. <ul> <li>Real user ID of passwd program: user 새로운 프로세스 생성 시 부모의 사용자 ID와 그룹 ID를 그대로 물려 받음</li> <li>Effective user ID of passwd program: root</li> </ul> </li> </ul> </li> </ul> <p><img src="https://user-images.githubusercontent.com/79521972/168040951-edbf54bf-3a4a-4c73-bede-202150cce55c.png" alt="image" /></p> <p><br /></p> <h1 id="91-프로세스-생성">9.1 프로세스 생성</h1> <h2 id="프로세스-생성">프로세스 생성</h2> <ul> <li>fork() 시스템 호출 <ul> <li>부모 프로세스를 똑같이 복제하여 새로운 자식 프로세스를 생성</li> <li>자기복제(自己複製)</li> </ul> </li> </ul> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="n">pid_t</span> <span class="nf">fork</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</code></pre></div></div> <ul> <li>새로운 자식 프로세스를 생성한다.</li> <li>It is called once but returns twice.</li> <li>자식 프로세스에게는 0을 리턴하고 부모 프로세스에게는 자식 프로 세스 ID를 리턴한다</li> </ul> <p><br /></p> <ul> <li> <p>The child is a copy of parent.</p> <ul> <li> <p>Child gets a copy of the parent‘s data, heap, and stack.</p> </li> <li>Parent and child often share the text segment. <ul> <li>실행 중에 코드는 수정되지 않기 때문에</li> </ul> </li> <li>data, heap, stack은 공유하지 않는다. <ul> <li>global 변수는 data 영역이기 때문에 이를 공유하지 않는 것</li> </ul> </li> </ul> </li> </ul> <p><img src="https://user-images.githubusercontent.com/79521972/168041237-acd87a67-ab92-40f4-839f-7fc8a6819b9f.png" alt="image" /></p> <ul> <li> <p>부모 프로세스의 pid에는 자식 프로세스의 pid인 15066이 들어가고 자식 프로세스의 pid에는 0의 값이 들어가게 된다.</p> </li> <li> <p>PC값도 부모 프로세스가 갖던 값과 동일한 값을 갖게 된다.</p> </li> </ul> <p><br /></p> <h2 id="프로세스-주소공간">프로세스 주소공간</h2> <p><img src="https://user-images.githubusercontent.com/79521972/168041327-27db91ef-096d-4a90-9973-1afe1776f776.png" alt="image" /></p> <p>변수는 선언과 동시에 초기화를 보통 하는데 그렇지 않은 부분도 있다. -&gt; bss: generally 0으로 초기화</p> <p>heap 구역은 동적 변수가 들어가는 곳</p> <p>정적 변수는 컴파일 될 때 생성된다.</p> <p><br /></p> <h2 id="프로세스-생성-1">프로세스 생성</h2> <ul> <li>fork()는 한 번 호출되지만 두 번 리턴한다. <ul> <li>자식 프로세스에게는 0을 리턴하고</li> <li>부모 프로세스에게는 자식 프로세스 ID를 리턴한다.</li> <li>부모 프로세스와 자식 프로세스는 병행적(concurrently)으로 각각 fork() 이후 문장의 실행을 계속한다.</li> <li>즉, thread control이 두 개 이상이 된다.</li> </ul> </li> </ul> <p><br /></p> <h2 id="fork1c">fork1.c</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cm">/* 자식 프로세스를 생성한다. */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
     <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">"[%d] 프로세스 시작 </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
     <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">"[%d] 프로세스 : 리턴값 %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(),</span> <span class="n">pid</span><span class="p">);</span> <span class="c1">//두 번 실행</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>fork1
<span class="o">[</span>15065] 프로세스 시작
<span class="o">[</span>15065] 프로세스 : 반환값 15066
<span class="o">[</span>15066] 프로세스 : 반환값 0
</code></pre></div></div> <p><br /></p> <h2 id="부모-프로세스와-자식-프로세스-구분">부모 프로세스와 자식 프로세스 구분</h2> <ul> <li>fork() 호출 후에 리턴값이 다르므로 이 리턴값을 이용하여</li> <li>부모 프로세스와 자식 프로세스를 구별하고</li> <li>서로 다른 일을 하도록 할 수 있다.</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pid = fork();
if ( pid == 0 )
{ 자식 프로세스의 실행 코드 }
else
{ 부모 프로세스의 실행 코드 }
</code></pre></div></div> <p><br /></p> <h2 id="fork2c">fork2.c</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cm">/* 부모 프로세스가 자식 프로세스를 생성하고 서로 다른 메시지를 프린트 */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
<span class="p">{</span>
     <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span> 
     <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 자식 프로세스</span>
         <span class="n">printf</span><span class="p">(</span><span class="s">"[Child] : Hello, world pid=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
     <span class="p">}</span>
     <span class="k">else</span> <span class="p">{</span> <span class="c1">// 부모 프로세스</span>
         <span class="n">printf</span><span class="p">(</span><span class="s">"[Parent] : Hello, world pid=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
     <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>fork2
<span class="o">[</span>Parent] : Hello, world <span class="nv">pid</span><span class="o">=</span>15799
<span class="o">[</span>Child] : Hello, world <span class="nv">pid</span><span class="o">=</span>15800
</code></pre></div></div> <p>parent와 chile의 실행 순서는 중요하지 않음</p> <p><br /></p> <h2 id="fork3c-두-개의-자식-프로세스-생성">fork3.c: 두 개의 자식 프로세스 생성</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cm">/* 부모 프로세스가 두 개의 자식 프로세스를 생성한다. */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span> 
    <span class="kt">int</span> <span class="n">pid1</span><span class="p">,</span> <span class="n">pid2</span><span class="p">;</span>
    <span class="n">pid1</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pid1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[Child 1] : Hello, world ! pid=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">//child process 종료</span>
    <span class="p">}</span>
    <span class="n">pid2</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pid2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[Child 2] : Hello, world ! pid=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>fork3
<span class="o">[</span>Child1] : Hello, world! <span class="nv">pid</span><span class="o">=</span>15741
<span class="o">[</span>Child2] : Hello, world! <span class="nv">pid</span><span class="o">=</span>15742
</code></pre></div></div> <p><br /></p> <h2 id="fork">fork()</h2> <p>13페이지</p> <ul> <li>Example</li> </ul> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"apue.h"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="n">glob</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="cm">/* external variable in initialized data */</span>
<span class="kt">char</span> <span class="n">buf</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"a write to stdout</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">var</span><span class="p">;</span> <span class="cm">/* automatic variable on the stack */</span> <span class="c1">//uninitialized data</span>
    <span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
    
    <span class="n">var</span> <span class="o">=</span> <span class="mi">88</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">"write error"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"before fork</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="cm">/* we don't flush stdout */</span>
    
    <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">"fork error"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* child */</span>
        <span class="n">glob</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* modify variables */</span>
        <span class="n">var</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="cm">/* parent */</span>
    <span class="p">}</span>
    
    <span class="n">printf</span><span class="p">(</span><span class="s">"pid = %d, glob = %d, var = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(),</span> <span class="n">glob</span><span class="p">,</span> <span class="n">var</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li>실행</li> </ul> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./a.out
a write to stdout
before fork
pid <span class="o">=</span> 430, glob <span class="o">=</span> 7, var <span class="o">=</span> 89
pid <span class="o">=</span> 429, glob <span class="o">=</span> 6, var <span class="o">=</span> 88
<span class="nv">$ </span>./a.out <span class="o">&gt;</span> temp.out
<span class="nv">$ </span><span class="nb">cat </span>temp.out
a write to stdout
before fork
pid <span class="o">=</span> 432, glob <span class="o">=</span> 7, var <span class="o">=</span> 89
before fork
pid <span class="o">=</span> 431, glob <span class="o">=</span> 6, var <span class="o">=</span> 88
<span class="err">$</span>
</code></pre></div></div> <blockquote> <p>We never know if the child starts executing before the parent or vice versa. - It depends on the process scheduling algorithm.</p> </blockquote> <p><br /></p> <h2 id="fork-1">fork()</h2> <ul> <li>Information <strong>shared</strong> by child and parent. <ul> <li>real-uid(gid), effective-uid(gid)</li> <li>controlling terminal</li> <li>current working directory, root directory</li> <li>signal handlers : 이벤트 발생 통지 수단</li> <li>environment</li> <li>resource limits</li> </ul> </li> <li><strong>differences</strong> between child and parent. <ul> <li>the return value from fork.</li> <li>PID and PPID</li> <li>child‘s resource utilizations are set to 0.</li> <li>pending signals - signal handler는 공유되지만 signal 그 자체는 공유 x</li> </ul> </li> <li>Two main reasons for fork to fail <ul> <li>if there are already too many processes in the system.</li> <li>if the total number of processes for this real user ID exceeds the system‘s limit.</li> </ul> </li> <li>Two uses for fork (왜 fork를 하는가?) <ul> <li>A process wants to duplicate itself. <ul> <li>Parent and child can each execute different sections of code at the same time.</li> <li>Common for <strong>network servers.</strong></li> </ul> </li> <li>A process wants to execute a different program. <ul> <li>Common for shells.</li> <li>Child does exec() right after it returns from fork().</li> </ul> </li> </ul> </li> </ul> <p><br /></p> <h2 id="쉘의-구조-revisit">쉘의 구조 (revisit)</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">While</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">display</span> <span class="n">prompt</span>
    <span class="n">read</span> <span class="n">command</span> <span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span> <span class="c1">// Get command or execution file</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fork</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">then</span> <span class="p">{</span> <span class="c1">// Execute command or execution file</span>
		<span class="n">wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">status</span><span class="p">);</span> <span class="c1">// fork a child, wait for a child to finish</span>
		<span class="n">exit</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">else</span>
		<span class="n">execve</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">parmas</span><span class="p">)</span> <span class="c1">// 자식 프로세스</span>
	<span class="p">}</span> <span class="c1">// 입력된 명령어를 실행</span>
</code></pre></div></div> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">ls</span>
<span class="nb">.</span> .. /etc
/home /usr /dev
<span class="nv">$ </span>a.out
….
<span class="err">$</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while(true){
	display prompt
	read command(command, params)
	if (fork()!=0) then {
		wait(&amp;status);
		exit()
	}
	else
		exec(command, params)
}
</code></pre></div></div> <p><br /></p> <h2 id="sigchld">SIGCHLD</h2> <ul> <li>When a process terminates, the kernel sends the signal SIGCHLD to the parent. <ul> <li>By default, this signal is ignored, and no action is taken by the parent.</li> </ul> </li> <li>Processes can elect to handle this signal, however, via the signal( ) or sigaction( ) system calls</li> <li>The SIGCHLD signal may be generated and dispatched at any time, as a child‘s termination is <strong>asynchronous</strong> with respect to its parent. <ul> <li>따라서 발생 시점 예측 불가.</li> </ul> </li> <li>But often, the parent wants to learn more about its child‘s termination, or even explicitly wait for the event‘s occurrence.</li> <li>This is possible with the <strong>wait</strong> system calls</li> </ul> <p><br /></p> <h2 id="wait-and-waitpid">wait() and waitpid()</h2> <ul> <li>A process that calls wait() or waitpid() <ul> <li>Block, if all of its children are still running.</li> <li>Return immediately if a child has terminated.</li> <li>Return immediately with an error, if it doesn’t have any child processes.(부모 프로세스가 child 프로세스를 생성하지 않았을 때) <ul> <li>fork를 하지 않고 wait -&gt; 즉시 return</li> </ul> </li> </ul> </li> </ul> <p><img src="https://user-images.githubusercontent.com/79521972/168042761-9c5f5129-89a4-41d8-9aa4-eca3704d3c21.png" alt="image" /></p> <p><br /></p> <h2 id="프로세스-기다리기-wait">프로세스 기다리기: wait()</h2> <ul> <li>자식 프로세스 중의 하나가 끝날 때까지 기다린다. <ul> <li>끝난 자식 프로세스의 종료 코드가 status에 저장되며</li> <li>끝난 자식 프로세스의 번호를 리턴한다. 오류시 -1 리턴</li> </ul> </li> </ul> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span><span class="n">pid_t</span> <span class="nf">wait</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">status</span><span class="p">);</span>
<span class="n">pid_t</span> <span class="nf">waitpid</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">statloc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">options</span><span class="p">);</span>
</code></pre></div></div> <p><img src="https://user-images.githubusercontent.com/79521972/168042879-498d3d6d-22ac-447b-b392-156d249516ff.png" alt="image" /></p> <p>파란색 선은 block하고 있다는 뜻</p> <p><br /></p> <h2 id="wait">wait()</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span>
<span class="n">pid_t</span> <span class="nf">wait</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">statloc</span><span class="p">);</span>
 		<span class="n">Both</span> <span class="k">return</span><span class="o">:</span> <span class="n">process</span> <span class="n">ID</span> <span class="k">if</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="p">(</span><span class="n">see</span> <span class="n">later</span><span class="p">),</span> <span class="n">or</span> <span class="o">-</span><span class="mi">1</span> <span class="n">on</span> <span class="n">error</span> 
</code></pre></div></div> <ul> <li>wait() <ul> <li>If a child has already terminated and is a zombie, wait <strong>returns immediately</strong> with that child’s status.</li> <li>Otherwise, it blocks the caller until a child terminates.</li> <li>If the caller blocks and has multiple children, wait returns when one terminates.</li> </ul> </li> <li>statloc argument <ul> <li>Pointer to integer</li> <li>Store termination <strong>status</strong> (in case of normal termination) in the location pointed to by staloc. <ul> <li>And <strong>signal number</strong> (abnormal termination) <ul> <li>왜 비정상 종료가 되었는지를 나타내는 정보</li> </ul> </li> <li>And if core file was created</li> </ul> </li> </ul> </li> </ul> <p><br /></p> <h2 id="forkwaitc">forkwait.c</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="c1"> …</span><span class="cp">
</span><span class="cm">/* 부모 프로세스가 자식 프로세스를 생성하고 끝나기를 기다린다. */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">pid</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">status</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[%d] 부모 프로세스 시작 </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(</span> <span class="p">));</span> 
    <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span> 
    <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> 
        <span class="n">printf</span><span class="p">(</span><span class="s">"[%d] 자식 프로세스 시작 </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(</span> <span class="p">));</span> 
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">child</span> <span class="o">=</span> <span class="n">wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">status</span><span class="p">);</span> <span class="c1">// 자식 프로세스가 끝나기를 기다린다.</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[%d] 자식 프로세스 %d 종료 </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(),</span> <span class="n">child</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">종료 코드 %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">status</span><span class="o">&gt;&gt;</span><span class="mi">8</span><span class="p">);</span> <span class="c1">//종료코드값은 4바이트 중 3번째 바이트임 -&gt; 8 shift</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>forkwait
<span class="o">[</span>15943] 부모 프로세스 시작
<span class="o">[</span>15944] 자식 프로세스 시작
<span class="o">[</span>15943] 자식 프로세스 15944 종료
종료코드 1
</code></pre></div></div> <p><br /></p> <h2 id="macros-for-interpreting-the-termination-status">macros for interpreting the termination status</h2> <p>termination status를 해석하기 위한 매크로 함수 - WIF</p> <ul> <li>If not NULL, the status pointer contains additional information about the child (how the process terminated)</li> <li>#include &lt;sys/wait.h&gt;</li> <li>WIFEXITED (status); <ul> <li>returns true if the child process terminated <strong>normally</strong></li> <li>정상적으로 종료한 경우에 참(<strong>TRUE</strong>) 값을 리턴</li> <li>WEXITSATUS(status) <ul> <li>WIFEXITED()가 True이면 exit 함수의 인자에서 하위 8 비트 값을 리턴</li> </ul> </li> </ul> </li> <li>WIFSIGNALED (status); <ul> <li>returns <strong>true</strong> if a signal that it <strong>did not catch</strong> caused the child process‘ termination (abnormal)</li> <li>WTERMSIG(status) : if WIFSIGNALED is True, <strong>fetch the signal numbe</strong>r that caused the termination.</li> </ul> </li> <li>WIFSTOPPED (status); <ul> <li>Child 프로세스가 실행이 <strong>일시 중단</strong>된 경우에 참 값을 리턴</li> <li>WSTOPSIG(status) <ul> <li>if WIFSTOPPED is True, Child 프로세스의 실행을 일시 중단시킨 시그널 번호를 리턴</li> </ul> </li> </ul> </li> <li>WIFCONTINUED (status); <ul> <li>return true if the process was continued, and is currently being traced via the ptrace( ) system call\</li> <li>중요 x</li> </ul> </li> </ul> <p><br /></p> <ul> <li>A process that calls wait or waitpid can <ul> <li><strong>block</strong> (if all of its children are <strong>still running</strong>), or <ul> <li>wait() is called at any random point in time</li> </ul> </li> <li><strong>return</strong> immediately with the termination status of a child, (SIGCHLD-asynchronous notification) or <ul> <li>예를 들어 zombie process 같은 경우</li> </ul> </li> <li>return immediately with an error (<strong>if it doesn‘t have any child processes</strong>) errno value:</li> <li><strong>ECHILD</strong> - The calling process does not have any children.</li> </ul> </li> </ul> <p><br /></p> <h2 id="wait-macros-for-interpreting-the-termination-status">wait(): macros for interpreting the termination status</h2> <ul> <li>Example</li> </ul> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span><span class="kt">void</span> <span class="nf">pr_exit</span><span class="p">(</span><span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">WIFEXITED</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="c1">//case 1</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"normal termination, exit status = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">WEXITSTATUS</span><span class="p">(</span><span class="n">status</span><span class="p">));</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">WIFSIGNALED</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="c1">// case 2</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"abnormal termination, signal number = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">WTERMSIG</span><span class="p">(</span><span class="n">status</span><span class="p">));</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">WIFSTOPPED</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="c1">// case 3</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"child stopped, signal number = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">WSTOPSIG</span><span class="p">(</span><span class="n">status</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div> <p><br /></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"fork error"</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="cm">/* child */</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">status</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pid</span><span class="p">)</span> <span class="cm">/* wait for child */</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"wait error"</span><span class="p">);</span>
    <span class="n">pr_exit</span><span class="p">(</span><span class="n">status</span><span class="p">);</span> <span class="cm">/* and print its status */</span> <span class="c1">// case 1 실행</span>
    
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"fork error"</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="cm">/* child */</span>
        <span class="n">abort</span><span class="p">();</span> <span class="cm">/* generates SIGABRT */</span> <span class="c1">// 비정상 종료</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">status</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pid</span><span class="p">)</span> <span class="cm">/* wait for child */</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"wait error"</span><span class="p">);</span>
    <span class="n">pr_exit</span><span class="p">(</span><span class="n">status</span><span class="p">);</span> <span class="cm">/* and print its status */</span> <span class="c1">//case 2 실행</span>
    
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"fork error"</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="cm">/* child */</span>
        <span class="n">status</span> <span class="o">/=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* divide by 0 generates SIGFPE */</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">status</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pid</span><span class="p">)</span> <span class="cm">/* wait for child */</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"wait error"</span><span class="p">);</span>
    <span class="n">pr_exit</span><span class="p">(</span><span class="n">status</span><span class="p">);</span> <span class="cm">/* and print its status */</span> <span class="c1">// case2 실행</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li>실행</li> </ul> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./a.out
normal termination, <span class="nb">exit </span>status <span class="o">=</span> 7
abnormal termination, signal number <span class="o">=</span> 6
abnormal termination, signal number <span class="o">=</span> 8
<span class="err">$</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Each signal number is defined in &lt;signal.h&gt;
SIGABRT: 6
SIGFPE: 8
</code></pre></div></div> <p><br /></p> <h2 id="waitc">wait.c</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
    <span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fork</span> <span class="p">(</span> <span class="p">))</span> <span class="c1">//child</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">pid</span> <span class="o">=</span> <span class="n">wait</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">status</span><span class="p">);</span> <span class="c1">//parent</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">//error</span>
        <span class="n">perror</span> <span class="p">(</span><span class="s">"wait"</span><span class="p">);</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">"pid=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">WIFEXITED</span> <span class="p">(</span><span class="n">status</span><span class="p">))</span>
        <span class="n">printf</span> <span class="p">(</span><span class="s">"Normal termination with exit status=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">WEXITSTATUS</span> <span class="p">(</span><span class="n">status</span><span class="p">));</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">WIFSIGNALED</span> <span class="p">(</span><span class="n">status</span><span class="p">))</span>
        <span class="n">printf</span> <span class="p">(</span><span class="s">"Killed by signal=%d%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">WTERMSIG</span> <span class="p">(</span><span class="n">status</span><span class="p">),</span> <span class="n">WCOREDUMP</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="o">?</span> <span class="s">"(dumped core)"</span> <span class="o">:</span> <span class="s">""</span><span class="p">);</span>
    
	<span class="k">if</span> <span class="p">(</span><span class="n">WIFSTOPPED</span> <span class="p">(</span><span class="n">status</span><span class="p">))</span>
		<span class="n">printf</span> <span class="p">(</span><span class="s">"Stopped by signal=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">WSTOPSIG</span> <span class="p">(</span><span class="n">status</span><span class="p">));</span>
    
	<span class="k">if</span> <span class="p">(</span><span class="n">WIFCONTINUED</span> <span class="p">(</span><span class="n">status</span><span class="p">))</span>
		<span class="n">printf</span> <span class="p">(</span><span class="s">"Continued</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./wait
<span class="nv">pid</span><span class="o">=</span>8529
Normal termination with <span class="nb">exit </span><span class="nv">status</span><span class="o">=</span>1
</code></pre></div></div> <p><br /></p> <ul> <li>If, instead of having the child return, we have it call abort( ), which sends itself the SIGABRT signal, we will instead see something resembling the following:</li> </ul> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./wait
<span class="nv">pid</span><span class="o">=</span>8678
Killed by <span class="nv">signal</span><span class="o">=</span>6
</code></pre></div></div> <p><br /></p> <h2 id="waiting-for-a-specific-process">Waiting for a Specific Process</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span><span class="n">pid_t</span> <span class="nf">waitpid</span> <span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">status</span><span class="p">,</span> <span class="kt">int</span> <span class="n">options</span><span class="p">);</span>
	<span class="k">return</span><span class="o">:</span> <span class="n">process</span> <span class="n">ID</span> <span class="k">if</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="p">(</span><span class="n">see</span> <span class="n">later</span><span class="p">),</span> <span class="n">or</span> <span class="o">-</span><span class="mi">1</span> <span class="n">on</span> <span class="n">error</span>
</code></pre></div></div> <ul> <li>Why waitpid() is required? <ul> <li>a process has multiple children, and does not wish to wait for all of them, but <strong>rather for a specific child process</strong></li> <li>wait() returns on termination of any of the children.</li> </ul> </li> <li>One solution would be to make multiple invocations of wait( ), each time noting the return value <ul> <li>wait() 여러번 호출하면서 자기가 생성한 것이 맞는지 확인 -&gt; 번거로움</li> </ul> </li> <li>If you know the pid of the process you want to wait for, you can use the waitpid( ) system call</li> <li>The waitpid( ) call is a more <strong>powerful</strong> version of wait( ). Its additional parameters allow for fine-tuning <ul> <li>Provides some controls with <strong>options</strong> argument</li> </ul> </li> </ul> <p><br /></p> <h2 id="pid_t-waitpidpid_t-pid-int-statloc-int-options">pid_t waitpid(pid_t pid, int *statloc, int options);</h2> <ul> <li>The pid parameter specifies exactly which process or processes to wait for.</li> <li>pid == -1 <ul> <li>Wait for <strong>any child process</strong>. This is the same behavior as wait( ).</li> </ul> </li> <li>pid &gt; 0 <ul> <li>Wait for any child process whose pid is exactly the value provided. For example, passing 500 waits for the child process with pid 500</li> <li>pid가 500인 프로세스가 종료되었을 때만 깨워달라</li> </ul> </li> <li>pid == 0 <ul> <li>Wait for any child process that belongs to the same process group as the calling process.</li> <li>나하고 같은 process group인 경우이기만 하면 어떤 child process든지 종료되면 깨워달라</li> </ul> </li> <li>pid &lt; -1 <ul> <li>Wait for any child process whose process group ID is equal to the <strong>absolute value</strong> of this value. <ul> <li>For example, passing -500 waits for any process in process group 500.</li> </ul> </li> </ul> </li> </ul> <p><br /></p> <h3 id="waitpid-option-parameter">waitpid option parameter</h3> <ul> <li>The status parameter works identically to the sole parameter to wait( )</li> <li>option - &gt; <strong>부모 프로세스의 대기 방법</strong></li> <li><strong>WNOHANG</strong> <ul> <li><strong>Do not block</strong>, but <strong>return</strong> immediately <strong>if no matching child process has already terminated</strong> (or stopped or continued) <ul> <li>if a child specified by pid is not terminated.</li> </ul> </li> </ul> </li> <li><strong>WUNTRACED</strong> <ul> <li>Do not block if a child specified by pid has stopped.</li> <li>If set, WIFSTOPPED is set, even if the calling process is not tracing the child process.</li> <li>실행을 중단한 자식 프로세스의 상태값을 리턴</li> <li>This flag allows for the implementation of more general job control, as in a shell.</li> </ul> </li> <li>WCONTINUED <ul> <li>If set, WIFCONTINUED is set even if the calling process is <strong>not tracing</strong> the child process.</li> <li>수행중인 자식 프로세스의 상태값 리턴</li> <li>As with WUNTRACED, this flag is useful for implementing a shell</li> </ul> </li> <li>wait (&amp;status); <ul> <li>is identical to waitpid (-1, &amp;status, 0);</li> <li>0 -&gt; no option</li> </ul> </li> </ul> <p><br /></p> <h2 id="wait-and-waitpid-1">wait() and waitpid()</h2> <ul> <li>Example</li> </ul> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"apue.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">"fork error"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* first child */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">err_sys</span><span class="p">(</span><span class="s">"fork error"</span><span class="p">);</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="cm">/* parent from second fork == first child */</span>
        <span class="cm">/* We're the second child; our parent becomes init. */</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"second child, parent pid = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getppid</span><span class="p">());</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pid</span><span class="p">)</span> <span class="cm">/* wait for first child */</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">"waitpid error"</span><span class="p">);</span>
    <span class="cm">/*
 * We're the parent (the original process); we continue executing,
 * knowing that we're not the parent of the second child.
 */</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./a.out
<span class="nv">$ </span>second child, parent pid <span class="o">=</span> 1
</code></pre></div></div> <p><br /></p> <h2 id="pid-1742인-자식프로세스를-wait-waitpid-자식이-종료-안된-경우-즉시-리턴">PID 1742인 자식프로세스를 wait (waitpid) 자식이 종료 안된 경우 즉시 리턴</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
<span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
<span class="n">pid</span> <span class="o">=</span> <span class="n">waitpid</span> <span class="p">(</span><span class="mi">1742</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="n">WNOHANG</span><span class="p">);</span> <span class="c1">// 바로 리턴 (종료를 하지 않더라도)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">perror</span> <span class="p">(</span><span class="s">"waitpid"</span><span class="p">);</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">"pid=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">WIFEXITED</span> <span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="c1">// status check macro function</span>
        <span class="n">printf</span> <span class="p">(</span><span class="s">"Normal termination with exit status=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">WEXITSTATUS</span> <span class="p">(</span><span class="n">status</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">WIFSIGNALED</span> <span class="p">(</span><span class="n">status</span><span class="p">))</span>
        <span class="n">printf</span> <span class="p">(</span><span class="s">"Killed by signal=%d%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">WTERMSIG</span> <span class="p">(</span><span class="n">status</span><span class="p">),</span> <span class="n">WCOREDUMP</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="o">?</span> <span class="s">" (dumped core)"</span> <span class="o">:</span> <span class="s">""</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><br /></p> <h2 id="zombies">Zombies</h2> <ul> <li>부모 프로세스가 wait()이나 waitpid()를 호출하기 이전에 자식 프로세스가 이미 종료가 돼버린 프로세스를 zombie process라고 한다. <ul> <li>사실상 가비지 개념으로 봐도 된다.</li> </ul> </li> <li>a process that has terminated, but that has not yet been waited upon by its parent is called a “zombie” <ul> <li>좀비 프로세스는 프로세스 테이블에만 존재</li> </ul> </li> <li>Zombie processes continue to consume system resources</li> <li>wait() returns immediately with that child‘s status</li> <li>These resources remain so that parent processes that want to <strong>check up</strong> on the status of their children can obtain <strong>information</strong> relating to the <strong>life</strong> and <strong>termination of those processes</strong>.</li> <li>Once the parent does so, the kernel <strong>cleans up</strong> the process for good and the zombie ceases(stop) to exist.</li> </ul> <p><br /></p> <h2 id="waitpidc">waitpid.c</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span><span class="err">…</span>
<span class="cm">/* 부모 프로세스가 자식 프로세스를 생성하고 끝나기를 기다린다. */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">pid1</span><span class="p">,</span> <span class="n">pid2</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">status</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[%d] 부모 프로세스 시작 </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(</span> <span class="p">));</span>
    <span class="n">pid1</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pid1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[%d] 자식 프로세스[1] 시작 </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(</span> <span class="p">));</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[%d] 자식 프로세스[1] 종료 </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(</span> <span class="p">));</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">pid2</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span> <span class="c1">// 자식 프로세스가 돌고 있는 도중에도 이를 실행</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pid2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[%d] 자식 프로세스 [2] 시작 </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(</span> <span class="p">));</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[%d] 자식 프로세스 [2] 종료 </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(</span> <span class="p">));</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 자식 프로세스 #1의 종료를 기다린다.</span>
    <span class="n">child</span> <span class="o">=</span> <span class="n">waitpid</span><span class="p">(</span><span class="n">pid1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">//option 0: 자식프로세스가 종료할때까지 wait</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[%d] 자식 프로세스 [1] %d 종료 </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(</span> <span class="p">),</span> <span class="n">child</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">종료 코드 %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">status</span><span class="o">&gt;&gt;</span><span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>waitpid
<span class="o">[</span>16840] 부모 프로세스 시작
<span class="o">[</span>16841] 자식 프로세스[1] 시작
<span class="o">[</span>16842] 자식 프로세스[2] 시작
<span class="o">[</span>16841] 자식 프로세스[1] 종료
<span class="o">[</span>16840] 자식 프로세스[1] 16841 종료
종료코드 1
<span class="o">[</span>16842] 자식 프로세스[2] 종료
</code></pre></div></div> <p>sleep이 영향을 미친다.</p> <p><br /></p> <h2 id="fork-후에-파일-공유">fork() 후에 파일 공유</h2> <ul> <li>자식은 부모의 fd 테이블을 복사한다. <ul> <li>부모와 자식이 <strong>같은 파일 디스크립터를 공유</strong> (FD table, U area 복사)</li> <li>같은 파일 오프셋을 공유</li> <li>부모와 자식으로부터 출력이 서로 <strong>섞이게 됨</strong></li> </ul> </li> <li>자식에게 상속되지 않는 성질 <ul> <li>fork()의 반환값 <ul> <li>리턴을 두 번 함</li> </ul> </li> <li>프로세스 ID</li> <li>부모 프로세스가 설정한 프로세스 잠금, 파일 잠금</li> <li>설정된 알람과 시그널</li> </ul> </li> </ul> <p><br /></p> <h2 id="fork-2">fork()</h2> <p><img src="https://user-images.githubusercontent.com/79521972/168189002-751ff4cb-edf9-4626-861f-da0f4cf94b17.png" alt="image" /></p> <p>자식 프로세스가 생성되면 동일한 내용의 file descriptor를 그대로 복사하고 open file table 뒷단은 모두 공유하게 된다.(같은 곳을 가리킴)</p> <ul> <li>per process table</li> </ul> <p>같은 open file entry를 공유하기 때문에 파일 오프셋이 공유되어 둘이 같이 파일을 작성하면 부모와 자식으로부터 출력이 서로 섞일 수 있음</p> <p><br /></p> <h2 id="copy-on-write">Copy-on-write</h2> <p>fork() 의 효율성을 높이기 위한 방법</p> <ul> <li>Copy-on-write is a <strong>lazy optimization strategy</strong> designed to mitigate the overhead of duplicating resources. <ul> <li>자식의 duplication을 가능한한 지연</li> </ul> </li> <li>The premise is simple: <ul> <li>if multiple consumers request <strong>read access</strong> to their own copies of a resource, <strong>duplicate</strong> copies of the resource need not be made. Instead, each consumer <strong>can be handed a pointer</strong> to the <strong>same resource</strong>. (처음부터 fork하면 바로 copy하지 않도록 -&gt; 같은 resource로 포인트로 hand)</li> </ul> </li> <li>So long as no consumer attempts to modify its “copy” of the resource, the illusion of exclusive access to the resource remains, and the overhead of a copy is avoided. <ul> <li>자기 만의 resource를 가진다고 착각</li> </ul> </li> <li>If a consumer does attempt to <strong>modify</strong> its copy of the resource, at that point, the resource is transparently duplicated, and the copy is given to the modifying consumer</li> <li>modify가 일어나지 않은 경우에는 한 개의 copy만 가지고 공유하도록 하다가 만약 두 프로세스 중에서 한 프로세스가 modify 하게 되면 그제서야 비로소 lazy하게 뒤늦게 copy를 만들어준다.</li> </ul> <p><br /></p> <h2 id="fork-3">fork()</h2> <p><strong>Copy on write</strong></p> <p><img src="https://user-images.githubusercontent.com/79521972/168189249-70076eb1-83c5-40e6-83d2-c388cdc87bfd.png" alt="image" /></p> <ul> <li>After parent process write a page C.</li> </ul> <p><img src="https://user-images.githubusercontent.com/79521972/168189298-84a8013c-2960-49dd-879d-d50f0b87ef3e.png" alt="image" /></p> <p>read만 하면 포인터를 공유</p> <p>c만 modify를 하고자 하면 별도의 copy본을 만들어 각자 다른 것을 가리키게 하는 것이다.</p> <p><br /></p> <h2 id="vfork">Vfork()</h2> <ul> <li>Creates a new process <strong>only to exec a new program</strong> <ul> <li>완전히 새로운 program을 실행시키기 위한 목적으로만 사용</li> <li>No copy of parent’s address space for child (not needed!)</li> <li>Before exec, child runs in “address space of parent” <ul> <li>주소 공간을 달리하지 않고 parent의 주소 공간에서 실행</li> </ul> </li> <li>Efficient in paged virtual memory</li> </ul> </li> <li><strong>Child runs first</strong> <ul> <li>Parent waits until child exec or exit (block) <ul> <li>Then the parent resume</li> </ul> </li> <li>The deadlock(block된 상태) possibility if the child wait for something from the parent <ul> <li>부모의 자원을 필요로하는 경우 -&gt; deadlock 발생 가능 -&gt; 굉장히 복잡한 동기화 기술로 해결</li> </ul> </li> </ul> </li> </ul> <p><br /></p> <h2 id="vfork-1">vfork()</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="n">pid_t</span> <span class="nf">vfork</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
 	<span class="c1">//Returns: 0 in child, process ID of child in parent, -1 on error </span>
</code></pre></div></div> <ul> <li>same calling sequence and same return values as fork().</li> <li>intended to create a new process when the purpose of the new process is to exec() a new program. <ul> <li>Does not copy the address space of parent into the child.</li> <li>The child calls exec() or exit() right after the vfork().</li> <li>The child runs <strong>in the address space of the parent</strong>. (exec() 전까지는)</li> <li>Provides an efficiency. <ul> <li>exec이 바로 호출되는 경우에 효율적임</li> </ul> </li> </ul> </li> <li>vfork() guarantees that the child runs first.</li> </ul> <p><br /></p> <ul> <li>Example</li> </ul> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"apue.h“
int glob = 6; /* external variable in initialized data */
int main(void)
{
    int var; /* automatic variable on the stack */
    pid_t pid;
    var = 88;
    
    printf("</span><span class="c1">before vfork\n"); /* we don't flush stdio */</span><span class="cp">
</span>    <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">vfork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">"vfork error"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* child */</span>
        <span class="n">glob</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* modify parent's variables */</span>
        <span class="n">var</span><span class="o">++</span><span class="p">;</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="cm">/* child terminates */</span>
    <span class="p">}</span>
    <span class="cm">/*
 * Parent continues here.
 */</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"pid = %d, glob = %d, var = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(),</span> <span class="n">glob</span><span class="p">,</span> <span class="n">var</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="err">}</span>
</code></pre></div></div> <ul> <li>실행 (13 페이지 fork 경우와의 차이점)</li> </ul> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./a.out
before vfork
pid <span class="o">=</span> 29039, glob <span class="o">=</span> 7, var <span class="o">=</span> 89
<span class="err">$</span>
</code></pre></div></div> <p>vfork는 자식 프로세스를 즉시 복제하지 않고 exec()을하기 전까지는 자식 프로세스가 부모 프로세스의 주소 공간에서 실행된다. 따라서 자식 프로세스가 변수(var, glob)을 증가 시켰는데 자식과 부모 프로세스가 glob, var 변수에 대해 별도로 copy를 가지고 있는 것이 아니라 부모 프로세스가 갖고 있는 것을 공유하는 것이기 때문에 부모가 증가시키지 않았더라도 자식이 증가시킨 것 때문에 부모가 출력하는 내용에 이것이 반영되어 나타나게 된 것이다.</p> <p>고로 이 점이 fork() 와의 차이점이라고 할 수 있다.</p> </section> <footer class="page__meta"> <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time class="dt-published" datetime="2022-05-11T00:00:00+09:00">May 11, 2022</time></p> </footer> <nav class="pagination"> <a href="/System-Programming-8-2%EC%9E%A5.-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-ID/" class="pagination--pager" title="[System Programming] 8-2장. 프로세스 ID ">Previous</a> <a href="/Computer-Architecture-Cache/" class="pagination--pager" title="[Computer Architecture] Cache ">Next</a> </nav> </div> </article> </div> </section> <footer> <p> <a href="https://github.com/github_username" title="Github"> <svg><use xlink:href="#icon-github"></use></svg> </a> <a href="https://www.facebook.com/facebook_username" title="Facebook"> <svg><use xlink:href="#icon-facebook"></use></svg> </a> <a href="https://twitter.com/twitter_username" title="Twitter"> <svg><use xlink:href="#icon-twitter"></use></svg> </a> <a href="https://medium.com/@medium_username" title="Medium"> <svg><use xlink:href="#icon-medium"></use></svg> </a> <a href="https://www.instagram.com/instagram_username" title="Instagram"> <svg><use xlink:href="#icon-instagram"></use></svg> </a> <a href="https://www.linkedin.com/in/linkedin_username" title="LinkedIn"> <svg><use xlink:href="#icon-linkedin"></use></svg> </a> </p> <ul> <li> <a href="http://localhost:4000/">Home</a> </li> <li> <a href="http://localhost:4000/about">About</a> </li> <li> <a href="http://localhost:4000/contact">Contact</a> </li> <li> <a href="http://localhost:4000/feed.xml">Feed</a> </li> </ul> <p> <span>Jekflix</span> was made with <svg class="love"><use xlink:href="#icon-heart"></use></svg> by <a href="https://rossener.com" target="_blank" class="creator">Thiago Rossener</a> </p> </footer> <script type="application/ld+json"> { "@context": "http://schema.org", "@type": "Organization", "name": "Jekflix", "description": "Jekflix is a template for Jekyll inspired by Netflix and made by Thiago Rossener.", "url": "http://localhost:4000/", "logo": { "@type": "ImageObject", "url": "http://localhost:4000/assets/img/icons/mediumtile.png", "width": "600", "height": "315" }, "sameAs": [ "https://github.com/github_username","https://www.facebook.com/facebook_username","https://twitter.com/twitter_username","https://medium.com/@medium_username","https://www.instagram.com/instagram_username","https://www.linkedin.com/in/linkedin_username" ] } </script> <!-- Include the script that allows Netlify CMS login --> <script src="https://identity.netlify.com/v1/netlify-identity-widget.js"></script> <!-- Include the website scripts --> <script src="/assets/js/scripts.min.js"></script> <!-- Include Google Analytics script --> <!-- Global site tag (gtag.js) - Google Analytics --> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-XXXXXXXX-X"></script> <script> var host = window.location.hostname; if (host != 'localhost') { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-XXXXXXXX-X'); } </script> <!-- Include extra scripts --> </body> </html>
