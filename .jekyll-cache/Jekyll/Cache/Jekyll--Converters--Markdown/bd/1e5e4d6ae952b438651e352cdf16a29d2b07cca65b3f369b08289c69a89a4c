I" <p>이번 시간에는 저번 시간(이진 탐색)에 이어서 점프 탐색(Jump search)에 대해서 알아보도록 하자.</p>

<h3 id="점프-탐색이란">점프 탐색이란?</h3>

<p>Jump Search는 순차적으로 탐색하는 선형 탐색과는 달리 블록 단위로 이동(점프)하면서 탐색하는 알고리즘이다.</p>

<p>이 역시도 이진 탐색과 마찬가지로 정렬된 배열에서만 사용할 수 있고, 한 칸씩 이동하는 것이 아니기 때문에 선형 탐색보다 적은 요소를 탐색할 수 있어 더 빠르게 탐색할 수 있다.</p>

<p><br /></p>

<p>이 알고리즘은 선형 탐색보다는 빠르지만 이진 탐색 보다는 느리다.</p>

<p><br /></p>

<h4 id="점프-탐색-방식">점프 탐색 방식</h4>

<ol>
  <li>배열을 블록(block) 단위로 나누어서 탐색을 진행하기 때문에 이 블록 사이즈 m의 크기를 구한다.
    <ul>
      <li>m의 최적 값은 다음과 같다.</li>
      <li>m = √n (n: 요소의 수)</li>
    </ul>
  </li>
  <li>한 블록에서 값을 탐색하고 없으면 다음 블록으로 이동한다.</li>
  <li>값을 가진 블록을 찾으면 해당 블록에서 선형 탐색을 사용하여 정확한 인덱스를 찾는다.</li>
</ol>

<p><br /></p>

<h5 id="블록의-최적-사이즈를-구하는-방법">블록의 최적 사이즈를 구하는 방법</h5>

<p>m의 최적 값을 구하는 공식은 다음과 같다.</p>

<ul>
  <li>블록 크기가 m이고 n개의 요소를 가지고 있다면 점프 탐색에서 총 n/m 만큼 블록을 탐색하게 된다.</li>
  <li>이후 선형 탐색은 (m - 1)번 일어나기 때문에 총 n/m + m - 1 만큼 수행하는 것이다.</li>
</ul>

<p>이 상황에서 m의 최적 해는 다음 공식으로 구할 수 있다.
\({\operatorname{d}\!\over\operatorname{d}\!m}({\operatorname{n}\over\operatorname{m}} + 1) = 0\)</p>

<blockquote>
  <p>-nm<sup>-2</sup> + 1 = 0</p>

  <p>nm<sup>-2</sup> = 1</p>

  <p>m =  √n</p>
</blockquote>

<p><br /></p>

<h3 id="search-방식">Search 방식</h3>

<p>다음 그림을 보면서 어떤 식으로 탐색이 진행되는 지 살펴 보자</p>

<p>아래 그림에서 크기가 11인 배열에서 key값인 22를 찾는다고 가정하자.</p>

<ol>
  <li>블록 사이즈 m을 구한다.
    <ul>
      <li>m = √11 = 3</li>
    </ul>
  </li>
</ol>

<p><img src="https://user-images.githubusercontent.com/79521972/155670545-eebb009a-17ac-4777-8700-ebbf94c98ee4.png" alt="image" /></p>

<p><br /></p>

<ol>
  <li>
    <p>key 값을 포함한 블록을 찾을 때까지 탐색을 진행한다.</p>

    <ul>
      <li>첫 번째 블록을 확인한다. 블록의 최댓값(11)이 key값(22)보다 작기 때문에 더 볼 것도 없이 다음 블록으로 이동한다.</li>
    </ul>

    <p><img src="https://user-images.githubusercontent.com/79521972/155671140-5581bc0f-d182-402d-b7c8-2e756476ab2d.png" alt="image" /></p>

    <ul>
      <li>두 번째 블록을 확인한다. 블록의 최댓값(18)이 key값(22)보다 작기 때문에 더 볼 것도 없이 다음 블록으로 이동한다.</li>
    </ul>

    <p><img src="https://user-images.githubusercontent.com/79521972/155671268-d9dda9fd-b211-495f-836c-b5a046914e6f.png" alt="image" /></p>

    <ul>
      <li>세 번째 블록을 확인한다. 블록이 key값(22)을 포함하고 있다.</li>
    </ul>

    <p><img src="https://user-images.githubusercontent.com/79521972/155671376-dfd03e37-eee3-475d-8829-2abb348c9807.png" alt="image" /></p>

    <ul>
      <li>찾았기 때문에 탐색 종료</li>
    </ul>
  </li>
  <li>
    <p>세 번째 블록 첫 번째 인덱스부터 선형 탐색으로 key값을 찾는다.</p>
  </li>
</ol>

<p><img src="https://user-images.githubusercontent.com/79521972/155671538-7594e6a6-3a21-4f33-a6d9-8e8f476d3642.png" alt="image" /></p>

<p><br /></p>

<h3 id="점프-탐색의-종료-조건">점프 탐색의 종료 조건</h3>

<p>점프 탐색에서 종료 조건은 두 가지가 있다. 다음 조건 중 하나라도 만족하면 탐색은 종료된다.</p>

<p><br /></p>

<ol>
  <li>데이터 검색을 성공한 경우
    <ul>
      <li>검색 key를 가진 블록을 발견한 경우이다.</li>
    </ul>
  </li>
</ol>

<p><img src="https://user-images.githubusercontent.com/79521972/155671538-7594e6a6-3a21-4f33-a6d9-8e8f476d3642.png" alt="image" /></p>

<p><br /></p>

<ol>
  <li>데이터 검색에 실패한 경우
    <ul>
      <li>더 이상 검색할 블록이 없는 경우이다.</li>
    </ul>
  </li>
</ol>

<p><img src="https://user-images.githubusercontent.com/79521972/155671854-d11019f9-40c3-46ac-a80b-9a998f479044.png" alt="image" /></p>

<p><br /></p>

<h2 id="점프-탐색-구현">점프 탐색 구현</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">jumpSearch</span><span class="o">(</span><span class="kt">int</span> <span class="n">arr</span><span class="o">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">sqrt</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
    
    <span class="kt">int</span> <span class="n">prev</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    
    <span class="k">while</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">min</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">m</span><span class="o">;</span>
        <span class="n">m</span> <span class="o">+=</span> <span class="n">m</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">prev</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="o">)</span> 
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="k">while</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">prev</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">prev</span><span class="o">++;</span>
        
        <span class="k">if</span> <span class="o">(</span><span class="n">prev</span> <span class="o">==</span> <span class="n">min</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">))</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">prev</span><span class="o">]</span> <span class="o">==</span> <span class="n">key</span><span class="o">)</span> 
        <span class="k">return</span> <span class="n">prev</span><span class="o">;</span>
    
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<ol>
  <li>m의 크기를 정한다.</li>
  <li>블록의 크기만큼 점프하면서 key값을 포함하는 블록을 찾는다.</li>
  <li>key 값을 포함한 블록을 찾았다면 블록의 첫 번째 인덱스부터 선형 탐색을 시작한다.</li>
  <li>검색 key를 찾은 경우 prev를 반환한다.</li>
</ol>

<p><br /></p>

<h4 id="시간-복잡도">시간 복잡도</h4>

<table>
  <thead>
    <tr>
      <th>연산</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Search</td>
      <td>O(1)</td>
      <td>O(√n)</td>
      <td>O(√n)</td>
    </tr>
  </tbody>
</table>

<p><br /></p>
:ET