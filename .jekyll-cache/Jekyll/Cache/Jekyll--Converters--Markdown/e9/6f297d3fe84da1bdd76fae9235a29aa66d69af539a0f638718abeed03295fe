I"Nª<p>1, 2 ì¥ì€ ì¤‘ìš”ë„ê°€ ë–¨ì–´ì§(ë§ì€ ì‹œê°„ì„ íˆ¬ìí•´ì„œ ì´í•´í•  í•„ìš” X)</p>

<p>ëŒ€ì¶© ë³´ë©´ì„œ ì´í•´í•˜ê³  ë‚˜ì¤‘ì— ê´€ë ¨ ë‚´ìš©ì´ ë‚˜ì™”ì„ ë•Œ ëŒì•„ì™€ì„œ ë³´ê¸°</p>

<h1 id="chapter-2-operating-system-structures">Chapter 2: Operating-System Structures</h1>

<ul>
  <li><strong>the services an OS provides to users, processes, and other systems</strong>
    <ul>
      <li>Operating System Services</li>
      <li>User Operating System Interface</li>
      <li>System Calls</li>
      <li>System Programs</li>
    </ul>
  </li>
  <li>the various ways of structuring an operating system
    <ul>
      <li>Operating System Design and Implementation</li>
      <li>Operating System Structure (ì–´ë–»ê²Œ êµ¬í˜„í•˜ëŠ” ì§€)</li>
    </ul>
  </li>
  <li>how operating systems are installed and customized and how they boot
    <ul>
      <li>Operating System Debugging</li>
      <li>Operating System Generation</li>
      <li>System Boot</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>ë¦¬ëˆ…ìŠ¤ëŠ” monolothic êµ¬ì¡°ë¥¼ ê°–ê³  ìˆìŒ
    <ul>
      <li>OSëŠ” ì„±ëŠ¥ì´ ìµœëŒ€ ê´€ê±´ vs. OSëŠ” ëª¨ë“ˆí™”ê°€ ê´€ê±´</li>
    </ul>
  </li>
  <li>OSëŠ” <strong>ì‹¤í–‰í™˜ê²½</strong>ì´ë‹¤.
    <ul>
      <li>cloud OS ì˜ ì‹œëŒ€</li>
      <li>JVMì€ ì‹¤í–‰í™˜ê²½ì´ì§€ë§Œ OSìœ„ì— ìˆë‹¤.</li>
      <li>ì¿ ë²„ë„¤í‹°ìŠ¤, docker -&gt; ì „ë§ì´ ìˆìŒ</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="operating-system-services">Operating System Services</h2>

<ul>
  <li>
    <p>Operating systems provide an <strong>environment</strong> for execution of programs and <strong>services</strong> to programs and users</p>
  </li>
  <li>
    <p>One set of operating-system <strong>services</strong> provides functions that are helpful to the user: (convinience ì¸¡ë©´)</p>

    <ul>
      <li><strong>User interface</strong> - Almost all operating systems have a user interface (<strong>UI</strong>).
        <ul>
          <li>Varies between <strong>Command-Line Interface (CLI)</strong> â€“ text command,</li>
          <li><strong>Graphics User Interface (GUI)</strong>,</li>
          <li><strong>Batch</strong> - file including several commands is executed â€“ <strong>shell script</strong>
            <ul>
              <li>ì—¬ëŸ¬ CLIê°€ ë‚˜ì—´ëœ íŒŒì¼</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><strong>Program execution</strong> - The system must be able to <strong>load a program</strong> into <strong>memory</strong> and to run that program, end execution, either â€˜normallyâ€™ or â€˜abnormallyâ€™ (<strong>indicating error</strong>)
        <ul>
          <li>c ì†ŒìŠ¤ íŒŒì¼ì—ì„œ object íŒŒì¼ë¡œ ë§Œë“œëŠ” ê²ƒì€ compilerì˜ ì—­í• </li>
          <li>ì—¬ëŸ¬ ê°œì˜ object íŒŒì¼ì„ í•˜ë‚˜ë¡œ ëª¨ì•„ì„œ ì‹¤í–‰íŒŒì¼ë¡œ ë§Œë“œëŠ” ì—­í• ì€ linker</li>
          <li>main memoryì— íƒ‘ì¬ ì‹œí‚¤ëŠ” ê²ƒì´ loader</li>
        </ul>
      </li>
      <li>
        <p><strong>I/O operations</strong> - A running program may require I/O, which may involve a file or an I/O device</p>
      </li>
      <li><strong>File-system manipulation</strong> - The file system is of particular interest. Programs need to read and write files and directories, create and delete them, search them, list file Information, permission management.
        <ul>
          <li>like íŒŒì¼ íƒìƒ‰ê¸°</li>
        </ul>
      </li>
      <li><strong>Communications</strong> â€“ Processes may exchange information, on the <strong>same computer</strong> or between computers over a <strong>network</strong>
        <ul>
          <li>Communications may be via <strong>shared memory</strong> or through <strong>message passing</strong> (packets moved by the OS)</li>
        </ul>
      </li>
      <li><strong>Error detection</strong> â€“ OS needs to be constantly aware of possible errors
        <ul>
          <li>May occur in the CPU and memory hardware, in I/O devices, in user program</li>
          <li>For each type of error, OS should take the <strong>appropriate action</strong> to ensure correct and consistent computing</li>
          <li>Debugging facilities can greatly enhance the userâ€™s and programmer â€™s abilities to efficiently use the system</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Another set of OS <strong>functions</strong> exists for ensuring the <strong>efficient</strong> operation of the system itself via resource sharing</p>
    <ul>
      <li><strong>Resource allocation</strong> - When multiple users or multiple jobs running concurrently, resources must be allocated to each of them
        <ul>
          <li>OSê°€ ì œê³µí•˜ëŠ” êµ‰ì¥íˆ ì¤‘ìš”í•œ ê¸°ëŠ¥</li>
          <li>Many types of resources - CPU cycles, main memory, file storage, I/O devicesâ€¦</li>
        </ul>
      </li>
      <li><strong>Accounting</strong> - To keep track of which users use how much and what kinds of computer resources (ì–¼ë§ˆë‚˜ ì‚¬ìš©í•˜ëŠ” ì§€ ëª¨ë‹ˆí„°ë§)
        <ul>
          <li>ê³¼ê¸ˆ í™•ì¸ ëª©ì  or í†µê³„ë¥¼ ìœ„í•œ ê¸°ëŠ¥</li>
        </ul>
      </li>
      <li><strong>Protection and security</strong> - The owners of information stored in a multiuser or networked computer system may want to <strong>control</strong> use of that information, concurrent processes should not interfere with each other
        <ul>
          <li><strong>Protection</strong> involves ensuring that all access to system resources is controlled</li>
          <li><strong>Security</strong> of the system from outsiders requires user <strong>authentication</strong>, extends to defending external I/O devices from <strong>invalid access attempts</strong></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="a-view-of-operating-system-services">A View of Operating System Services</h2>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20220907225450734.png" alt="image-20220907225450734" /></p>

<ul>
  <li>For convinience,
    <ul>
      <li>program execution, I/O operations, file systems, communication</li>
    </ul>
  </li>
  <li>For efficiency,
    <ul>
      <li>resource allocation, accounting, error detection, proteection and security</li>
    </ul>
  </li>
  <li>user interface
    <ul>
      <li>GUI, batch, command line(CLI)</li>
      <li>ì‚¬ìš©ìëŠ” ìœ„ ì„¸ ê°€ì§€ ì¤‘ í•˜ë‚˜ì˜ interfaceë¥¼ í†µí•´ì„œ OSê°€ ì œê³µí•˜ëŠ” ì„œë¹„ìŠ¤ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ ëœë‹¤.</li>
    </ul>
  </li>
  <li>ì‚¬ìš©ìê°€ í•˜ë“œì›¨ì–´ë¥¼ ì§ì ‘ ì ‘ê·¼í•  ì¼ì€ ì—†ìŒ -&gt; OSê°€ í•˜ë“œì›¨ì–´ë¥¼ ì¶”ìƒí™” í•˜ì˜€ê¸° ë•Œë¬¸ì—</li>
</ul>

<p><br /></p>

<h2 id="user-operating-system-interface---cli">User Operating System Interface - CLI</h2>

<ul>
  <li><strong>CLI</strong> or <strong>command interpreter</strong> allows direct command entry
    <ul>
      <li>Sometimes implemented in kernel, sometimes by systems program (Window/Unix)</li>
      <li>Sometimes multiple flavors implemented â€“ <strong>shells</strong>
        <ul>
          <li>Bourne shell, C shell, Bourne-Again shell, Korn shell</li>
        </ul>
      </li>
      <li>Primarily fetches a command from user and executes it</li>
      <li>Sometimes commands <strong>built-in</strong>, sometimes just <strong>names of programs</strong>
        <ul>
          <li>If the latter, adding new features doesnâ€™t require shell modification</li>
        </ul>
      </li>
      <li>lsì™€ ê°™ì€ ëª…ë ¹ ë˜í•œ í”„ë¡œê·¸ë¨ì„.(ì‹œìŠ¤í…œ í”„ë¡œê·¸ë¨)</li>
      <li>shellì€ ëª…ë ¹ì„ ê¸°ë‹¤ë ¸ë‹¤ê°€ ëª…ë ¹ì„ ì‹¤í–‰í•˜ê³  ë‹¤ì‹œ ë˜ ê¸°ë‹¤ë¦¬ëŠ” ê²ƒì˜ ë°˜ë³µí•˜ëŠ” í”„ë¡œê·¸ë¨</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="bourne-shell-command-interpreter">Bourne Shell Command Interpreter</h2>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20220907225743599.png" alt="image-20220907225743599" /></p>

<p><br /></p>

<h2 id="user-operating-system-interface---gui">User Operating System Interface - GUI</h2>

<ul>
  <li>User-friendly <strong>desktop</strong> metaphor interface
    <ul>
      <li>Usually mouse, keyboard, and monitor</li>
      <li><strong>Icons</strong> represent files, programs, actions, etc</li>
      <li>Various mouse buttons over objects in the interface cause various actions (provide information, options, execute function, open directory (known as a <strong>folder</strong>)</li>
      <li>Invented at Xerox PARC (Palo Alto Research Center)</li>
    </ul>
  </li>
  <li>Many systems now include both CLI and GUI interfaces
    <ul>
      <li>Microsoft Windows is GUI with CLI â€œcommandâ€ shell</li>
      <li>Apple Mac OS X is â€œAquaâ€ GUI interface with UNIX kernel underneath and shells available</li>
      <li>Unix and Linux have CLI with optional GUI(optional) interfaces
        <ul>
          <li>Commercial- CDE(Common Desktop Environment), X-window</li>
          <li>Open source - KDE, GNOME</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="touchscreen-interfaces">Touchscreen Interfaces</h2>

<ul>
  <li>
    <p>ì–´ë–»ê²Œ ë³´ë©´, GUIì˜ í•œ ì¢…ë¥˜</p>
  </li>
  <li>Touchscreen devices require new interfaces
    <ul>
      <li><strong>Mouse not possible</strong> or not desired</li>
      <li>Actions and selection based on gestures</li>
      <li>Virtual keyboard for text entry</li>
    </ul>
  </li>
  <li>Voice commands.(ìµœê·¼)</li>
</ul>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20220907230322554.png" alt="image-20220907230322554" /></p>

<p><br /></p>

<h2 id="the-mac-os-x-gui">The Mac OS X GUI</h2>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20220907230350004.png" alt="image-20220907230350004" /></p>

<p><br /></p>

<h2 id="system-calls">System Calls</h2>

<ul>
  <li><strong>Programming interface</strong> to the services provided by the OS</li>
  <li>Typically written in a high-level language (C or C++)</li>
  <li>Mostly accessed by programs via a high-level <strong>Application Programming Interface (API)</strong> rather than direct <strong>system call</strong> use
    <ul>
      <li>API -&gt; system call ì „í™˜</li>
    </ul>
  </li>
  <li>Three most common APIs are <strong>Win32 API</strong> for Windows, <strong>POSIX API</strong> for POSIX-based systems (including virtually all versions of UNIX, Linux, and Mac OS X), and <strong>Java API</strong> for the Java virtual machine (JVM)
    <ul>
      <li>3ê°œì˜ APIê°€ ì¡´ì¬í•œë‹¤.</li>
      <li>POSIX APIë¥¼ ì‚¬ìš©í•˜ëŠ” ì‹œìŠ¤í…œì€ ëª¨ë‘ ê°™ì€ API í˜•íƒœë¥¼ ì‚¬ìš©í•˜ì§€ë§Œ UNIXì™€ LINUXëŠ” ê°ê° ë‹¤ë¥¸ OSì´ê¸° ë•Œë¬¸ì— ë‹¤ë¥¸ ì‹œìŠ¤í…œ ì½œì˜ í˜•íƒœë¥¼ ì‚¬ìš©í•˜ê²Œ ëœë‹¤.</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>Note that the system-call names used throughout this text are generic</p>
</blockquote>

<ul>
  <li>ì‹œìŠ¤í…œì½œ ì´ë¦„ì´ generic ìŠ¤íƒ€ì¼ë¡œ ì œê³µë¨</li>
</ul>

<p><br /></p>

<h2 id="example-of-system-calls">Example of System Calls</h2>

<ul>
  <li>System call sequence to copy the contents of one file to another file</li>
</ul>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20220907231055458.png" alt="image-20220907231055458" /></p>

<p>system callì€ ì»¤ë„ ì•ˆì—ì„œ êµ¬í˜„ëœ ì»¤ë„ í•¨ìˆ˜ì´ë‹¤.</p>

<p><br /></p>

<h2 id="example-of-standard-api">Example of Standard API</h2>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20220907231116093.png" alt="image-20220907231116093" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">man read</code> ì™€ ê°™ì´ ì…ë ¥í•˜ë©´ readì— ëŒ€í•œ ì‚¬ìš©ë²•ì´ ì¢Œë¥´ë¥µ ë‚˜ì˜¤ê²Œ(display) ëœë‹¤.
    <ul>
      <li>man page: POISX ê³„ì—´ì˜ API ì‚¬ìš©ë²•ì„ ì•Œë ¤ì£¼ëŠ” ê¸°ëŠ¥</li>
    </ul>
  </li>
  <li>ë°˜ë“œì‹œ unistd.h ë¥¼ include í•´ì•¼ í•¨.
    <ul>
      <li>ssize_t ë‚˜ size_tì˜ íƒ€ì…ì´ í•´ë‹¹ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— í¬í•¨ë˜ì–´ ìˆê¸° ë•Œë¬¸ì—</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="system-call-implementation">System Call Implementation</h2>

<ul>
  <li>Typically, a <strong>number</strong> associated with each system call (ë§ˆì¹˜ interrupt vectorê°€ ìˆ«ìë¥¼ ê°€ì§„ ê²ƒì²˜ëŸ¼)
    <ul>
      <li>ê³¼ì œ 1ë²ˆì—ì„œë„ ê·¸ë˜ì„œ ì‹œìŠ¤í…œì½œì„ ë§Œë“¤ ë•Œ ìˆ«ìë¥¼ ë“±ë¡í–ˆì—ˆìŒ.</li>
      <li><strong>System-call interface</strong> maintains a <strong>table</strong> indexed according to these numbers</li>
    </ul>
  </li>
  <li>The system call interface invokes the intended system call in OS kernel and returns status of the system call and any return values</li>
  <li>The caller need know nothing about how the system call is implemented
    <ul>
      <li>Just needs to obey API and understand what OS will do as a result call</li>
      <li>Most details of OS interface hidden from programmer by API
        <ul>
          <li>Managed by run-time support library (set of functions built into libraries included with compiler)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="api---system-call---os-relationship">API - System Call - OS Relationship</h2>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20220907231213382.png" alt="image-20220907231213382" /></p>

<ul>
  <li>open() ì‹œìŠ¤í…œ ì½œì˜ numberê°€ ië¼ í•  ë•Œ, í…Œì´ë¸”ì˜ ië²ˆì§¸ entryë¥¼ ì°¾ì•„ê°€ê²Œ ë˜ë©´ open() ì‹œìŠ¤í…œ ì½œ í•¨ìˆ˜ì˜ ì£¼ì†Œê°€ ì í˜€ ìˆì–´ ì´ë¥¼ invoke í•  ìˆ˜ ìˆê²Œ ëœë‹¤.</li>
  <li>ì‚¬ìš©ìê°€ ì–´ë–¤ system callì„ í˜¸ì¶œí–ˆëƒì— ë”°ë¼ì„œ system call tableì„ ë²ˆí˜¸ë¥¼ indexingí•´ì„œ í•´ë‹¹ ì‹œìŠ¤í…œ ì½œ í•¨ìˆ˜ë¥¼ ì‹¤í–‰ í›„ ë¦¬í„´í•˜ê²Œ ëœë‹¤.</li>
</ul>

<p><br /></p>

<h2 id="standard-c-library-example">Standard C Library Example</h2>

<ul>
  <li>C program invoking printf() library call, which calls write() system call</li>
</ul>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20220907231241893.png" alt="image-20220907231241893" /></p>

<ul>
  <li>printf() -&gt; library call(API) -&gt; write()
    <ul>
      <li>APIê°€ writeì„ ëŒ€ì‹  í˜¸ì¶œí•´ ì¤Œ.</li>
      <li>ì‹œìŠ¤í…œì½œì—ì„œ APIë¡œ ë¦¬í„´, APIì—ì„œ ì‚¬ìš©ì ìª½ìœ¼ë¡œ ë¦¬í„´</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="system-call-parameter-passing">System Call Parameter Passing</h2>

<ul>
  <li>Often, more information is required than simply identity of desired system call
    <ul>
      <li>Exact type and amount of information <strong>vary according to OS and call.</strong></li>
    </ul>
  </li>
  <li>Three general methods used to pass parameters to the OS
    <ul>
      <li>Simplest: pass the parameters in <strong>registers</strong>
        <ul>
          <li>In some cases, may be more parameters than registers</li>
        </ul>
      </li>
      <li>Parameters stored in a block, or table, in memory, and <strong>address of block</strong> passed as a parameter in a register
        <ul>
          <li>ë§ì€ parameterë¥¼ memoryì— block í˜•íƒœë¡œ ì €ì¥í•˜ê³  blockì˜ ì£¼ì†Œë¥¼ registerì— ì €ì¥</li>
          <li>This approach taken by Linux and Solaris</li>
        </ul>
      </li>
      <li>Parameters placed, or <strong>pushed</strong>, onto the <strong>stack</strong> by the program and <strong>popped</strong> off the stack by the operating system</li>
      <li><strong>Block and stack methods do not limit</strong> the number or length of parameters being passed</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="parameter-passing-via-table">Parameter Passing via Table</h2>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20220907231734443.png" alt="image-20220907231734443" /></p>

<ul>
  <li>Xë¼ëŠ” ì—¬ëŸ¬ íŒŒë¼ë¯¸í„°ê°€ ìˆëŠ” ë©”ëª¨ë¦¬ ê³µê°„ì´ ìˆëŠ”ë°</li>
  <li>ì´ê²ƒì˜ ì£¼ì†Œë¥¼ registerì— loadí•˜ê³  system call 13ì„ í˜¸ì¶œí•˜ë©´ OS system call tableì—ì„œ 13ë²ˆì„ ë³´ë©´ í•´ë‹¹ ì‹œìŠ¤í…œ ì½œì„ í˜¸ì¶œí•  ìˆ˜ ìˆëŠ” ì£¼ì†Œê°€ ìˆëŠ”ë°</li>
  <li>ì´ ì‹œìŠ¤í…œì½œì—ì„œ registerë¥¼ ì°¸ì¡°í•´ì„œ íŒŒë¼ë¯¸í„° Xë¥¼ ì „ë‹¬ë°›ì„ ìˆ˜ ìˆê²Œ ë˜ëŠ” ê²ƒì´ë‹¤.</li>
</ul>

<p><br /></p>

<h2 id="types-of-system-calls">Types of System Calls</h2>

<ul>
  <li><strong>Process control</strong>
    <ul>
      <li>create process, terminate process</li>
      <li>Normal termination, abort</li>
      <li>load, execute</li>
      <li>get process attributes, set process attributes</li>
      <li>wait for time : wait_time()</li>
      <li>wait event, signal event : wait_event(), signal_event()</li>
      <li>allocate and free memory</li>
      <li>Dump memory if error</li>
      <li><strong>Debugger</strong> for determining <strong>bugs</strong>, <strong>single step</strong> execution</li>
      <li><strong>Locks</strong> for managing access to shared data between processes
        <ul>
          <li>acquire_lock(), release_lock()</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="examples-of-windows-and-unix-system-calls">Examples of Windows and Unix System Calls</h2>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20220907231830253.png" alt="image-20220907231830253" /></p>

<p><br /></p>

<h2 id="standard-c-library-example-1">Standard C Library Example</h2>

<ul>
  <li>C program invoking printf() library call, which calls write() system call</li>
</ul>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20220907231850599.png" alt="image-20220907231850599" /></p>

<p><br /></p>

<p>system callì„ ì‹¤í–‰ì‹œí‚¤ëŠ” í™˜ê²½</p>

<h2 id="example-ms-dos">Example: MS-DOS</h2>

<ul>
  <li>No GUI</li>
  <li><strong>Single-tasking</strong></li>
  <li><strong>Shell</strong> invoked when system booted</li>
  <li>Simple method to run program
    <ul>
      <li>No process created</li>
    </ul>
  </li>
  <li>Single memory space</li>
  <li>Loads program into memory, overwriting all but the kernel</li>
  <li>Program exit -&gt; shell reloaded
    <ul>
      <li>overwriting í•˜ëŠ” ê²½ìš° reload</li>
    </ul>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20220907231923235.png" alt="image-20220907231923235" /></p>

<p><br /></p>

<h2 id="example-freebsd">Example: FreeBSD</h2>

<ul>
  <li>Unix variant</li>
  <li><strong>Multitasking</strong>
    <ul>
      <li>ì—¬ëŸ¬ í”„ë¡œê·¸ë¨ì´ ë™ì‹œì— ì‹¤í–‰</li>
    </ul>
  </li>
  <li>User login -&gt; invoke userâ€™s choice of shell</li>
  <li>Shell executes <strong>fork()</strong> system call to create process
    <ul>
      <li>Executes <strong>exec()</strong> to load program into process</li>
      <li>Shell <strong>waits for process</strong> to terminate or continues with user commands</li>
    </ul>
  </li>
  <li>Process exits with:
    <ul>
      <li>code = 0 â€“ no error</li>
      <li>code &gt; 0 â€“ error code</li>
    </ul>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20220907232028166.png" alt="image-20220907232028166" /></p>

<p><br /></p>

<h2 id="types-of-system-calls-1">Types of System Calls</h2>

<ul>
  <li><strong>File management</strong>
    <ul>
      <li>create file, delete file</li>
      <li>open, close file</li>
      <li>read, write, reposition</li>
      <li>get and set file attributes</li>
      <li>Same for directories</li>
    </ul>
  </li>
  <li><strong>Device management</strong>
    <ul>
      <li>physical device (disk drives), logical device (file)</li>
      <li>request device, release device (similar to open, close files)</li>
      <li>read, write, reposition</li>
      <li>get device attributes, set device attributes</li>
      <li>logically attach or detach devices</li>
    </ul>
  </li>
  <li><strong>Information maintenance</strong>
    <ul>
      <li>get time or date, set time or date</li>
      <li>get system data, set system data</li>
      <li>get and set process, file, or device attributes</li>
    </ul>
  </li>
  <li><strong>Communications</strong>
    <ul>
      <li>create, delete <strong>communication connection</strong></li>
      <li>send, receive messages if <strong>message passing model</strong> to <strong>host name</strong> or <strong>process name</strong>
        <ul>
          <li>From <strong>client</strong> to <strong>server</strong></li>
          <li>ë°›ì„ host nameê³¼ ë©”ì„¸ì§€ë¥¼ ìˆ˜ì‹ í•  process nameì´ í•„ìš”ë¡œ ë¨</li>
        </ul>
      </li>
      <li><strong>Shared-memory model</strong> create and gain access to memory regions
        <ul>
          <li>allows memory transfer speed, but may have <strong>synch problem</strong> (ì½ê³  ì“°ëŠ” ì‹œê°„ì˜ ì°¨ì´ ë•Œë¬¸ì— ë°œìƒí•˜ëŠ” problem)</li>
          <li>shared_memory create, shared_memory attach</li>
        </ul>
      </li>
      <li>transfer status information</li>
      <li>attach and detach remote devices</li>
    </ul>
  </li>
  <li>Protection
    <ul>
      <li>Control access to <strong>resources</strong></li>
      <li>Get and set <strong>permissions</strong></li>
      <li><strong>Allow</strong> and <strong>deny</strong> user access</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="system-programs">System Programs</h2>

<ul>
  <li>kernel ìœ„ì—ì„œ ì‹¤í–‰ë˜ëŠ” í”„ë¡œê·¸ë¨(ì‚¬ìš©ì ëª¨ë“œì—ì„œ ëŒê³  ìˆìŒ)
    <ul>
      <li>utility programì´ë¼ê³  í•˜ê¸°ë„ í•¨.</li>
    </ul>
  </li>
  <li>System programs provide a convenient environment for program development and execution. They can be divided into:
    <ul>
      <li>File manipulation</li>
      <li>Status information sometimes stored in a File modification</li>
      <li>Programming language support</li>
      <li>Program loading and execution</li>
      <li>Communications</li>
      <li>Background services</li>
      <li>Application programs</li>
    </ul>
  </li>
  <li>
    <p>Most usersâ€™ <strong>view</strong> of the operation system is defined by system programs, not the actual system calls</p>
  </li>
  <li>Provide a convenient environment for program development and execution
    <ul>
      <li>Some of them are simply user interfaces to system calls; others are considerably more complex</li>
    </ul>
  </li>
  <li><strong>File management</strong> - Create, delete, copy, rename, print, dump, list, and generally manipulate files and directories</li>
  <li><strong>Status information</strong>
    <ul>
      <li>Some ask the system for info - date, time, amount of available memory, disk space, number of users</li>
      <li>Others provide detailed performance, logging, and debugging information</li>
      <li>Typically, these programs format and print the output to the terminal or other output devices</li>
      <li>Some systems implement a <strong>registry</strong> - used to store and retrieve configuration information</li>
    </ul>
  </li>
  <li><strong>File modification</strong>
    <ul>
      <li>Text editors to create and modify files</li>
      <li>Special commands to search contents of files or perform transformations of the text</li>
    </ul>
  </li>
  <li><strong>Programming-language support</strong> - Compilers, assemblers, debuggers and interpreters sometimes provided</li>
  <li><strong>Program loading and execution</strong>- <code class="language-plaintext highlighter-rouge">Absolute loaders</code>, <code class="language-plaintext highlighter-rouge">relocatable loaders</code>, linkage editors, and overlay-loaders, debugging systems for higher-level and machine language</li>
  <li><strong>Communications</strong> - Provide the mechanism for creating virtual connections among processes, users, and computer systems
    <ul>
      <li>Allow users to send messages to one anotherâ€™s screens, browse web pages, send electronic-mail messages, log in remotely, transfer files from one machine to another</li>
    </ul>
  </li>
  <li><strong>Background Services</strong>
    <ul>
      <li>Launch system program-process at <strong>boot</strong> time
        <ul>
          <li>Some for system startup, then terminate</li>
          <li>Some from system boot to shutdown</li>
        </ul>
      </li>
      <li>Provide facilities like disk checking, process scheduling, error logging, printing</li>
      <li>Run in user context <strong>not kernel context</strong></li>
      <li>Known as <strong>services</strong>, <strong>subsystems</strong>, <strong>daemons</strong></li>
      <li>backgroundì˜ ì˜ë¯¸: ëª¨ë‹ˆí„°ë¥¼ í†µí•´ì„œ ì‚¬ìš©ìì™€ interactionì´ ì¼ì–´ë‚˜ì§€ ì•ŠëŠ” í”„ë¡œê·¸ë¨</li>
    </ul>
  </li>
  <li><strong>Application programs</strong>
    <ul>
      <li>Donâ€™t pertain to system</li>
      <li>ì‚¬ìš©ìê°€ ì§  í”„ë¡œê·¸ë¨ì´ ì•„ë‹˜
        <ul>
          <li>ì¼ë°˜ ì‚¬ìš©ìì—ê²Œ ì œê³µí•˜ëŠ” í”„ë¡œê·¸ë¨</li>
        </ul>
      </li>
      <li>Word processor, web browser . ..</li>
      <li>Run by users</li>
      <li><strong>Not typically considered part of OS</strong></li>
      <li>Launched by command line, mouse click, finger poke</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="linker-loader">Linker &amp;Â Loader</h2>

<ul>
  <li>Will be explained later(memory management part)</li>
</ul>

<p><br /></p>

<h2 id="operating-system-design-and-implementation">Operating System Design and Implementation</h2>

<ul>
  <li>Design and Implementation of OS is <strong>not easy</strong>, but some approaches have been proven successful</li>
  <li>Internal structure of different Operating Systems can vary widely</li>
  <li>Start the design by defining <strong>goals</strong> and <strong>specifications</strong>
    <ul>
      <li><strong>Affected</strong> by <strong>choice</strong> of hardware, type of system
        <ul>
          <li>Batch, time-sharing, multi-user, distributed, real-time â€¦</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>User</strong> goals and <strong>System</strong> goals
    <ul>
      <li><strong>User goals</strong> â€“ operating system should be convenient to use, <strong>easy</strong> to learn, reliable, safe, and fast
        <ul>
          <li>May not be useful in the system design</li>
        </ul>
      </li>
      <li><strong>System goals</strong> â€“ operating system should be easy to design, implement, and maintain, as well as flexible, reliable, error-free, and efficient</li>
      <li>No unique solution</li>
    </ul>
  </li>
  <li>Important principle to separate the following for flexibility
    <ul>
      <li><strong>Policy</strong>: <u>What</u> will be done?</li>
      <li><strong>Mechanism</strong>: <u>How</u> to do it?</li>
    </ul>
  </li>
  <li>Mechanisms determine how to do something, policies decide what will be done</li>
  <li>The <strong>separation</strong> of policy from mechanism is a very important principle, it allows maximum flexibility if policy decisions are to be changed later (example â€“ timer)
    <ul>
      <li>ë‘˜ì´ ë¬¶ì—¬ ìˆìœ¼ë©´ ë‘˜ ì¤‘ í•˜ë‚˜ë¥¼ ë°”ê¿€ ë•Œ ìƒê¸°ëŠ” dependencyê°€ ìˆê¸° ë•Œë¬¸ì— ë‘˜ ê°„ì˜ dependencyë¥¼ ì¤„ì¼ ìˆ˜ ìˆìŒ</li>
    </ul>
  </li>
  <li>Specifying and designing an OS is highly creative task(ì°½ì˜ì  ì—…ë¬´) of <strong>software engineering</strong></li>
</ul>

<p><br /></p>

<h2 id="implementation">Implementation</h2>

<ul>
  <li>Much variation
    <ul>
      <li>Early OSes in assembly language</li>
      <li>Then system programming languages like Algol, PL/1</li>
      <li>Now C, C++</li>
    </ul>
  </li>
  <li>Actually usually a mix of languages
    <ul>
      <li>Lowest levels in assembly (ì‹¤í–‰ì†ë„ê°€ ë¹ ë¦„)</li>
      <li>Main body in C</li>
      <li>Systems programs in C, C++, scripting languages like PERL, Python, shell scripts</li>
    </ul>
  </li>
  <li>More high-level language easier to <strong>port</strong> to other hardware (port-í•œ ì‹œìŠ¤í…œì—ì„œ ì‘ë™ë˜ëŠ” ê±¸ ë‹¤ë¥¸ ì‹œìŠ¤í…œì—ì„œë„ ì‘ë™ë˜ë„ë¡ í•´ ì£¼ëŠ”)
    <ul>
      <li>Can be written faster, easy to understand, debug (compilerì˜ ë°œì „ìœ¼ë¡œ assemblyë§Œí¼ ë¹¨ë¼ì§)</li>
      <li>But slower. Require more memory (ê¸°ìˆ ì˜ ë°œì „ìœ¼ë¡œ gapì´ ê·¸ë ‡ê²Œ í¬ì§„ ì•ŠìŒ.)</li>
      <li>Linux is written in C, so it can be available on various CPUs</li>
    </ul>
  </li>
  <li>MS-DOS written in Intel 8088 assembly language
    <ul>
      <li>It runs natively only on Intel X86 family.</li>
      <li><strong>Emulators</strong> of X86 instruction set allow OS to run <strong>on other CPUs</strong></li>
    </ul>
  </li>
  <li><strong>Emulation</strong> can allow an OS to run on <strong>non-native hardware</strong> by <strong>duplicating</strong> functionalities between two systems</li>
</ul>

<p><br /></p>

<h2 id="operating-system-structure">Operating System Structure</h2>

<ul>
  <li>General-purpose OS is very large program
    <ul>
      <li>Monolithic structure vs. Modular structure</li>
    </ul>
  </li>
  <li>Various ways to structure ones (ìœ„ë¡œ ê°ˆ ìˆ˜ë¡ monolithic, ì•„ë˜ë¡œ ê°ˆ ìˆ˜ë¡ modular)
    <ul>
      <li>Simple structure â€“ MS-DOS</li>
      <li>More complex â€“ UNIX</li>
      <li>Layered â€“ an abstraction</li>
      <li>Microkernel -Mach</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="simple-structure--ms-dos">Simple Structure â€“ MS-DOS</h2>

<ul>
  <li>MS-DOS â€“ written to provide the most functionality in the least space
    <ul>
      <li><strong>Not divided</strong> into modules (monolithic)</li>
      <li>application programì´ ì§ì ‘ device driversì— interface -&gt; êµ‰ì¥í•œ ë¬¸ì œê°€ ë°œìƒí•  í™•ë¥ ì´ ë†’ë‹¤.</li>
      <li>Although MS-DOS has some structure, its interfaces and levels of functionality are not well separated</li>
      <li>8088 provides no dual mode, hardware protection
        <ul>
          <li>ë˜ë„ë¡ ì ì€ ìì›ìœ¼ë¡œ OS êµ¬í˜„í•˜ë ¤ê³  ì‹œë„</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20220907233015240.png" alt="image-20220907233015240" /></p>

<p><br /></p>

<h2 id="non-simple-structure--unix">Non Simple Structure â€“ UNIX</h2>

<ul>
  <li>original UNIX â€“ <strong>limited</strong> by hardware functionality, the original UNIX operating system had limited structuring.</li>
  <li>The UNIX OS consists of two separable parts
    <ul>
      <li>Systems programs</li>
      <li>The kernel
        <ul>
          <li>Consists of everything <strong>below</strong> the <strong>system-call interface</strong> and <strong>above the physical hardware</strong></li>
          <li>Provides the file system, CPU scheduling, memory management, and other operating-system functions; a large number of functions for one level</li>
          <li>Layered some extent, but basically <strong>monolithic</strong>
            <ul>
              <li>hardware ê¸°ëŠ¥ì´ ë§¤ìš° ì œí•œì ì´ê¸° ë•Œë¬¸ì—</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="traditional-unix-system-structure">Traditional UNIX System Structure</h3>

<p>Beyond simple but not fully layered</p>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20220907233156659.png" alt="image-20220907233156659" /></p>

<p>OS kernel ë¶€ë¶„ì´ ê·¸ë ‡ê²Œ ë§‰ well-structured ë˜ì§„ ì•ŠìŒ, ë‹¨ì§€ ì‚¬ìš©ìì™€ kernelì‚¬ì´ê°€ ì˜ êµ¬ë¶„ ë˜ì–´ ìˆìŒ</p>

<p><br /></p>

<h2 id="layered-approach">Layered Approach</h2>

<ul>
  <li><strong>Modular structure</strong></li>
  <li>Information hiding
    <ul>
      <li>higher layerì˜ ì„¤ê³„, ì‚¬ìš©ìê°€ lower layerì˜ êµ¬ì¡°ë¥¼ ì•Œ í•„ìš” ì—†ìŒ</li>
    </ul>
  </li>
  <li>The operating system is <strong>divided</strong> into a number of layers (levels), each built on top of lower layers. The bottom layer (layer 0), is the hardware; the highest (layer N) is the user interface.</li>
  <li>With modularity, layers are selected such that each uses functions (operations) and <strong>services of only lower-level layers</strong></li>
  <li>Simple construction, debugging</li>
  <li>Overhead in each layer(ë‹¨ì )
    <ul>
      <li>monolithic - interactionì´ í•˜ë‚˜ì˜ ê³„ì¸µì—ì„œë§Œ ì´ë£¨ì–´ì§€ì§€ë§Œ modularëŠ” layerì— ê±¸ì³ì„œ ì´ë£¨ì–´ ì§€ê¸° ë•Œë¬¸ì— response ì‹œê°„ì´ ëŠë ¤ì§„ë‹¤.</li>
    </ul>
  </li>
  <li>ê·¸ë ‡ì§€ë§Œ! ì„±ëŠ¥ì€ ê·¸ë ‡ë‹¤ê³  í•˜ì§€ë§Œ ì—”ì§€ë‹ˆì–´ë§ ì‹œê°„ì´ë‚˜ ìœ ì§€ë³´ìˆ˜ ê¸°ê°„ ë“±ì„ ë”°ì ¸ ë³´ì•˜ì„ ë•Œ modularê°€ ì••ë„ì ìœ¼ë¡œ ì¢‹ë‹¤.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20220907233427206.png" alt="image-20220907233427206" /></p>

<p><br /></p>

<h2 id="microkernel-system-structure">Microkernel System Structure</h2>

<ul>
  <li><strong>seperation</strong> between policy and mechanism
    <ul>
      <li>Policy free mechanisms of building blocks (kernel mode ëª¨ë“ˆ)
        <ul>
          <li>ë‹¤ë¥¸ ê²ƒì´ ë³€ê²½ë˜ëŠ” ê²ƒê³¼ ìƒê´€ì´ ì—†ë„ë¡!</li>
        </ul>
      </li>
      <li>Modularized Kernel (ì»¤ë‹¤ë€ OSì˜ í„°ì „)</li>
    </ul>
  </li>
  <li>Moves as much from the kernel into user space</li>
  <li><strong>Mach (CMU)</strong> example of <strong>microkernel</strong>
    <ul>
      <li>Mac OS X kernel (<strong>Darwin</strong>) partly based on Mach</li>
    </ul>
  </li>
  <li>Communication takes place between user modules using <strong>message passing</strong></li>
  <li>Benefits:
    <ul>
      <li>Easier to extend a microkernel (ì–¹ê¸°ë§Œ í•˜ë©´ ë¨)</li>
      <li>Easier to <strong>port</strong> the operating system to new architectures</li>
      <li>More reliable (less code is running in kernel mode)</li>
      <li>More secure</li>
    </ul>
  </li>
  <li>Detriments:
    <ul>
      <li><strong>Performance overhead</strong> of user space to kernel space communication
        <ul>
          <li>due to message passingâ€™s communication</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>â€‹</p>

<p><br /></p>

<h2 id="microkernel-system-structure-1">Microkernel System Structure</h2>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20220907233551710.png" alt="image-20220907233551710" /></p>

<ul>
  <li>ì¼ë¶€ kernelì˜ ë‚´ìš©ì´ ë°–ì— ë‚˜ì˜¬ ìˆ˜ ìˆìŒ</li>
  <li>microkernel: ìµœì†Œí•œì˜ ê¸°ëŠ¥ë§Œì„ ê°€ì§„ kernel
    <ul>
      <li>ë‚˜ë¨¸ì§€ëŠ” user mode</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="modules">Modules</h2>

<ul>
  <li>loadable kernel modules approach
    <ul>
      <li>ê¸°ì¡´ì˜ modular approachì—ì„œ ì§„ë³´í•œ êµ¬ì¡°</li>
      <li>performanceì— ì§€ì¥ì´ ì—†ìœ¼ë©´ì„œ ìœ ì§€ë³´ìˆ˜ë¥¼ ë¬¸ì œì—†ì´ í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ì‹œë„</li>
    </ul>
  </li>
  <li>Many modern operating systems implement <strong>loadable kernel modules</strong>
    <ul>
      <li><strong>Kernel</strong> provides <strong>core services</strong> while <strong>other services</strong> are implemented (<mark>via modules</mark>) dynamically (<strong>dynamic linking</strong> rather than recompiling)
        <ul>
          <li>dynamic linkingì˜ ëŒ€ìƒì´ ë˜ëŠ” ê²ƒì´ loadable kernel modules</li>
          <li>core serviceê°€ ì•„ë‹ˆê¸° ë•Œë¬¸ì— ì²˜ìŒë¶€í„° linking ë˜ì–´ íƒ‘ì¬ ë˜ì–´ ìˆì§„ ì•Šë‹¤.</li>
        </ul>
      </li>
      <li>Uses object-oriented approach</li>
      <li>Each core component is separate</li>
      <li>Each talks to the others over <strong>known interfaces</strong></li>
      <li>Each is loadable as needed within the kernel</li>
    </ul>
  </li>
  <li>Overall, <strong>similar to layers but with more flexible</strong>
    <ul>
      <li>Linux, Solaris, etc</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="solaris-modular-approach">Solaris Modular Approach</h2>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20220907233817812.png" alt="image-20220907233817812" /></p>

<p><br /></p>

<h2 id="hybrid-systems">Hybrid Systems</h2>

<ul>
  <li>Most modern operating systems are actually not one pure model
    <ul>
      <li><strong>Hybrid</strong> combines multiple approaches to address <code class="language-plaintext highlighter-rouge">performance, security, usability </code>needs</li>
      <li>Linux and Solaris kernels in kernel address space, <strong>so monolithic</strong>(<mark>because of performance</mark>), plus modular for <strong>dynamic loading</strong> of functionality(coreê°€ ì•„ë‹Œ ê²½ìš°ì— ëŒ€í•˜ì—¬)</li>
      <li><strong>Windows</strong> mostly monolithic, plus microkernel for different subsystem personalities</li>
    </ul>
  </li>
  <li>Apple Mac OS X hybrid, <strong>layered</strong>, Aqua UI plus Cocoa programming environment
    <ul>
      <li>Below is kernel consisting of Mach microkernel and BSD Unix parts, plus I/O kit and dynamically loadable modules (called <strong>kernel extensions</strong>)</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>í•µì‹¬ ê¸°ëŠ¥ì€ ì„±ëŠ¥ì„ ìœ„í•´ monolithicìœ¼ë¡œ, ë‚˜ë¨¸ì§€ ê¸°ëŠ¥ì€ dependency, ìœ ì§€ë³´ìˆ˜ë¥¼ ìœ„í•´ dynamic loading(ì¦‰, modular ë°©ì‹)ìœ¼ë¡œ êµ¬í˜„í•œ ê²ƒì´ë‹¤.</p>
</blockquote>

<p><br /></p>

<h2 id="mac-os-x-structure">Mac OS X Structure</h2>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20220907233918782.png" alt="image-20220907233918782" /></p>

<hr />

<p><mark>ì´ ì•„ë˜ëŠ” ìƒëµ</mark></p>

<hr />

<p><br /></p>

<h2 id="ios">iOS</h2>

<ul>
  <li>Apple mobile OS for iPhone, iPad
    <ul>
      <li>Structured on Mac OS X, added functionality</li>
      <li>Does not run OS X applications natively
        <ul>
          <li>Also runs on different CPU architecture (ARM vs. Intel)</li>
        </ul>
      </li>
      <li>Cocoa Touch Objective-C API for developing apps</li>
      <li>Media services layer for graphics, audio, video</li>
      <li>Core services provides cloud computing, databases</li>
      <li>Core operating system, based on Mac OS X kernel</li>
    </ul>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20220907234000505.png" alt="image-20220907234000505" /></p>

<p><br /></p>

<h2 id="android">Android</h2>

<ul>
  <li>Developed by Open Handset Alliance (mostly Google)
    <ul>
      <li>Open Source</li>
    </ul>
  </li>
  <li>Similar stack to IOS</li>
  <li>Based on Linux kernel but modified
    <ul>
      <li>Provides process, memory, device-driver management</li>
      <li>Adds power management</li>
    </ul>
  </li>
  <li>Runtime environment includes core set of libraries and Dalvik virtual machine
    <ul>
      <li>Apps developed in Java plus Android API
        <ul>
          <li>Java class files compiled to Java bytecode then translated to executable than runs in Dalvik VM</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Libraries include frameworks for web browser (webkit), database (SQLite), multimedia, smaller libc</li>
</ul>

<p><br /></p>

<h2 id="android-architecture">Android Architecture</h2>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20220907234053174.png" alt="image-20220907234053174" /></p>

<p><br /></p>

<h2 id="operating-system-debugging">Operating-System Debugging</h2>

<ul>
  <li>Debugging is finding and fixing errors, or bugs</li>
  <li>Failure analysis
    <ul>
      <li>If a process fails, OS generate log files containing error information and Failure of an application can generate core(memory) dump file capturing memory of the process
        <ul>
          <li>Running program and core dump can be probed by debugger</li>
        </ul>
      </li>
      <li>OS failure is called crash. Error info is saved on log files, and crash dump file containing kernel memory is saved</li>
    </ul>
  </li>
  <li>Beyond crashes, performance tuning can optimize system performance
    <ul>
      <li>Sometimes using trace listings of activities, recorded for analysis</li>
      <li>Unix command top</li>
      <li>Windows Task Manager</li>
    </ul>
  </li>
  <li>Kernighanâ€™s Law: â€œDebugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it.â€</li>
</ul>

<p><br /></p>

<h2 id="performance-tuning">Performance Tuning</h2>

<ul>
  <li>Improve performance by removing bottlenecks</li>
  <li>To identify bottleneks, we need monitoring system performance</li>
  <li>OS must provide means of computing and displaying measures of system behavior</li>
  <li>For example, â€œtopâ€ program or Windows Task Manager
    <ul>
      <li>Display resources used</li>
      <li>CPU. Memory usuage, networking í†µê³„</li>
    </ul>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20220907234204265.png" alt="image-20220907234204265" /></p>

<p><br /></p>

<h2 id="dtrace">DTrace</h2>

<ul>
  <li>DTrace tool in Solaris, FreeBSD, Mac OS X allows live instrumentation on production systems</li>
  <li>Probes fire when code is executed within a provider, capturing state data and sending it to consumers of those probes</li>
  <li>Example of following XEventsQueued system call move from libc library to kernel and back</li>
</ul>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20220907234230584.png" alt="image-20220907234230584" /></p>

<p><br /></p>

<ul>
  <li>DTrace code enables scheduler to probe and record amount of time of each process running with UserID 101 in running mode (on CPU) in nanoseconds</li>
</ul>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20220907234305805.png" alt="image-20220907234305805" /></p>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20220907234310961.png" alt="image-20220907234310961" /></p>

<p><br /></p>

<h2 id="operating-system-generationbuilding-an-os">Operating System Generation(Building an OS)</h2>

<ul>
  <li>Building OS
    <ul>
      <li>Write OS source code, or obtain written source code</li>
      <li>Configure the OS for specific machine</li>
      <li>Compile the OS</li>
      <li>Install the OS</li>
      <li>Boot the computer and its OS</li>
    </ul>
  </li>
  <li>Operating systems are designed to run on any of a class of machines; the system must be configured for each specific computer site
    <ul>
      <li>The computer system must be configured and generated for each computer site â€“ need system generation</li>
    </ul>
  </li>
  <li>SYSGEN program obtains information concerning the specific configuration of the hardware system from OS distribution file
    <ul>
      <li>Used to build system-specific compiled kernel or system-tuned</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="system-boot">System Boot</h2>

<ul>
  <li>When power initialized on system, execution starts at a fixed memory location
    <ul>
      <li>Firmware ROM used to hold initial boot code</li>
    </ul>
  </li>
  <li>Operating system must be made available to hardware so hardware can start it
    <ul>
      <li>Small piece of code â€“ bootstrap program, stored in ROM or EEPROM locates the kernel, loads it into memory, and starts it
        <ul>
          <li>Sometimes two-step process where small bootstrap loader (BIOS), stored in ROM, load a second boot loader at fixed location (boot block) of disk</li>
        </ul>
      </li>
      <li>Kernel initializes hardware, Inspecting memory, CPU.</li>
      <li>root file system is mounted</li>
    </ul>
  </li>
  <li>Common open source bootstrap loader for unix, GRUB, allows selection of kernel from multiple disks, versions, kernel options</li>
</ul>
:ET