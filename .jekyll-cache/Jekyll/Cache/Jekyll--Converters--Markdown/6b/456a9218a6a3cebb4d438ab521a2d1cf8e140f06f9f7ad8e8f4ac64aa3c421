I"—µ<p>[toc]</p>

<h1 id="chapter-8-deadlocks">Chapter 8: Deadlocks</h1>

<ul>
  <li>System Model</li>
  <li>Deadlock Characterization</li>
  <li>Methods for Handling Deadlocks</li>
  <li>Deadlock Prevention</li>
  <li>Deadlock Avoidance</li>
  <li>Deadlock Detection</li>
  <li>Recovery from Deadlock</li>
  <li>Combined Approach to Deadlock Handling</li>
</ul>

<p><br /></p>

<h2 id="chapter-objectives">Chapter Objectives</h2>

<ul>
  <li>Illustrate how deadlock can occur when <strong>mutex locks</strong> are used</li>
  <li>Define the <strong>four necessary conditions</strong> that characterize deadlock</li>
  <li>Identify a deadlock situation in a <strong>resource allocation graph</strong></li>
  <li>Evaluate the four different approaches for <strong>preventing deadlocks</strong></li>
  <li>Apply the bankerâ€™s algorithm for <strong>deadlock avoidance</strong></li>
  <li>Apply the <strong>deadlock detection</strong> algorithm</li>
  <li>Evaluate approaches for recovering from deadlock</li>
</ul>

<p><br /></p>

<h2 id="bridge-crossing-example">Bridge Crossing Example</h2>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20221002222310399.png" alt="image-20221002222310399" /></p>

<ul>
  <li>Traffic only in one direction.</li>
  <li>Each section of a bridge can be viewed as a resource.
    <ul>
      <li>ë‹¤ë¦¬ - resource</li>
    </ul>
  </li>
  <li>If a deadlock occurs, it can be resolved if one car backs up  (preempt resources and rollback).</li>
  <li>Several cars may have to be backed up if a deadlock occurs.</li>
  <li>Starvation is possible.</li>
</ul>

<p><br /></p>

<h2 id="system-model">System Model</h2>

<ul>
  <li>
    <p>System consists of resources</p>
  </li>
  <li>
    <p>Resource types R1 , R2 , . . ., Rm</p>

    <p>CPU cycles, memory space, I/O devices</p>
  </li>
  <li>
    <p>Each resource type Ri has Wi instances(CPU).</p>
  </li>
  <li>
    <p>ê³µìœ ê°€ ì•ˆë˜ëŠ” resourceì—ì„œ ë¬¸ì œê°€ ë¨.</p>
  </li>
  <li>
    <p>If a resource is non-sharable, Each process utilizes a resource as follows:</p>

    <ul>
      <li>request resource</li>
      <li>use</li>
      <li>Release</li>
    </ul>
  </li>
  <li>
    <p>OS manages resources</p>

    <ul>
      <li>Maintains info. regarding availability of resource, which process using resource etc.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="deadlock-with-semaphores">Deadlock with Semaphores</h2>

<ul>
  <li>A set of blocked processes each holding a resource and waiting to acquire a  resource held by another process in the set.
    <ul>
      <li>Example
        <ul>
          <li>System has 2 tape drives.</li>
          <li>P1 and P2 each hold one tape drive and each needs another one.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Data:
    <ul>
      <li>A semaphore S1 initialized to 1</li>
      <li>A semaphore S2 initialized to 1</li>
    </ul>
  </li>
  <li>Two processes P1 and P2</li>
  <li>P1:
    <ul>
      <li>wait(s1)</li>
      <li>wait(s2)</li>
    </ul>
  </li>
  <li>P2:
    <ul>
      <li>wait(s2)</li>
      <li>wait(s1)</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="deadlock-in-multithreaded-application">Deadlock in multithreaded application</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pthread_mutex_t first_mutex;
pthread_mutex_t second_mutex;

pthread_mutex_init(&amp;first_mutex, NULL);
pthread_mutex_init(&amp;second_mutex, NULL);
</code></pre></div></div>

<p>mutex_lockì€ semaphoreì™€ ë‹¤ë¥´ê²Œ blockì´ ì•ˆë¨.</p>

<p><br /></p>

<h2 id="deadlock-in-multithreaded-application-1">Deadlock in multithreaded application</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">do_work_one</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">param</span><span class="p">){</span> <span class="cm">/* thread one */</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">first_mutex</span><span class="p">);</span> <span class="cm">/* POSIX mutex lock */</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">second_mutex</span><span class="p">);</span>
    <span class="cm">/* do some work */</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">second_mutex</span><span class="p">);</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">first_mutex</span><span class="p">);</span>
    <span class="n">pthread_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">do_work_two</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">param</span><span class="p">){</span> <span class="cm">/* thread two */</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">second_mutex</span><span class="p">);</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">first_mutex</span><span class="p">);</span>
    <span class="cm">/* do some work */</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">first_mutex</span><span class="p">);</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">second_mutex</span><span class="p">);</span>
    <span class="n">pthread_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>deadlock ë°œìƒ
    <ul>
      <li>ë‹¤ë¥¸ ìƒëŒ€ë°©ì´ ê°–ê³  ìˆëŠ” mutex_lockì„ ê°€ì§ˆ ìˆ˜ ìˆëŠ” ê²½ìš°ëŠ” ì—†ë‹¤.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="livelock-in-multithreaded-application">Livelock in multithreaded application</h2>

<ul>
  <li>similar to deadlock, but the threads are unable to proceed <strong>for different reasons</strong></li>
  <li><strong>Deadlock</strong> occurs when every thread in a set is blocked waiting for  an event that can be caused only by another thread in the set
    <ul>
      <li>eventë¥¼ ë°œìƒí•˜ê¸°ë¥¼ ê¸°ë‹¤ë¦¬ëŠ”ë° eventê°€ ì‹¤í–‰ë˜ì§€ ì•Šì„ ë•Œ</li>
      <li>Deadlocks can occur via system calls, locking, etc.</li>
    </ul>
  </li>
  <li><strong>Livelock</strong>
    <ul>
      <li>when threads retry failing operations at the same time
        <ul>
          <li>ì˜ë¯¸ì—†ëŠ” operationì„ ë°˜ë³µí•˜ëŠ” ìƒíƒœ</li>
        </ul>
      </li>
      <li><strong>pthread_mutex_trylock() function</strong> attempts to acquire a mutex lock without blocking</li>
      <li>Livelock can be avoided by having each retry <strong>failing operations</strong> at random times
        <ul>
          <li>random ì‹œê°„ ë§Œí¼ delayë¥¼ ì£¼ê³  ë‹¤ì‹œ ì‹œë„</li>
        </ul>
      </li>
      <li>Ethernet collision detection</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="livelock-in-multithreaded-application-1">Livelock in multithreaded application</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">do_work_one</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">param</span><span class="p">){</span> <span class="cm">/* thread one */</span>
    <span class="kt">int</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">first_mutex</span><span class="p">);</span> 
        <span class="k">if</span> <span class="p">(</span><span class="n">pthread_mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">second_mutex</span><span class="p">))</span> <span class="p">{</span>
            <span class="cm">/* do some work */</span>
            <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">second_mutex</span><span class="p">);</span>
            <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">first_mutex</span><span class="p">);</span>
            <span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
            <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">first_mutex</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">pthread_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">do_work_two</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">param</span><span class="p">){</span> <span class="cm">/* thread two */</span>
    <span class="kt">int</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">second_mutex</span><span class="p">);</span> 
        <span class="k">if</span> <span class="p">(</span><span class="n">pthread_mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">first_mutex</span><span class="p">))</span> <span class="p">{</span>
            <span class="cm">/* do some work */</span>
            <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">first_mutex</span><span class="p">);</span>
            <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">second_mutex</span><span class="p">);</span>
            <span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> 
        <span class="k">else</span>
            <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">second_mutex</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">pthread_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>if (pthread_mutex_trylock(mutex)) ë¥¼ í•´ë„ ì´ë¯¸ firstì™€ second ëª¨ë‘ lockì„ ì–»ì€ ìƒíƒœì´ê¸° ë•Œë¬¸ì— falseì¼ ê²ƒì´ë‹¤.</p>

<p>ê·¸ë˜ì„œ elseë¬¸ì˜ pthread_mutex_unlockì„ í•˜ì—¬ ë‹¤ì‹œ ëŒì•„ê°€ì„œ ë˜‘ê°™ì´ ë°˜ë³µí•œë‹¤.</p>

<p>livelock, deadlock, deadlock with semaphore ì…‹ ê°„ì˜ ì°¨ì´ì </p>

<ul>
  <li>deadlock with semaphore
    <ul>
      <li>wait(S1)ì„ í•˜ë©´ kernelë¡œ ë‚´ë ¤ì˜¤ëŠ”ë° semaphore ê°’ì´ 1ì´ë‹ˆê¹Œ ë°”ë¡œ returnì´ ë¨</li>
      <li>return ë˜ë©´ì„œ <strong>semaphoreê°€</strong> 0-&gt;1ë¡œ ë°”ë€Œê³ </li>
      <li>ê·¸ ì´í›„ì— wait(S2)</li>
      <li>ê·¸ëŸ¬ë©´ ëª» ëŒì•„ì˜´(block)</li>
    </ul>
  </li>
  <li>deadlock in multithreaded
    <ul>
      <li>mutex_lock</li>
      <li>ì²«ë²ˆì§¸ ë¬¸ì¥ìœ¼ë¡œ first_mutexë¥¼ ì–»ê³  ë‹¤ë¥¸ í•¨ìˆ˜ì˜ ì²«ë²ˆì§¸ ë¬¸ì¥ìœ¼ë¡œ second_mutexë¥¼ ì–»ìŒ</li>
      <li>ê·¼ë° ë‘ í•¨ìˆ˜ ì–´ë–¤ ê²ƒì´ë“  ë‘ ë²ˆì§¸ ë¬¸ì¥ì€ ì‹¤í–‰ì´ ì•ˆëœë‹¤. (1ì—ì„œ 0ìœ¼ë¡œ ë°”ë€Œì—ˆì„í…Œë‹ˆê¹Œ)</li>
      <li>ì»¤ë„ ì•ˆì—ì„œ ë¹™ê¸€ë¹™ê¸€ ëŒê³  ìˆìŒ (wait ìƒíƒœë¥¼ ê°„ ê²Œ ì•„ë‹˜)</li>
      <li>ë‹¤ë¥¸ lockì„ ì–»ìœ¼ë ¤ê³  í•˜ëŠ”ë° ëª»ì–»ê³  ìˆìœ¼ë‹ˆê¹Œ ê³„ì† ì–»ìœ¼ë ¤ê³  ì‹œê³ í•˜ê³  ìˆëŠ” ê±°ì„.</li>
    </ul>
  </li>
  <li>livelock
    <ul>
      <li>ë‘ threadê°€ ê°ê°</li>
      <li>pthread_mutex_trylock: ë°”ë¡œ userì—ê²Œ lockì„ ì–»ì—ˆëŠ”ì§€ ëª»ì–»ì—ˆëŠ”ì§€ì˜ ê²°ê³¼ë¥¼ returní•´ì¤Œ
        <ul>
          <li>ê·¸ë˜ì„œ if ì¡°ê±´ë¬¸ì— ë”± ê±¸ë¦¬ê¸° ë•Œë¬¸ì— íšë“í–ˆëŠ”ì§€ ì•ˆí–ˆëŠ”ì§€ ë”± ì•Œ ìˆ˜ ìˆìŒ.</li>
        </ul>
      </li>
      <li>ë§Œì•½ ëª»ì–»ê³  elseì— ê±¸ë¦¬ë©´ ì²«ë²ˆì§¸ ë¬¸ì¥ìœ¼ë¡œ íšë“í–ˆë˜ lockì„ íšŒìˆ˜í•˜ê³  ë‹¤ì‹œ ì‹œë„í•œë‹¤.</li>
      <li>ì´ ê³¼ì •ì„ ë°˜ë³µí•˜ë©´ deadlockì´ ë°œìƒí•  í™•ë¥ ì´ í˜„ì €íˆ ì¤„ì–´ë“ ë‹¤.</li>
      <li>sleep(rand(100)) ê³¼ ê°™ì´ random timeì„ ê¸°ë‹¤ë¦¬ê²Œ í•œë‹¤.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="deadlock-characterization">Deadlock Characterization</h2>

<p>Deadlock can arise if four conditions hold simultaneously.(4ê°œì˜ í•„ìš”ì¡°ê±´)</p>

<p>4ê°€ì§€ê°€ ë™ì‹œì— ì¼ì–´ë‚˜ì•¼ deadlock ë°œìƒ</p>

<ul>
  <li><strong>Mutual exclusion</strong>: at least one resource must be held in a non-sharable mode
    <ul>
      <li><u>only one process at a time can use a resource.</u></li>
      <li>ì˜¤ë¡œì§€ í•˜ë‚˜ì˜ í”„ë¡œì„¸ìŠ¤ë§Œì´ í•˜ë‚˜ì˜ ìì›ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.</li>
      <li>If a process wants resource held by another process, it must suspend</li>
      <li>Wait for process holding resource to release it</li>
    </ul>
  </li>
  <li><strong>Hold and wait</strong>: a process holding at least one resource is waiting to acquire additional resources held by other processes.
    <ul>
      <li>ê³µìœ ê°€ ë¶ˆê°€ëŠ¥í•œ resourceë¥¼ ì ì–´ë„ í•œ ê°œì´ìƒ ë³´ìœ í•˜ê³  ìˆëŠ” í”„ë¡œì„¸ìŠ¤ and ë‹¤ë¥¸ resourceë¥¼ ìš”êµ¬í•  ë•Œ</li>
      <li>ìì›ì„ ìµœì†Œ í•œ ê°œë¥¼ ê°–ê³  ìˆìœ¼ë©´ì„œ ë‹¤ë¥¸ ìì›ì„ ê¸°ë‹¤ë¦¬ê³  ìˆëŠ” ìƒíƒœ</li>
    </ul>
  </li>
  <li><strong>No preemption</strong>: a resource can be released only voluntarily(ìë°œì ìœ¼ë¡œ) by the process  holding it, after that process has completed its task.
    <ul>
      <li>preemptionì´ ë¶ˆê°€ëŠ¥í•œ resourceê°€ ìˆì–´ì•¼ í•¨.</li>
      <li>í”„ë¡œì„¸ìŠ¤ëŠ” ì‘ì—…ì„ ì™„ë£Œí•œ í›„ì—ë§Œ ì†Œìœ í•˜ê³  ìˆë˜ ìì›ì„ ë°˜ë‚©í•  ìˆ˜ ìˆë‹¤.</li>
    </ul>
  </li>
  <li><strong>Circular wait</strong>: there exists a set {P0 , P1 , â€¦, P0 } of waiting processes such that P0 is waiting for a resource that is held by  P1 , P1 is waiting for a resource that is held by P2 , â€¦, Pnâ€“1 is waiting for a resource that is held by Pn , and P0 is waiting for a resource that is held by  P0 .
    <ul>
      <li>circularí•˜ê²Œ ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ì˜ resourceë¥¼ ì—°ì‡„ì ìœ¼ë¡œ ê¸°ë‹¤ë¦¬ê³  ìˆëŠ” ìƒíƒœì´ë‹¤.</li>
      <li>í”„ë¡œì„¸ìŠ¤ê°€ ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ì˜ ìì›ì„ ìš”êµ¬í•˜ëŠ” í˜•íƒœê°€ ì›í˜•ì„ ì´ë£¨ê³  ìˆëŠ” ìƒíƒœ</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="resource-allocation-graph">Resource-Allocation Graph</h2>

<p>A set of vertices V and a set of edges E.</p>

<ul>
  <li>V is partitioned into two types:
    <ul>
      <li>P = {P1 , P2 , â€¦, Pn }, the set consisting of all the processes in the  system.</li>
      <li>R = {R1 , R2 , â€¦, Rm}, the set consisting of all resource types in the  system.</li>
    </ul>
  </li>
  <li>2 types of edges
    <ul>
      <li>request edge â€“ directed edge P1 -&gt; Rj
        <ul>
          <li>Indicates process waiting for instances of a resource type</li>
        </ul>
      </li>
      <li>assignment edge â€“ directed edge Rj -&gt; Pi
        <ul>
          <li>Indicates an instance of resource held by process</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="resource-allocation-graph-cont">Resource-Allocation Graph (Cont.)</h2>

<ul>
  <li>
    <p>Process<img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20221002223045837.png" alt="image-20221002223045837" /></p>
  </li>
  <li>
    <p>Resource Type with 4 instances <img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20221002223100966.png" alt="image-20221002223100966" /></p>
  </li>
  <li>
    <p>P<sub>i</sub> requests instance of R<sub>j</sub> <img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20221002223131353.png" alt="image-20221002223131353" /></p>
  </li>
  <li>
    <p>P<sub>i</sub> is holding an instance of R<sub>j</sub> <img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20221002223152827.png" alt="image-20221002223152827" /></p>
  </li>
</ul>

<p><br /></p>

<h2 id="example-of-a-resource-allocation-graph">Example of a Resource Allocation Graph</h2>

<ul>
  <li>One instance of R1</li>
  <li>Two instances of R2</li>
  <li>One instance of R3</li>
  <li>Three instance of R4</li>
  <li>P1 holds one instance of R2 and is  waiting for an instance of R1</li>
  <li>P2 holds one instance of R1, one  instance of R2, and is waiting for an  instance of R3</li>
  <li>P3 is holds one instance of R3</li>
</ul>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20221002223234227.png" alt="image-20221002223234227" /></p>

<ul>
  <li>2 process P1, P2</li>
  <li>resources f1, f2</li>
  <li>P1: request(f1)                P2: request(f2)</li>
  <li>request(f2)                       request(f1)
    <ul>
      <li>P1ì´ ì­‰ ì‹¤í–‰ëœ í›„ releaseë¥¼ í•œë‹¤ë©´ deadlockì€ ë°œìƒí•˜ì§€ ì•Šì„ ê²ƒì´ë‹¤.</li>
      <li>ê·¸ëŸ¬ë‚˜ P1ì—ì„œ ì²«ë¬¸ì¥ì„ ì‹¤í–‰í•˜ê³  P2ì—ì„œ ì²«ë¬¸ì¥ì„ ì‹¤í–‰í•œ í›„ì—
        <ul>
          <li>ê°ì ê·¸ ë‹¤ìŒ ë¬¸ì¥ì„ ì‹¤í–‰í•˜ë ¤ í•˜ë©´ resource allocation graphì—ì„œ cycleì´ í˜•ì„± ëœë‹¤.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20221002223321330.png" alt="image-20221002223321330" /></p>

<p>Cycle in resource allocation graph sufficient for deadlock if each resource type in cycle <strong>consists of a single entity</strong></p>

<ul>
  <li>
    <p>cycleì´ ì¡´ì¬í•˜ë©´ deadlockì„ ë°œìƒì‹œí‚¨ë‹¤ëŠ” ì¶©ë¶„ì¡°ê±´ì€ resource typeê°€ single entityë¥¼ êµ¬ì„±í•˜ëŠ” ê²ƒ</p>
  </li>
  <li>
    <p>cycleì´ ì—†ìœ¼ë©´ deadlockë„ ì—†ë‹¤.</p>
  </li>
</ul>

<p><br /></p>

<h2 id="resource-allocation-graph-with-a-deadlock">Resource Allocation Graph With A Deadlock</h2>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20221002223354398.png" alt="image-20221002223354398" /></p>

<ul>
  <li>P1ì´ R1ì„ ìš”ì²­í•˜ë‚˜ íšë“í•  ê°€ëŠ¥ì„±ì€ ì—†ìŒ
    <ul>
      <li>P2ê°€ ê°€ì§€ê³  ìˆê¸° ë•Œë¬¸ì— request edgeê°€ assignment edgeë¡œ ë°”ë€” ìˆ˜ê°€ ì—†ìŒ.</li>
    </ul>
  </li>
  <li>P2 ì—­ì‹œ P3ê°€ ê°–ê³  ìˆëŠ” ê²ƒì„ ìš”êµ¬ í•˜ê³  ìˆê¸° ë•Œë¬¸ì— ê°€ëŠ¥ì„± ì—†ìŒ</li>
  <li>P3ë„ P1ì´ ê°–ê³  ìˆëŠ” ê²ƒì„ ê¸°ë‹¤ë¦¬ê³  ìˆìŒ.</li>
  <li>ë”°ë¼ì„œ ì´ëŠ” circular wait</li>
  <li>ê³µìœ ë„ ì•ˆë˜ê³ , preemptionë„ ì•ˆë˜ê³  hold and wait ì¡°ê±´ë„ ë§Œì¡±í•˜ê³ </li>
  <li>R2ëŠ” single resourceê°€ ì•„ë‹ˆê¸° ë•Œë¬¸ì— cycleì´ ìˆë‹¤ê³  ë¬´ì¡°ê±´ deadlockì€ ì•„ë‹ˆë‹¤.</li>
</ul>

<p><br /></p>

<h2 id="resource-allocation-graph-with-a-cycle-but-no-deadlock">Resource Allocation Graph With A Cycle But No Deadlock</h2>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20221002223421800.png" alt="image-20221002223421800" /></p>

<ul>
  <li>
    <p>R1ê³¼ R2ê°€ single resourceê°€ ì•„ë‹ˆê¸° ë•Œë¬¸ì— í•„ìš”ì¡°ê±´ì€ ë§Œì¡±í–ˆì§€ë§Œ ì¶©ë¶„ì¡°ê±´ì€ ë§Œì¡±í•˜ì§€ ëª»í–ˆë‹¤.</p>
  </li>
  <li>P1ì€ P2ë‚˜ P3 ë‘˜ ì¤‘ ì–´ëŠ ê²ƒì´ releaseí•˜ëŠ” resourceë¥¼ ê¸°ë‹¤ë¦¬ê³  ìˆìŒ.</li>
  <li>ì—¬ê¸°ì„œ P2ì™€ P4ëŠ” holdë§Œ í•˜ê³  ìˆê¸° ë•Œë¬¸ì—(not hold and wait) ìì›ì„ ë†“ì•˜ì„ ë•Œ cycleì´ ê¹¨ì§€ê¸° ë•Œë¬¸ì— deadlockì´ ì•„ë‹ˆë‹¤</li>
</ul>

<p><br /></p>

<h2 id="basic-facts">Basic Facts</h2>

<ul>
  <li>If graph contains no cycles =&gt; no deadlock.</li>
  <li>If graph contains a cycle =&gt;
    <ul>
      <li>if only one instance per resource type, then <strong>deadlock</strong>. (ì¶©ë¶„ì¡°ê±´)
        <ul>
          <li>í•˜ë‚˜ë©´ ë¬´ì¡°ê±´ ë°ë“œë½</li>
        </ul>
      </li>
      <li>if several instances per resource type, possibility of deadlock. (í•„ìš”ì¡°ê±´)
        <ul>
          <li>ì¼ìˆ˜ë„ ì•„ë‹ìˆ˜ë„</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>ì¦‰ cycleì´ ìˆëŠ”ë° single resource typeì´ë©´ ë¬´ì¡°ê±´ ë°ë“œë½ì´ë‹¤.</li>
</ul>

<p><br /></p>

<h2 id="methods-for-handling-deadlocks">Methods for Handling Deadlocks</h2>

<ul>
  <li>Ensure that the system will <strong>never</strong> enter a deadlock state. : overheadê°€ ìˆìŒ(ì‚¬ì „ì— ë°œìƒê°€ëŠ¥ì„±ì„ ì°¨ë‹¨í•´ì•¼ í•˜ê¸° ë•Œë¬¸ì—)
    <ul>
      <li>: Deadlock í˜„ìƒ ìì²´ë¥¼ ë¯¸ì—°ì— ë°©ì§€í•˜ëŠ” ë°©ë²•
        <ul>
          <li>Deadlock prevention</li>
          <li>Deadlock avoidance</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Allow the system to enter a deadlock state and then recover.
    <ul>
      <li>Deadlock ìƒíƒœë¥¼ í—ˆìš©í•˜ë©´ì„œ ê·¸ê²ƒì„ ë³µêµ¬í•˜ëŠ” ë°©ë²•
        <ul>
          <li>Deadlock detection and recovery</li>
        </ul>
      </li>
      <li>ì‚¬ì „ì— ì•„ë¬´ ì¡°ì¹˜ë¥¼ ì·¨í•˜ì§€ ì•Šê³  ì£¼ê¸°ì ìœ¼ë¡œ ì²´í¬ë§Œ í•¨.</li>
    </ul>
  </li>
  <li>Ignore the problem and pretend that deadlocks never occur in the  system; used by most operating systems, including UNIX.
    <ul>
      <li>Deadlock ë¬¸ì œ ìì²´ë¥¼ ë¬´ì‹œí•´ ë²„ë¦¬ëŠ” ë°©ë²•</li>
      <li>deadlockê³¼ ê´€ë ¨í•´ì„œ OSê°€ í•´ì¤„ ìˆ˜ ìˆëŠ” ì¼ì´ ì•„ë¬´ê²ƒë„ ì—†ìœ¼ë‹ˆê¹Œ ê·¸ëƒ¥ ë¬´ì‹œ
        <ul>
          <li>ê·¸ëƒ¥ kill í•˜ê±°ë‚˜ rebooting</li>
        </ul>
      </li>
      <li>OSê°€ ì œê³µí•˜ì§€ ì•Šìœ¼ë©´ application ë‚´ì— í•´ê²°ì±… êµ¬í˜„ì´ í•„ìš”í•  ìˆ˜ë„ ìˆìŒ.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="deadlock-prevention">Deadlock Prevention</h2>

<ul>
  <li><strong>Invalidate one of the four necessary conditions for deadlock</strong>:
    <ul>
      <li>A set of methods for ensuring that one of 4 necessary conditions for  deadlock cannot hold</li>
    </ul>
  </li>
  <li>Restrain the ways request can be made.
    <ul>
      <li>Result in low device utilization and reduced system throughput</li>
    </ul>
  </li>
</ul>

<p>1) Mutual Exclusion ë¶€ì •</p>
<ul>
  <li>not required for sharable resources
    <ul>
      <li>(e.g., read-only files)</li>
    </ul>
  </li>
  <li>must hold for non-sharable resources.</li>
  <li>Depends on resources</li>
  <li>Not practical - ì˜ë¯¸ê°€ ì—†ìŒ(ì‹¤í˜„ ë¶ˆê°€ëŠ¥0)</li>
  <li>ì• ì´ˆì— ìì›ì— ë™ì‹œ ì ‘ê·¼ì´ ë¶ˆê°€ëŠ¥í•˜ê¸° ë•Œë¬¸ì— ë™ì‹œì—¥ ì ‘ê·¼ì„ í•˜ê²Œ í•˜ëŠ” ê²ƒì€ ë¶ˆê°€ëŠ¥</li>
</ul>

<p><br /></p>

<ol>
  <li>
    <p>Hold and Wait ë¶€ì •  - must guarantee that whenever a process requests a resource, it does not hold any other resources.</p>

    <ul>
      <li>í”„ë¡œì„¸ìŠ¤ê°€ ìì›ì„ ìš”ì²­í•  ë•ŒëŠ” í•­ìƒ ì–´ëŠ ìì›ë„ ì†Œìœ í•˜ê³  ìˆì§€ ì•Šë„ë¡ í•´ì•¼ í•œë‹¤.
        <ul>
          <li>í”„ë¡œì„¸ìŠ¤ê°€ ì‹¤í–‰ë˜ê¸° ì „ì— í•„ìš”í•œ ìì›ë“¤ì„ ëª¨ë‘ ìš”ì²­í•˜ê³  í• ë‹¹ ë°›ëŠ”ë‹¤.</li>
        </ul>
      </li>
      <li>One shot allocation
        <ul>
          <li>Require process to request and be allocated all its resources  before it begins execution,</li>
          <li>í•œêº¼ë²ˆì— ìš”êµ¬ -&gt; ìì›ì˜ ë‚­ë¹„ê°€ ì‹¬í•¨(ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ê²ƒë„ ë¯¸ë¦¬ ë°›ì•„ë†“ê¸° ë–„ë¬¸)</li>
        </ul>
      </li>
      <li>or allow process to request resources only when the process has none.
        <ul>
          <li>Release resources held before requesting more</li>
        </ul>
      </li>
      <li>Prob.
        <ul>
          <li>Ability to acquire resources simultaneously may be limited</li>
          <li>Low throughput : processes may be suspended waiting for jobs  holding resources they donâ€™t need</li>
          <li>Low resource utilization :</li>
          <li>starvation possible : Not all the required resources may  become available at once</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<p><br /></p>

<p>3) No Preemption ë¶€ì •</p>
<ul>
  <li>ê°–ê³  ìˆëŠ” ìì›ì„ í”„ë¡œì„¸ìŠ¤ê°€ ìŠ¤ìŠ¤ë¡œ ë°˜ë‚©í•˜ê¸° ì „ê¹Œì§€ëŠ” íšŒìˆ˜ ë˜ì§€ ì•ŠìŒ
    <ul>
      <li>í”„ë¡œì„¸ìŠ¤ê°€ í•˜ë‚˜ ì´ìƒì˜ ìì›ì„ ì†Œìœ í•˜ê³  ìˆê³  ì¦‰ì‹œ í• ë‹¹ ë°›ì„ ìˆ˜ ì—†ëŠ” ë‹¤ë¥¸ ìì›ì„ ìš”ì²­í•˜ëŠ” ê²½ìš° ì†Œìœ í•˜ê³  ìˆëŠ” ìì›ì„ ëª¨ë‘ ë°˜ë‚©í•˜ê²Œ í•˜ëŠ” ê²ƒ</li>
    </ul>
  </li>
  <li>ì ˆëŒ€ë¡œ preemptionì„ ëª»í•˜ê²Œ ë˜ë©´ deadlock í™•ë¥ ì´ ì¦ê°€í•˜ê¸° ë•Œë¬¸ì— preemptionì„ ê°€ëŠ¥í•˜ê²Œ í•˜ë©´ deadlock í™•ë¥ ì´ ê°ì†Œí•œë‹¤.</li>
  <li>If a process that is holding some resources requests another  resource that cannot be immediately allocated to it, then all resources currently being held are released</li>
  <li>Take away resources from a process suspended on requests
    <ul>
      <li>(If  a process that is holding some resources requests another  resource that cannot be immediately allocated to it, then all  resources currently being held are released)</li>
    </ul>
  </li>
  <li>Preempted resources are added to the list of resources for  which the process is waiting.</li>
  <li>Process will be restarted only when it can regain its old  resources, as well as the new ones that it is requesting.</li>
  <li>Starvation</li>
</ul>

<p>4) Circular Wait</p>
<ul>
  <li>ìì›ë“¤ì˜ total orderingì„ ë°˜í™˜í•˜ëŠ” F() í•¨ìˆ˜ë¥¼ ì‚¬ìš©</li>
  <li>Ensure that there is no cycle of suspended processes</li>
  <li>impose a total ordering of all resource types,
    <ul>
      <li>Disk(3), tape(5) ,,,,</li>
      <li>ë‚®ì€ ë²ˆí˜¸ì˜ resource requestëŠ” ê±°ë¶€</li>
    </ul>
  </li>
  <li>require that each process requests resources in an increasing order of  enumeration.
    <ul>
      <li>Processes can only request a resource whose associated value is  greater than value of any resources it holds</li>
    </ul>
  </li>
  <li>P1ì€ R1ì„ ìš”êµ¬í•˜ê¸° ìœ„í•´ì„œ R2ë¥¼ releaseí•˜ê³  í•´ì•¼ í•¨!</li>
  <li>If want resource less than hold
    <ul>
      <li>Release resources &gt; new request</li>
      <li>Make new request in ascending order</li>
    </ul>
  </li>
  <li>Circular wait (P1 has R2, wait for R1 ; P2 has R1, wait for R2)
    <ul>
      <li>Impossible situation</li>
    </ul>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20221002223908168.png" alt="image-20221002223908168" /></p>

<p><br /></p>

<h2 id="circular-wait-deadlock-example">Circular Wait (Deadlock Example)</h2>

<ul>
  <li>Invalidating the circular wait  condition is most common.</li>
  <li>Simply assign each resource  (i.e., mutex locks) a unique  number.</li>
  <li>Resources must be acquired in  order.</li>
  <li>If 
first_mutex = 1 
second_mutex = 5</li>
  <li>code for thread_two could not  be written:</li>
</ul>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20221002223951090.png" alt="image-20221002223951090" /></p>

<p><br /></p>

<h2 id="deadlock-example-with-lock-ordering">Deadlock Example with Lock Ordering</h2>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20221002224013927.png" alt="image-20221002224013927" /></p>

<ul>
  <li>Transactions 1 and 2 execute concurrently. Transaction 1 transfers $25  from account A to account B, and Transaction 2 transfers $50 from  account B to account A</li>
  <li>
    <p>Java: System.identifyHashCode(Object) â€“ returns the hash code value  for ordering lock acquisition</p>
  </li>
  <li>lock ë²ˆí˜¸ë¥¼ ì–»ëŠ”ë° ë„ì›€ì´ ë˜ëŠ” hash code</li>
</ul>

<p><br /></p>

<h2 id="deadlock-avoidance">Deadlock Avoidance</h2>

<ul>
  <li>Deadlock prevention prevent deadlocks by restraining how requests  can be made</li>
  <li>
    <p>Lead to low device utilization and reduced system throughput</p>
  </li>
  <li>System will not grant request which could potentially lead to deadlock
    <ul>
      <li>ììœ  í˜•ì‹ìœ¼ë¡œ ìš”ì²­ì„ í•  ìˆ˜ ìˆì§€ë§Œ deadlockìœ¼ë¡œ ë°œì „í•  ê°€ëŠ¥ì„±ì´ ìˆëŠ” requestë¥¼ ê±°ë¶€í•œë‹¤.</li>
    </ul>
  </li>
  <li>
    <p>Requires that the system has some additional a priori information(ì‚¬ì „ ì •ë³´) available.</p>

    <ul>
      <li>
        <p>Simplest and most useful model requires that each process declare the <strong>maximum number</strong> of resources of each type that it may need.</p>
      </li>
      <li>
        <p>The deadlock-avoidance algorithm dynamically examines the resource-allocation state to ensure that there can never be a circular-wait condition.</p>
      </li>
      <li>
        <p>Resource-allocation state is defined by the number of available and  allocated resources, and the maximum demands of the processes.</p>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="safe-state">Safe State</h2>

<ul>
  <li>When a process requests an available resource, system must  decide if immediate allocation leaves the system in a safe state.</li>
  <li>System is in safe state if there exists a safe sequence of all  processes.</li>
  <li>Sequence {P1, P2, â€¦, Pn} is safe if for each Pi , the resources  that Pi can still request can be satisfied by currently available  resources + resources held by all the Pj , with j&lt;I.
    <ul>
      <li>If Pi resource needs are not immediately available, then Pi can wait until all Pj have finished.</li>
      <li>When Pj is finished, Pi can obtain needed resources,  execute, return allocated resources, and terminate.</li>
      <li>When Pi terminates, Pi+1 can obtain its needed resources,  and so on.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="basic-facts-1">Basic Facts</h2>

<ul>
  <li>If a system is in safe state =&gt; no deadlocks.</li>
  <li>If a system is in unsafe state =&gt; possibility of deadlock.</li>
  <li><strong>Avoidance</strong> =&gt; ensure that a system will never enter an unsafe  state.
    <ul>
      <li>í•­ìƒ safe ìƒíƒœì— ìˆë„ë¡</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="safe-unsafe-deadlock-state-spaces">Safe, unsafe, deadlock state spaces</h2>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20221002224304739.png" alt="image-20221002224304739" /></p>

<p>unsafe: í˜„ì¬ëŠ” deadlockì´ ì•„ë‹Œë° ì§„ì „ì´ ë˜ë©´ deadlockì´ ê±¸ë¦´ ê²ƒì´ ë†í›„í•´ ë³´ì´ëŠ” ìƒíƒœ</p>

<p>safe: ì•„ì˜ˆ deadlockì´ ê±¸ë¦¬ì§€ ì•ŠëŠ” ìƒíƒœ</p>

<p><br /></p>

<h2 id="safe-unsafe-state">Safe, unsafe state</h2>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20221002224329818.png" alt="image-20221002224329818" />s</p>

<p>P1ì€ 2ê°œë§Œ ìˆìœ¼ë©´ ë˜ëŠ”ë° í˜„ì¬ availableì´ 3ì´ë¯€ë¡œ P1ì´ ì „ë¶€ ìš”êµ¬í•´ë„ ë“¤ì–´ì¤„ ìˆ˜ ìˆì§€ë§Œ ë‚˜ë¨¸ì§€ëŠ” ë“¤ì–´ì¤„ ìˆ˜ ì—†ëŠ” ê²½ìš°ê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤.</p>

<p><br /></p>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20221002224344691.png" alt="image-20221002224344691" /></p>

<ul>
  <li>if P2 requests and is allocated 1 more tape drive</li>
  <li>Safe sequence exist? =&gt; <strong>no</strong>!, so the request should not be allowed.
    <ul>
      <li>deadlock avoidance!</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="avoidance-algorithms">Avoidance algorithms</h2>

<ul>
  <li>Single instance of a resource type
    <ul>
      <li>Use a resource-allocation graph</li>
    </ul>
  </li>
  <li>Multiple instances of a resource type
    <ul>
      <li>Use the bankerâ€™s algorithm</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="resource-allocation-graph-algorithm">Resource-Allocation Graph Algorithm</h2>

<ul>
  <li>If we have a resource-allocation system with only one instance of each  resource type,
    <ul>
      <li>Request and assignment edge</li>
      <li><strong>Claim edge</strong> Pi -&gt; Rj indicated that process PI may request  resource Rj at some time in the future; represented by a dashed  line.</li>
      <li>Claim edge converts to request edge when a process requests a  resource.</li>
      <li>When a resource is released by a process, assignment edge  reconverts to a claim edge.</li>
      <li>Resources must be claimed a priori in the system.
        <ul>
          <li>Before process Pi starts execution, all its claim edges must  already appear in resource-allocation graph</li>
          <li>Request (Pi -&gt; Rj ) can be granted only if converting the  request edge to an assignment edge does not result in the  formation of a cycle</li>
        </ul>
      </li>
      <li>O(n 2 ) where n is the # of processes</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="resource-allocation-graph-for-deadlock-avoidance">Resource-Allocation Graph For Deadlock Avoidance</h2>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20221002224551024.png" alt="image-20221002224551024" /></p>

<p>ì‹¤ì„ : assignment edge, request edge</p>

<p>ì ì„ : Request and assignment edge</p>

<p><br /></p>

<h2 id="unsafe-state-in-a-resource-allocation-graph">Unsafe State In A Resource-Allocation Graph</h2>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20221002224618692.png" alt="image-20221002224618692" /></p>

<p><br /></p>

<h2 id="resource-allocation-graph-algorithm-1">Resource-Allocation Graph Algorithm</h2>

<ul>
  <li>Suppose that process P<sub>i</sub> requests a resource R<sub>j</sub></li>
  <li>The request can be granted only if converting the request edge to an  assignment edge does not result in the formation of a cycle in the  resource allocation graph</li>
</ul>

<p><br /></p>

<h2 id="bankers-algorithm">Bankerâ€™s Algorithm</h2>

<ul>
  <li>Multiple instances.
    <ul>
      <li>multiple resource type - deadlock avoidance</li>
    </ul>
  </li>
  <li>Each process must a priori claim maximum use.</li>
  <li>When a process requests a resource it may have to wait.</li>
  <li>When a process gets all its resources it must return them in a  finite amount of time.</li>
  <li>O(m x n<sup>2</sup>)
    <ul>
      <li>n: í”„ë¡œì„¸ìŠ¤ ê°¯ìˆ˜</li>
      <li>m: message typeì˜ ê°¯ìˆ˜</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="data-structures-for-the-bankers-algorithm">Data Structures for the Bankerâ€™s Algorithm</h2>

<p>Let n = number of processes, and m = number of resources types</p>

<ul>
  <li>
    <p><strong>Available</strong>: Vector of length m. If available [j] = k, there are k instances of resource type Rj available.</p>
  </li>
  <li>
    <p><strong>Max</strong>: n x m matrix. If Max [i,j] = k, then process Pi may request  at most k instances of resource type Rj .</p>
  </li>
  <li>
    <p><strong>Allocation</strong>: n x m matrix. If Allocation[i,j] = k then Pi is currently  allocated k instances of Rj.</p>
  </li>
  <li>
    <p><strong>Need</strong>: n x m matrix. If Need[i,j] = k, then Pi may need k more  instances of Rj to complete its task.</p>

    <p>Need [i,j] = Max[i,j] â€“ Allocation [i,j].</p>
  </li>
</ul>

<p><br /></p>

<h2 id="safety-algorithm">Safety Algorithm</h2>

<ol>
  <li>
    <p>Let Work and Finish be vectors of length m and n, respectively.<br />
Initialize: Work := Available and Finish [i] = false for i = 1,2, â€¦, n.</p>
  </li>
  <li>
    <p>Find an i such that both:</p>

    <p>(a) Finish [i] = false</p>

    <p>(b) Needi â‰¤ Work</p>

    <p>If no such i exists, go to step 4.</p>
  </li>
  <li>
    <p>Work := Work + Allocation<sub>i</sub> 
Finish[i] := true 
go to step 2.</p>
  </li>
  <li>
    <p>If Finish [i] = true for all i, then the system is in a safe state</p>
  </li>
</ol>

<p><br /></p>

<h2 id="resource-request-algorithm-for-process-pi">Resource-Request Algorithm for Process Pi</h2>

<p>Request = request vector for process Pi . If Request<sub>i</sub> [j] = k then  process P<sub>i</sub> wants k instances of resource type R<sub>j</sub></p>

<ol>
  <li>
    <p>If Request<sub>i</sub> â‰¤ Need<sub>i</sub> go to step Otherwise, raise error condition,  since process has exceeded its maximum claim</p>
  </li>
  <li>
    <p>If Request<sub>i</sub> â‰¤ Available, go to step 3. Otherwise Pi must wait,  since resources are not available</p>
  </li>
  <li>
    <p>Pretend to allocate requested resources to Pi by modifying the  state as follows:</p>

    <p>â€‹				Available = Available â€“ Request;</p>

    <p>â€‹				Allocation<sub>i</sub> = Allocation<sub>i</sub> + Request<sub>i</sub> ;</p>

    <p>â€‹				Need<sub>i</sub> = Need<sub>i</sub> â€“ Request<sub>i</sub> ;</p>

    <ul>
      <li>If safe =&gt; the resources are allocated to P<sub>i</sub></li>
      <li>If unsafe =&gt; P<sub>i</sub> must wait, and the old resource-allocation state  is restored</li>
    </ul>
  </li>
</ol>

<p><br /></p>

<h2 id="example-of-bankers-algorithm---ì‹œí—˜">Example of Bankerâ€™s Algorithm - ì‹œí—˜</h2>

<ul>
  <li>5 processes P<sub>0</sub> through P<sub>4</sub> ;</li>
  <li>3 resource types
    <ul>
      <li>A (10 instances), B (5instances), and C (7 instances).</li>
    </ul>
  </li>
  <li>Snapshot at time T<sub>0</sub> :</li>
</ul>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20221002225224194.png" alt="image-20221002225224194" /></p>

<p>Need: ì•ìœ¼ë¡œ ë” ìš”ì²­í•  ê°€ëŠ¥ì„±ì´ ìˆëŠ” ìˆ«ì</p>

<p><br /></p>

<h2 id="example-cont">Example (Cont.)</h2>

<p>Is this safe?</p>

<ul>
  <li>The content of the matrix. Need is defined to be Max â€“ Allocation.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20221002225317137.png" alt="image-20221002225317137" /></p>

<ul>
  <li>The system is in a safe state since the sequence &lt; P<sub>1</sub> , P<sub>3</sub> , P<sub>4</sub> , P<sub>2</sub> , P<sub>0</sub>&gt;  satisfies safety criteria.
    <ul>
      <li>(3,3,2) -&gt; P<sub>1</sub> (5,3,2) -&gt; P<sub>3</sub> (7,4,3) -&gt; P<sub>4</sub> (7,4,5) -&gt; P<sub>2</sub> (10,4,7) -&gt; P<sub>0</sub> (10,5,7)</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="example-cont-p1-request-102---ì‹œí—˜">Example (Cont.): P1 request (1,0,2) - ì‹œí—˜</h2>

<ul>
  <li>Check that Request by P1 â‰¤ Available (that is, (1,0,2) â‰¤ (3,3,2) =&gt; true.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20221002225801105.png" alt="image-20221002225801105" /></p>

<ul>
  <li>Executing safety algorithm shows that sequence &lt; P<sub>1</sub> , P<sub>3</sub> , P<sub>4</sub> , P<sub>0</sub> , P<sub>2</sub>&gt; satisfies safety requirement.</li>
  <li><mark>ì¤‘ìš”</mark></li>
  <li>Can request for (3,3,0) by P<sub>4</sub> be granted?</li>
  <li>Can request for (0,2,0) by P<sub>0</sub> be granted?</li>
  <li>ìœ„ ì˜ˆì œì— ëŒ€í•´ì„œ safe sequenceë¥¼ ì°¾ì„ ìˆ˜ ìˆìœ¼ë©´ í•´ë‹¹ requestëŠ” ë°›ì•„ë“¤ì—¬ì§€ëŠ” ê²ƒì´ê³  ì°¾ì„ ìˆ˜ ì—†ë‹¤ë©´ ë°›ì•„ë“¤ì¼ ìˆ˜ ì—†ëŠ” ê²ƒì´ë‹¤.</li>
</ul>

<p>ì´ˆê¸°ì— 2,3,0ì˜ ìš©ëŸ‰ì— ë²—ì–´ë‚˜ì§€ ì•ŠëŠ” Needë¥¼ ê°€ì§„ ê²ƒì€ P1ë°–ì— ì—†ë‹¤.</p>

<p><br /></p>

<h2 id="deadlock-detection">Deadlock Detection</h2>

<ul>
  <li>Allow system to enter deadlock state</li>
  <li>Detection algorithm</li>
  <li>Recovery scheme</li>
</ul>

<p><br /></p>

<h2 id="single-instance-of-each-resource-type">Single Instance of Each Resource Type</h2>

<ul>
  <li>Maintain <strong>wait-for</strong> graph</li>
  <li>Nodes are processes. â€“ Pi -&gt; Pj if Pi is waiting for Pj .</li>
  <li>Periodically invoke an algorithm that searches for acycle in the graph.</li>
  <li>An algorithm to detect a cycle in a graph requires an order of n<sup>2</sup> operations, where n is the number of vertices in the graph.
    <ul>
      <li>O(n^2)</li>
      <li>x: n</li>
      <li>y: O(n^2)</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="resource-allocation-graph-and-wait-for-graph">Resource-Allocation Graph And Wait-for Graph</h2>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20221002230020650.png" alt="image-20221002230020650" /></p>

<p>resourceë¥¼ ì œê±°í•˜ë”ë¼ë„ ì‚¬ì‹¤ìƒ í”„ë¡œì„¸ìŠ¤ ë¼ë¦¬ ìš”êµ¬í•˜ëŠ” ê²ƒì´ê¸° ë•Œë¬¸ì— ì˜ë¯¸ ì „ë‹¬ì€ ëœë‹¤.</p>

<p><br /></p>

<h2 id="several-instances-of-a-resource-type">Several Instances of a Resource Type</h2>

<ul>
  <li><strong>Available</strong>: A vector of length m indicates the number of available  resources of each type</li>
  <li><strong>Allocation</strong>: An n x m matrix defines the number of resources of each  type currently allocated to each process</li>
  <li><strong>Request</strong>: An n x m matrix indicates the current request of each  process. If Request [i][j] = k, then process Pi is requesting k more  instances of resource type Rj .</li>
</ul>

<p><br /></p>

<h2 id="detection-algorithm">Detection Algorithm</h2>

<ol>
  <li>
    <p>Let Work and Finish be vectors of length m and n, respectively  Initialize:</p>

    <p>(a) Work = Available</p>

    <p>(b) For i = 1,2, â€¦, n, if Allocation<sub>i</sub> â‰  0, then<br />
		Finish[i] = false; otherwise, Finish[i] = true</p>
  </li>
  <li>
    <p>Find an index i such that both: 
(a) Finish[i] == false 
(b) Requesti â‰¤ Work</p>

    <p>If no such i exists, go to step 4</p>
  </li>
  <li>Work = Work + Allocation<sub>i</sub> 
Finish[i] = true 
go to step 2</li>
  <li>If Finish[i] == false, for some i, 1 â‰¤ i â‰¤ n, then the system is in deadlock state. Moreover, if Finish[i] == false, then Pi is deadlocked</li>
</ol>

<p>Algorithm requires an order of O(m x n<sup>2</sup>) operations to detect  whether the system is in deadlocked state</p>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/tmp45F0.jpg" alt="ê·¸ë¦¼ì…ë‹ˆë‹¤. ì›ë³¸ ê·¸ë¦¼ì˜ ì´ë¦„: CLP0000b6980004.bmp ì›ë³¸ ê·¸ë¦¼ì˜ í¬ê¸°: ê°€ë¡œ 909pixel, ì„¸ë¡œ 475pixel" /></p>

<p><br /></p>

<h2 id="example-of-detection-algorithm---ì‹œí—˜">Example of Detection Algorithm - ì‹œí—˜</h2>

<ul>
  <li>Five processes P<sub>0</sub> through P<sub>4</sub> ; three resource types  A (7 instances), B (2 instances), and C (6 instances).</li>
  <li>Snapshot at time T<sub>0</sub> :</li>
</ul>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20221002230446061.png" alt="image-20221002230446061" /></p>

<ul>
  <li>Request: í˜„ì¬ ìš”ì²­í•œ resource ê°¯ìˆ˜</li>
  <li>Need: ì•ìœ¼ë¡œ ìš”ì²­í•  ìˆ˜ ìˆëŠ” ìµœëŒ€ ê°¯ìˆ˜(ì´ ì •ë„ëŠ” ë°˜ë“œì‹œ í•„ìš”í•˜ë‹¤.)</li>
  <li>Sequence  &lt; P<sub>0</sub> , P<sub>2</sub> , P<sub>3</sub> , P<sub>1</sub> , P<sub>4</sub>&gt; will result in Finish[i] = true for all i.
    <ul>
      <li>sequenceê°€ ì¡´ì¬í•˜ë¯€ë¡œ ì´ ìƒí™©ì€ deadlockì´ ë°œìƒí•˜ì§€ ì•Šì€ ìƒí™©ì„!</li>
    </ul>
  </li>
  <li>bankerâ€™s alg:   <u>Allocation</u>  <u>Max</u>  <u>Available</u>  <u>Need</u></li>
</ul>

<p><br /></p>

<hr />

<h2 id="detectionê³¼-avoidanceì˜-ì°¨ì´ì ì„-ëª…í™•íˆ-ì•Œê¸°">detectionê³¼ avoidanceì˜ ì°¨ì´ì ì„ ëª…í™•íˆ ì•Œê¸°</h2>

<hr />

<h2 id="example-cont-1">Example (Cont.)</h2>

<ul>
  <li>ê·¼ë° P<sub>2</sub> requests an additional instance of type C.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/speardragon/save-image-repo/main/img/image-20221002230736013.png" alt="image-20221002230736013" /></p>

<ul>
  <li>State of system?
    <ul>
      <li>Can reclaim resources held by process P<sub>0 </sub>, but insufficient  resources to fulfill other processes; requests.</li>
      <li><strong>Deadlock exists</strong>, consisting of processes P<sub>1</sub> , P<sub>2</sub> , P<sub>3</sub> , and P<sub>4</sub></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="detection-algorithm-usage">Detection-Algorithm Usage</h2>

<ul>
  <li>When, and how often, to invoke depends on:
    <ul>
      <li>How often a deadlock is likely to occur?</li>
      <li>How many processes will need to be rolled back? (ì´ˆë°˜ ë‹¤ë¦¬ ì–˜ê¸°)
        <ul>
          <li>deadlock ì´ì „ ìƒíƒœë¡œ ëŒì•„ê°€ê¸° ìœ„í•´ì„œ ì–¼ë§ˆ ì „ìœ¼ë¡œ ëŒì•„ê°€ì•¼ í•˜ëŠ”ê°€?</li>
          <li>one for each disjoint cycle</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>If detection algorithm is invoked arbitrarily, there may be many cycles in the resource graph and so we would not be able to tell which of the many deadlocked processes â€œcausedâ€ the deadlock.
    <ul>
      <li>ìµœì´ˆë¡œ deadlockì„ ìœ ë°œí•œ processë¥¼ ì°¾ê¸° ì–´ë ¤ì›Œì§</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="recovery-from-deadlock-process-termination">Recovery from Deadlock: Process Termination</h2>

<ul>
  <li>Abort <strong>all</strong> deadlocked processes.</li>
  <li>Abort one process at a time until the deadlock cycle is eliminated.
    <ul>
      <li>í•œê°œì”© abort ì‹œì¼œë³´ëŠ” ë°©ì‹</li>
    </ul>
  </li>
  <li>In which order should we choose to abort?
    <ul>
      <li>Priority of the process.</li>
      <li>How long process has computed, and how much longer to completion.</li>
      <li>Resources the process has used.</li>
      <li>Resources process needs to complete.</li>
      <li>How many processes will need to be terminated.</li>
      <li>Is process interactive or batch?</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="recovery-from-deadlock-resource-preemption">Recovery from Deadlock: Resource Preemption</h2>

<ul>
  <li>Selecting a victim â€“ minimize cost.</li>
  <li>Rollback â€“ return to some safe state, restart process fro that  state.</li>
  <li>Starvation â€“ same process may always be picked as victim,  include number of rollback in cost factor.</li>
</ul>

<p><br /></p>

<h2 id="combined-approach-to-deadlock-handling">Combined Approach to Deadlock Handling</h2>

<ul>
  <li>
    <p><strong>Combine</strong> the three basic approaches</p>

    <ul>
      <li><strong>prevention</strong></li>
      <li><strong>avoidance</strong></li>
      <li><strong>detection</strong></li>
    </ul>

    <p>allowing the use of the optimal approach for each of resources in  the system.</p>
  </li>
  <li>
    <p>Partition resources into hierarchically ordered classes.</p>
  </li>
  <li>
    <p>Use most appropriate technique for handling deadlocks within  each class.</p>
  </li>
</ul>

:ET