I"'<p>이번 시간에는 트리 구조에 대해서 배워보도록 하겠습니다.</p>

<p><br /></p>

<h2 id="트리tree란">트리(Tree)란?</h2>

<p><img src="https://user-images.githubusercontent.com/79521972/154190733-666e345d-cebe-4b07-ad6a-7420993d6053.png" alt="image" style="zoom:67%;" /></p>

<p><img src="https://user-images.githubusercontent.com/79521972/155836817-8fb54dba-0a80-4ae1-bdba-227267e024cd.png" alt="image" style="zoom:50%;" /></p>

<p>트리란 노드들이 나무 가지처럼 연결된 비선형, 계층적 자료구조로 위 그림처럼 나무를 거꾸로 뒤집어 놓은 것과 같은 모양이어서 트리(tree)라는 이름을 가지게 된 자료구조이다.</p>

<p><br /></p>

<blockquote>
  <h3 id="개요">개요</h3>
</blockquote>

<p>트리는 한 노드가 여러 노드를 가르킬 수 있는 비선형적 자료구조를 일컫는 말이다.</p>

<p>앞서 배웠던 리스트(List), 스택(Stack), 큐(Queue)는 이전 데이터와 다음 데이터 간의 <span style="color:red">순서</span>가 존재했다.</p>

<p>트리도 물론 내부적으로 순서 정보를 가지도록 구현할 수도 있지만 트리 구조자체의 특성상 순서는 그렇게 중요하지 않다.</p>

<p>그래서 트리는 뒤에서 배우게 될 <strong>그래프</strong>의 일종이며 데이터 구조의 상하 개념 계층의 구조적 속성을 표현한다는 특징도 있다.</p>

<p><br /></p>

<p>다음 사진처럼 우리가 자주 쓰는 컴퓨터의 파일, 폴더의 계층 구조를 트리 구조라고 할 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/79521972/153970439-9db53747-cec3-439c-9525-ba08323e1d84.png" alt="image" /></p>

<p><br /></p>

<blockquote>
  <h3 id="관련-용어">관련 용어</h3>
</blockquote>

<p>트리의 구조를 그림을 통해 살펴보면서 이와 관련된 용어에 대해 정리를 해 보도록 하겠다.</p>

<p><img src="https://user-images.githubusercontent.com/79521972/154190733-666e345d-cebe-4b07-ad6a-7420993d6053.png" alt="image" /></p>

<ul>
  <li><strong>Node</strong>: 트리 구조에서 각 구성요소를 의미하는 단위
    <ul>
      <li>위 그림에서는 A~J까지를 모두 Node라고 할 수 있다.</li>
    </ul>
  </li>
  <li><strong>Root Node</strong>: 트리의 시작 노드로, 부모가 없는 최상위 노드
    <ul>
      <li>위 그림에서 A노드를 의미</li>
      <li>트리는 최대 1개의 Root Node를 가질 수 있다.</li>
    </ul>
  </li>
  <li>
    <p><strong>Edge</strong>: 노드와 노드 간의 연결을 하는 선</p>
  </li>
  <li><strong>Path</strong>: 특정 노드에서 노드까지의 경로 (순서)
    <ul>
      <li>한 번 지나쳤던 경로를 다시 지나는 것은 허락하지 않는다.</li>
    </ul>
  </li>
  <li><strong>Terminal Node(Leaf Node)</strong>: 자식 노드가 존재하지 않는, 즉 다시 말해 밑으로 또 다른 노드가 연결 되어있지 않는 노드
    <ul>
      <li>위 그림에서 H, I, J, F, G와 같은 노드를 말한다.</li>
    </ul>
  </li>
  <li><strong>Sub-Tree</strong>: 전체 큰 트리 구조 안의 작은 트리 구조
    <ul>
      <li>트리의 재귀적인 특성을 보여준다.</li>
    </ul>
  </li>
  <li><strong>Depth</strong>: 루트 노드로부터 얼마나 떨어져 있는 지를 뜻하는 단위
    <ul>
      <li>루트 노드의 바로 아래 노드는 depth 1로 잡는다.</li>
      <li>루트 노드가 기준이기 때문에 루트 노드는 depth 0이다.</li>
    </ul>
  </li>
  <li><strong>Level</strong>: 트리 구조에서 같은 위치, 즉 같은 depth를 가지는 노드들을 한 레벨로 나타내는 단위
    <ul>
      <li>Root Node가 기준이고 이 위치를 level 0으로 잡는다.</li>
      <li>루트 노드에서 어떤 노드까지의 간선 수이다.</li>
    </ul>
  </li>
  <li><strong>Height</strong>: 트리에서 가장 최고 레벨, 가장 깊은(deep) 층
    <ul>
      <li>어떤 노드에서 리프 노드까지 가장 긴 경로의 간선 수이다.</li>
    </ul>
  </li>
  <li><strong>Order</strong>: 부모 노드가 가질 수 있는 최대 자식의 수
    <ul>
      <li>예를 들어 order 4라고 하면 부모 노드는 최대 3명의 자식 노드를 가질 수 있는 것이다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p>또한 상위 노드를 <code class="language-plaintext highlighter-rouge">부모 노드</code>라 하며 부모 노드에서 파생된 노드를 <code class="language-plaintext highlighter-rouge">자식 노드</code>라 한다. 
이때, 같은 부모를 가진 노드를 <strong>형제 관계</strong>에 있다고 하며 자식 수를 차수로 나타내어 <strong>degree</strong>라고도 합니다.</p>

<p>예를 들어, Node D는 H, I 노드의 부모(Parent) 노드이며 degree 2의 차 수를 갖습니다.</p>

<p><br /></p>

<h3 id="트리-종류">트리 종류</h3>

<ul>
  <li>편향 트리(skew tree)
    <ul>
      <li>모든 노드들이 자식 노드를 하나씩만 가진 트리이다. 경사 트리라고도 불린다. 또한 아래 그림은 왼쪽 자식만 존재하기 때문에 left skew tree 이다.</li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/79521972/154193740-b3587214-789d-4b8f-91b6-8a6a5dbfe4eb.png" alt="image" style="zoom:67%;" /></p>

<p><br /></p>

<ul>
  <li>이진 트리(Binary Tree)
    <ul>
      <li>이후에 배울 내용으로 각 노드의 차수(자식 노드)가 2이하인 트리 구조이다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>이진 탐색 트리(Binary Search Tree, BST)
    <ul>
      <li>이 역시도 조금 있다가 배울 것이지만 굉장히 중요한 트리 구조로 BST라고도 하며 순서화된 이진 트리이다.</li>
      <li>노드의 왼쪽 자식은 부모의 값보다 항상 작은 값을 가져야 하고 노드의 오른쪽 자식은 부모의 값보다 항상 큰 값을 가져야 한다는 규칙이 존재한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>m원 탐색 트리(m-way Search Tree)
    <ul>
      <li>최대 m 개의 서브 트리를 갖는 탐색 트리이다.</li>
      <li>이진 탐색 트리의 확장된 형태로 높이를 줄이기 위해 사용한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>균형 트리(Balanced Tree, B-Tree)
    <ul>
      <li>m원 탐색 트리에서 높이 균형을 유지하는 트리이다.</li>
      <li>height-balanced m-way tree라고도 한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>이진 트리(Binary Tree)
    <ul>
      <li>이후에 배울 내용으로 각 노드의 차수(자식 노드)가 2이하인 트리 구조이다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="사용-예">사용 예</h3>

<hr />

<p><strong>계층적인 데이터 저장</strong></p>

<ul>
  <li>트리는 데이터를 계층 구조로 저장하기 때문에 파일 이나 폴더와 같이 계층구조를 갖는 곳에 사용된다.</li>
</ul>

<p><br /></p>

<p><strong>효율적인 검색 속도</strong></p>

<ul>
  <li>효율적인 삽입, 삭제, 검색을 위해 트리 구조를 사용한다.</li>
</ul>

<p><br /></p>

<p><strong>힙(Heap)</strong></p>

<ul>
  <li>이후에 배울 힙(heap)도 트리를 이용한 구조이다.</li>
  <li><strong>Heap 정렬</strong>은 우선순위 큐에서 사용하는 정렬로 <a href="https://speardragon.github.io/lecture/data%20structure%20and%20algorithms/algorithm/heap/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-Heap-&amp;-Priority-Queue(%ED%9E%99%EA%B3%BC-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90)/"><u><span style="color:blue">이곳</span></u></a>을 참조</li>
</ul>

<p><br /></p>

<p><strong>데이터 베이스 인덱싱</strong></p>

<ul>
  <li>데이터베이스 인덱싱을 구현하는데 트리를 사용한다.</li>
  <li>컴퓨터 공학적 지식에서 굉장히 중요한 일이다.</li>
  <li>예) B-Tree, B+Tree, AVL-Tree</li>
</ul>

<p><br /></p>

<p><strong>Trie</strong></p>

<ul>
  <li>사전(Dictionary)을 저장하는 데 사용되는 특별한 종류의 트리이다.</li>
  <li><strong>Trie</strong>에 대한 설명은 <a href="&quot;https://speardragon.github.io/lecture/data%20structure%20and%20algorithms/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-Trie(%ED%8A%B8%EB%9D%BC%EC%9D%B4)/&quot;"><u><span style="color:blue">이곳</span></u></a>을 참조</li>
</ul>

<p><br />
<br /></p>

<h2 id="이진-트리">이진 트리</h2>

<p>자 그럼 트리 구조 중에서 이진 트리에 대해 배워 보도록 하자.</p>

<p><br /></p>

<ul>
  <li>
    <p>각 노드가 최대 2개(0-2)의 자식 노드를 가지는 트리를 의미한다.</p>

    <p>최대 2개라는 것은 자식이 없을 수도(0개) 있고 1개만 있을 수도 있다는 것이다.</p>

    <ul>
      <li>자식 노드에는 왼쪽 자식 노드와 오른쪽 자식노드가 있으며 이 둘은 엄연히 다른 노드이다.</li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/79521972/154196285-fc0ccd70-7b94-410f-88fb-920baa5b34bc.png" alt="image" /></p>

<p><br /></p>

<h3 id="이진-트리-유형">이진 트리 유형</h3>

<dl>
  <dt><strong>정 이진 트리(full binary tree) (or 엄격한 (strict) 이진 트리</strong>)</dt>
  <dd>
    <p><span style="color:red">모든 노드가 2개의 자식을 가지는 트리</span>를 의미한다. (즉 자식 노드가 1개인 노드가 아예 없어야 만족한다.)</p>
  </dd>
</dl>

<ul>
  <li>
    <p>왼쪽 그림은 자식 노드가 하나인 노드가 존재하기 때문에 정 이진 트리가 될 수 없고 오른쪽 그림은 자식 노드가 하나인 노드가 존재하지 않기 때문에 정 이진 트리라고 할 수 있다.</p>
  </li>
  <li>
    <p><img src="https://user-images.githubusercontent.com/79521972/154196254-cceb69f0-ac2a-4dce-9ab2-2a6d60df217f.png" alt="image" /></p>
  </li>
</ul>

<p><br /></p>

<dl>
  <dt><strong>포화 이진 트리(Perfect Binary tree)</strong></dt>
  <dd>
    <p>모든 노드가 2개의 자식을 가지고 <span style="color:red">leaf 노드가 모두 같은 레벨인 트리</span>입니다.</p>
  </dd>
</dl>

<ul>
  <li>높이가 h일 때 노드 갯수는 2<sup>k+1</sup> - 1 개를 가진다는 특징있습니다.</li>
  <li>Leaf 노드의 갯수는 2<sup>h</sup> 개가 됩니다.</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/79521972/154196042-8f7a8dd2-f96c-4c4d-9211-545da52f2388.png" alt="image" /></p>

<p><br /></p>

<p><img src="https://user-images.githubusercontent.com/79521972/155840210-853f14bb-1ba4-41e1-a57b-055b7376e7f9.png" alt="image" /></p>

<p><br /></p>

<p><strong>완전 이진 트리(Complete Binary Tree)</strong></p>

<ul>
  <li>
    <p><span style="color:red">마지막 레벨을 제외하고</span> 모든 노드가 채워진 트리 구조이다.</p>
  </li>
  <li>
    <p>노드는 왼쪽에서 오른쪽으로 채워져야 한다.</p>
  </li>
</ul>

<p>위 두 조건이 만족할 때 완전 이진 트리라고 한다.</p>

<p>아래 그림에서 왼쪽과 오른쪽 그림 모두 완전 이진 트리라고 할 수 있다. 만약 <strong>왼쪽그림</strong>에서 level 1의 오른쪽 노드의 자식 노드가 오른쪽 자식 노드만 있었다면 완전 이진 트리가 될 수 없는 것이다.</p>

<p><img src="https://user-images.githubusercontent.com/79521972/154196589-a8dc629a-b5d3-4f0e-8b4b-550db26f6172.png" alt="image" /></p>

<p><br /></p>

<blockquote>
  <p>포화 이진 트리는 완전 이진 트리의 조건을 모두 만족하므로 <code class="language-plaintext highlighter-rouge">포화 이진 트리는 완전 이진 트리에 속한다</code>라고 볼 수 있고 이 명제의 역은 무조건 성립하는 것은 아니다.</p>
</blockquote>

<p>아래 그림은 완전 이진 트리가 될 수 없는 구조를 보여주고 있다.</p>

<p><img src="https://user-images.githubusercontent.com/79521972/154196894-d228f359-164b-4fbe-83cd-faefba3d19f2.png" alt="image" /></p>

<p><br /></p>

<h3 id="1차원-배열로-표현하는-이진-트리">1차원 배열로 표현하는 이진 트리</h3>

<p>그래서 트리는 선형 구조인 1차원 배열로도 표현이 가능하다.</p>

<p>아래의 그림을 살펴보자.</p>

<p><img src="https://user-images.githubusercontent.com/79521972/154196965-ddf199d8-af87-4a97-be56-de15a5661094.png" alt="image" /></p>

<p>왼쪽 트리는 level 순, 그리고 왼쪽에서 오른쪽 순서로 각 노드에 index를 붙여 표현 가능하다.</p>

<p>따라서 완전 이진 트리는 위의 그림과 같이 배열을 빈틈없이 모두 채울 수 있다.</p>

<p><br /></p>

<p>더 쉽게 이해 되도록 그림을 추가하였다.</p>

<p><img src="https://user-images.githubusercontent.com/79521972/154232616-916fe9f1-b8a4-4eda-94f0-e22646ca6a3e.png" alt="image" /></p>

<p>왼쪽 노드에서 오른쪽 노드 순서로 채워진다는 것이 중요한 사실이다.</p>

<p>이 사실로 인해 경사 이진 트리같은 경우 불필요한 공간이 낭비 될 수 있고 배열 크기 이상 노드를 추가할 수 없다는 점이 단점이다.</p>

<p><br /></p>

<p>반면 중간이 비어있는 트리의 경우(왼쪽 자식 노드는 있는데 오른쪽 자식 노드는 없는 경우) 배열 사이에 null 값이 들어간 구조로 나타나게 된다.</p>

<p><img src="https://user-images.githubusercontent.com/79521972/154197127-93fbfe92-c857-44a7-8bbd-4e4306df0dc4.png" alt="image" /></p>

<p><br /></p>

<p><mark>한 가지 신기한 점은 0번 index는 비우고 1번 index 부터 Root Node를 채운 점</mark>인데, 이렇게 함으로써 탐색을 쉽게 할 수 있기 때문이다.</p>

<p><br /></p>

<p><span style="color:red">다음 표는 이진 트리의 속성으로 인해 정해지는 배열의 인덱스이다 .</span></p>

<table>
  <thead>
    <tr>
      <th><mark>**루트 노드**</mark></th>
      <th><mark>**1**</mark></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>노드 i의 부모</td>
      <td>i/2</td>
    </tr>
    <tr>
      <td>노드 i의 왼쪽 자식</td>
      <td>i*2</td>
    </tr>
    <tr>
      <td>노드 i의 오른쪽 자식</td>
      <td>i*2 + 1</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th><mark>**루트 노드**</mark></th>
      <th><mark>**0**</mark></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>노드 i의 부모</td>
      <td>(i - 1) / 2</td>
    </tr>
    <tr>
      <td>노드 i의 왼쪽 자식</td>
      <td>i*2 + 1</td>
    </tr>
    <tr>
      <td>노드 i의 오른쪽 자식</td>
      <td>i*2 + 2</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p>위 표와 같은 연산을 통해 쉽게 특정 노드의 index를 찾을 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/79521972/154197127-93fbfe92-c857-44a7-8bbd-4e4306df0dc4.png" alt="image" /></p>

<ul>
  <li>6의 index를 찾도록 해 보자.
    <ul>
      <li>6은 노드 3의 왼쪽 자식 노드이다.</li>
      <li>표의 3번째 식을 통해 3 * 2 = 6 이다.</li>
      <li>따라서 6의 index는 6이다.</li>
    </ul>
  </li>
</ul>

<p>그래서 이진 트리를 구현함에 있어서 노드를 사용할 것인데 이때 left 노드와 right노드를 통해 구현할 것이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="o">;</span>
    <span class="nc">Node</span> <span class="n">left</span><span class="o">;</span>
    <span class="nc">Node</span> <span class="n">right</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/79521972/155841112-4b8b19d5-2d73-45a0-99fe-eb1636fe190a.png" alt="image" /></p>

<p>연결 리스트를 사용하면 배열 보다는 접근 속도는 느리지만(random access가 불가하기 때문) 삽입, 삭제가 쉽고 노드를 포인터로 연결하는 개념이기 때문에 노드 수에 제한이 없다.</p>

<p><strong>LinkedList(연결리스트)</strong>의 설명은 <a href="https://speardragon.github.io/lecture/data%20structure%20and%20algorithms/algorithm/linkedlist/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-LinkedList(%EC%97%B0%EA%B2%B0-%EB%A6%AC%EC%8A%A4%ED%8A%B8)/"><u><span style="color:blue">이곳</span></u></a>을 참조<br /></p>

<p><br /></p>

<h3 id="이진-트리의-응용">이진 트리의 응용</h3>

<ul>
  <li>힙(Heap)</li>
  <li>이진 탐색 트리 (Binary Search Tree)</li>
  <li>B-Tree</li>
  <li>
    <p>AVL 트리(Adelson-Velsky and Landis에서 따온 이름)</p>
  </li>
  <li>수식 트리(Expression Tree)</li>
  <li>허프만 코딩 트리(Huffman coding tree)</li>
  <li>우선 순위 큐(PQ)</li>
</ul>

<p>바로 다음 챕터에서 배울 힙(Heap) 구조라는 것도 트리의 한 가지이고, Binary Search Tree 줄여서 BST라고 하는 것도 이진 트리 구조이다.</p>

<p>또한 B-Tree라는 것은 이진 트리의 응용으로 데이터 베이스나 파일 시스템에 사용되는 중요한 구조이다.</p>

<p><br /></p>

<h3 id="이진-트리의-기본-연산">이진 트리의 기본 연산</h3>

<p>트리도 자료 구조이기 때문에 앞에서 배운 다른 구조들과 동일하게 다음과 같은 연산이 가능하다.</p>

<ul>
  <li>트리에 데이터 삽입하기</li>
  <li>데이터 삭제하기</li>
  <li>데이터 검색하기</li>
  <li><strong><u>트리 탐색</u></strong>하기</li>
</ul>

<p><br /></p>

<p>앞에서 배웠던 선형 자료구조들은 앞에서부터 데이터를 탐색하는 것이 그렇게 어렵지 않은 작업이었는데 <strong>연결 관계로 표현되는 구조</strong>는 그들의 특성상 탐색하는 방식이 <strong>선형 구조</strong>와 다를 수 밖에 없다.</p>

<p>그래서 <strong>트리 구조의 탐색</strong>은 더욱 신경써서 다뤄 보도록 하겠다.</p>

<p><br /></p>

<h2 id="트리-순회">트리 순회</h2>

<p>트리 순회에 대해서 자세히 알아보도록 하자.</p>

<ul>
  <li><strong>트리 순회란?</strong></li>
</ul>

<p>트리 구조에서 각 노드를 한 번씩 방문하는 과정이다.</p>

<p><br /></p>

<ul>
  <li><mark>**트리 순회 방법**</mark></li>
</ul>

<ol>
  <li><strong>전위 탐색</strong> (preorder)</li>
  <li><strong>중위 탐색</strong> (inorder)</li>
  <li><strong>후위 탐색</strong> (postorder)</li>
</ol>

<p><span style="color:red">노드 방문을 언제 하느냐에 따라</span> 순회 방법이 나뉘어진다.</p>

<p><br /></p>

<h4 id="1-preorder">1. Preorder</h4>

<ul>
  <li>
    <p>이름 그대로 노드를 가장 먼저 방문</p>
  </li>
  <li>
    <p>이후 <u>왼쪽</u> 서브 트리를 preoder (재귀 호출로).</p>
  </li>
  <li>
    <p><u>오른쪽</u> 서브 트리를 preorder.</p>
  </li>
</ul>

<p><br /></p>

<h4 id="2-inorder">2. inorder</h4>

<ul>
  <li>
    <p>먼저 <u>왼쪽</u> 서브 트리를 inorder.</p>
  </li>
  <li>
    <p>그 다음에 중간에(루트)노드를 방문.</p>
  </li>
  <li>
    <p><u>오른쪽</u> 서브 트리를 inorder(재귀적으로).</p>
  </li>
</ul>

<p><br /></p>

<h4 id="3-postorder">3. postorder</h4>

<ul>
  <li>먼저 <u>왼쪽</u> 서브 트리를 postorder.</li>
  <li>
    <p><u>오른쪽</u> 서브 트리를 postorder.</p>
  </li>
  <li>마지막으로 (루트)노드를 방문.</li>
</ul>

<p><br /></p>

<p>자 그럼 그림을 통해 전, 중, 후위 탐색이 어떻게 이루어 지는 지 보도록 하자.</p>

<p><img src="https://user-images.githubusercontent.com/79521972/154202666-9f5ecd7d-64c4-459f-b9ec-f6eec9708214.png" alt="image" /></p>

<p><br /></p>

<h3 id="preorder"><strong>preorder</strong></h3>

<p><img src="https://user-images.githubusercontent.com/79521972/154231791-cdb5a452-1c7a-44a4-b7b2-322c6eb55c03.gif" alt="1_VDapzFYMTK0dI5kHNnrZxg" /></p>

<p>먼저 <strong>전위탐색</strong>은 각 노드가 <strong>루트 노드 - 왼쪽 서브 트리 - 오른쪽 서브 트리</strong> 순으로 preorder를 진행한다.</p>

<p><br /></p>

<p>[<strong>순서</strong>]</p>

<ol>
  <li>노드 방문</li>
  <li>왼쪽 서브 트리 preorder</li>
  <li>오른쪽 서브 트리 preorder</li>
</ol>

<p>가 되며 이것이 모두 만족해야 해당 노드의 preorder가 끝난 것임을 유의하자.</p>

<p><br /></p>

<p><img src="https://user-images.githubusercontent.com/79521972/154202666-9f5ecd7d-64c4-459f-b9ec-f6eec9708214.png" alt="image" style="zoom:50%;" /></p>

<p>자 그럼 루트 노드인 A노드부터 시작해 보도록 하겠다.</p>

<ul>
  <li>A 노드 방문(A 노드 1번 만족 = A<sub>1</sub>)
    <ul>
      <li>왼쪽 서브 트리인 B 노드 방문(B<sub>1</sub>, A<sub>12</sub>)
        <ul>
          <li>왼쪽 서브 트리인 D 노드 방문 (D<sub>1</sub>, B<sub>12</sub>)</li>
          <li>D노드는 왼쪽 노드가 없고 오른쪽 노드만 있기 때문에 H 노드 방문(H<sub>1</sub>)</li>
          <li>H노드는 leaf노드이기 때문에 preorder가 완료되었고 이에 따라 D노드도 자동적으로 preorder가 완료. (H<sub>123</sub>, D<sub>123</sub>)</li>
          <li>D 노드는 B노드의 왼쪽 노드이었기에 그 다음은 B의 3번 조건을 만족 시키기 위해 오른쪽 노드인 E노드에 방문합니다.(B<sub>123</sub>, E<sub>1</sub>)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>이러한 방식으로 모든 노드가 preorder가 될 때까지 반복한다.</p>

<p>Path(노드 방문 순서)를 나타내면 다음과 같다.</p>

<blockquote>
  <p>A - B - D - H - E- C- F - I - J - G - K</p>
</blockquote>

<p><br /></p>

<h3 id="inorder"><strong>inorder</strong></h3>

<p><img src="https://user-images.githubusercontent.com/79521972/154232049-46edb3b8-ac61-47ac-be99-5871dfa75ca5.gif" alt="1_hbJOJjABy16aJzbhfPfpQQ" /></p>

<p><strong>중위 탐색</strong>은 각 노드가 왼쪽 <strong>서브 트리 - 루트 노드  - 오른쪽 서브 트리</strong> 순으로 preorder를 진행한다.</p>

<p><br /></p>

<p><strong>[순서]</strong></p>

<ol>
  <li>왼쪽 서브 트리 inorder</li>
  <li>노드 방문</li>
  <li>오른쪽 서브 트리 inorder</li>
</ol>

<p>가 되며 이것이 모두 만족해야 <strong>해당 노드의 inorder</strong>가 끝난 것임을 유의하자.</p>

<p><img src="https://user-images.githubusercontent.com/79521972/154202666-9f5ecd7d-64c4-459f-b9ec-f6eec9708214.png" alt="image" style="zoom:50%;" /></p>

<p>중위 탐색에서는 루트 노드인 A에서 시작했을 때 1번 조건이 노드 방문이 아니므로 왼쪽 서브 트리를 탐색하면서 시작한다.</p>

<ul>
  <li>A 노드는 그래서 처음에 방문을 한것이 아니라 중간에 방문한 노드가 되는 것이다.</li>
</ul>

<p>이 과정으로 inoder를 진행하며 거쳐가는 노드 path(노드 방문 순서)는 다음과 같다.</p>

<blockquote>
  <p>D- H - B- E - A - I - F - J - C - G - K</p>
</blockquote>

<p><br /></p>

<h3 id="postorder"><strong>postorder</strong></h3>

<p><img src="https://user-images.githubusercontent.com/79521972/154232093-ccfe92c0-17f7-4776-952c-4fab8d08ad3f.gif" alt="1_NqVMFGOioTCqJdkJYUOCkw" /></p>

<p><strong>중위 탐색</strong>은 각 노드가 <strong>왼쪽 서브 트리 - 루트 노드  - 오른쪽 서브 트리</strong> 순으로 preorder를 진행한다.</p>

<p><br /></p>

<p><strong>[순서]</strong></p>

<ol>
  <li>왼쪽 서브 트리 postorder</li>
  <li>오른쪽 서브 트리 postorder</li>
  <li>노드 방문</li>
</ol>

<p>가 되며 이것이 모두 만족해야 <strong>해당 노드의 postorder</strong>가 끝난 것임을 유의하자.</p>

<p><img src="https://user-images.githubusercontent.com/79521972/154202666-9f5ecd7d-64c4-459f-b9ec-f6eec9708214.png" alt="image" style="zoom:50%;" /></p>

<p><strong>후위 탐색</strong>에서는 루트 노드인 A에서 시작했을 때 1번 조건이 왼쪽 서브 트리를 탐색하면서 시작한다.</p>

<ul>
  <li>왼쪽과 오른쪽 서브 트리를 모두 탐색한 후에 노드를 방문할 수 있기 때문에 A 노드가 가장 마지막에 방문한 것이 된다.</li>
</ul>

<p><br /></p>

<p>그 후 이 과정으로 재귀 호출로 계속 반복하며 postorder를 진행하며 거쳐가는 노드 path(노드 방문 순서)는 다음과 같습니다.</p>

<blockquote>
  <p>H- D - E - B - I - J - F - K - G - C - A</p>
</blockquote>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th>pre-order</th>
      <th>In-order</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>A - B - D - H - E- C- F - I - J - G - K</td>
      <td>D- H - B- E - A - I - F - J - C - G - K</td>
    </tr>
    <tr>
      <td><strong>Post-order</strong></td>
      <td> </td>
    </tr>
    <tr>
      <td>H- D - E - B - I - J - F - K - G - C - A</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p><strong>전위 탐색</strong>에서는 루트 노드를 가장 먼저 방문하였고</p>

<p><strong>중위 탐색</strong>에서는 루트 노드를 중간에(루트 노드의 왼쪽 노드가 방문된 후에)방문하였으며</p>

<p><strong>후위 탐색</strong>에서는 루트 노드를 가장 마지막에(루트 노드의 왼쪽, 오른쪽 노드를 모두 방문된 후에) 방문한 것을 알 수 있다.</p>

<p><br /></p>

<h2 id="이진-탐색-트리binary-search-tree---bst">이진 탐색 트리(Binary Search Tree - BST)</h2>

<p>이번엔 이진 탐색 트리에 대해서 배워 보겠다.</p>

<p><br /></p>

<p>트리 구조 자체적으로는 데이터의 특성에 아무런 제약이 걸리지 않는다. 그렇기 때문에 트리 노드를 하나하나씩 방문하여 탐색해야 하기 때문에 시간 복잡도 측면에서 큰 이점을 얻지 못한다.</p>

<p>이에 대하여 더 <strong>빠른 탐색을 위해서</strong> <span style="color:red">데이터 특성에 제약을 줌으로써</span> Binary Search와 마찬가지로 O(log<sub>2</sub>n)의 시간 복잡도를 가지며 나온 것이 이진 탐색 트리라고 할 수 있다.</p>

<p><br /></p>

<blockquote>
  <p>특징</p>
</blockquote>

<ul>
  <li>이진 탐색 트리도 <strong>이진 트리</strong> 구조로 이루어져 있다.</li>
  <li>노드의 왼쪽 서브 트리에는 루트 노드보다 작은 값이 들어있다.</li>
  <li>노드의 오른쪽 서브 트리에는 루트 노드보다 큰 값이 들어있다.</li>
  <li>서브 트리 또한 <strong>이진 탐색 트리 구조</strong>이다.</li>
  <li>중복된 값은 일체 없다.</li>
</ul>

<p><br /></p>

<h4 id="이진-탐색-트리-방식">이진 탐색 트리 방식</h4>

<p>그림을 통해 이진 탐색 트리가 어떤 방식으로 이루어져 있는지를 보도록 하겠다.</p>

<p><img src="https://user-images.githubusercontent.com/79521972/154207993-3fe6d49f-b017-4efd-b595-9cd6f8539ca1.png" alt="image" /></p>

<p>루트 노드인 5를 기준으로 왼쪽 서브 트리에는 5보다 작은 수로 구성 되어있고 오른쪽 서브 트리에는 5보다 큰 수로 구성 되어 있다.</p>

<p><img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20220216152418963.png" alt="image-20220216152418963" /></p>

<p>연속적으로 하위의 서브 트리를 봐도 각 루트 노드를 기준으로 오른쪽과 왼쪽이 작은 수와 큰 수로 나뉘어져 있는 것을 볼 수있다.</p>

<p><br /></p>

<p>[<strong>트리의 최솟값</strong>]</p>

<p><img src="https://user-images.githubusercontent.com/79521972/154208294-0109e47f-756f-4c16-9b6b-53b97744578f.png" alt="image" /></p>

<p>트리의 최솟값은 위의 그림처럼 트리 구조의 가장 왼쪽 끝에 위치한 노드가 최솟값이 된다. 만약 1의 왼쪽 자식 노드가 있다면 그 노드가 최솟값이 될 것이다.</p>

<p><br /></p>

<p>[<strong>트리의 최댓값</strong>]</p>

<p><img src="https://user-images.githubusercontent.com/79521972/154208534-83d3967e-5d10-4d75-9661-7bfb589f99e0.png" alt="image" /></p>

<p>반대로 트리의 최댓값은 위의 그림처럼 트리 구조의 가장 오른쪽 끝에 위치한 노드가 최댓값이 된다. 만약 9의 오른쪽 자식 노드가 있다면 그 노드가 최댓값이 된다.</p>

<p><br /></p>

<p>다음과 같은 <strong>이진 탐색 트리</strong>가 있다고 하자.</p>

<p><img src="https://user-images.githubusercontent.com/79521972/154208639-2a2aa982-6769-4556-9dec-a832e924504f.png" alt="image" /></p>

<p>이 트리 구조를 중위 탐색 하면 오름 차순으로 숫자를 가져올 수 있게 된다.</p>

<ul>
  <li>중위 탐색
    <ul>
      <li>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8 -&gt; 9</li>
    </ul>
  </li>
</ul>

<p><span style="color:red">이진 탐색 트리는 중위 탐색을 하면 오름 차순으로 인덱스를 탐색 할 수 있다.</span></p>

<p><br /></p>

<h3 id="이진-탐색-트리-생성">이진 탐색 트리 생성</h3>

<p>이진 탐색 트리를 생성할 때는 데이터의 크기를 비교해 가면서 노드를 추가해 간다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[50, 15, 62, 80, 7, 54, 11]
</code></pre></div></div>

<p>위의 데이터들로 이진 탐색 트리를 생성해 보도록 하겠다.</p>

<p><br /></p>

<ol>
  <li>50이 배열의 첫 번째 데이터이기 때문에 루트 노드로 트리에 삽입한다.</li>
  <li>다음 요소를 계속해서 읽고 해당 노드가 루트 노드 요소보다 작으면 왼쪽 하위 트리의 루트로 삽입한다.</li>
  <li>그렇지 않으면 오른쪽 하위 트리의 오른쪽 루트로 삽입한다.</li>
</ol>

<p><img src="https://user-images.githubusercontent.com/79521972/155843151-16af9f43-0368-464a-a5ac-6f63b68248c5.png" alt="image" /></p>

<p><br /></p>

<h3 id="이진-탐색-트리의-삽입">이진 탐색 트리의 삽입</h3>

<p>기존의 이진 탐색 트리에서 삽입하는 과정은 굉장히 중요하다.</p>

<p><br /></p>

<p>삽입 과정의 특징을 먼저 살펴 보겠다.</p>

<ul>
  <li>
    <p>가장 먼저 해당 데이터가 자신이 들어갈 위치를 찾아야 한다.</p>
  </li>
  <li>그리고 중복된 데이터는 삽입하지 않는다.</li>
  <li>
    <p>그렇기 때문에 <span style="color:blue">만약 숫자를 삽입하려 하는데 탐색을 하다가 같은 숫자가 있는 것을 발견</span>하면 삽입하지 않고 그대로 종료하게 된다.</p>
  </li>
  <li>데이터를 삽입하거나 삭제하더라도 그 특성이 유지되어야 한다.</li>
  <li>추가된 노드는 트리의 <mark>leaf 노드</mark>에 삽입을 한다.
    <ul>
      <li>자식 노드가 3개를 넘으면 안 되기 때문이다.(이진 트리의 특성)</li>
    </ul>
  </li>
</ul>

<p><br />
[<strong>과정</strong>]</p>

<p><img src="https://user-images.githubusercontent.com/79521972/154210855-e3f2c8cd-b2be-4b87-b033-7add75184515.png" alt="image" /></p>

<p>만약, 1이라는 데이터를 위 이진 탐색 트리에 삽입하고자 한다.</p>

<ol>
  <li>그럼 먼저 <strong>루트 노드</strong>인 8과 비교한다.</li>
  <li>1은 루트노드 8보다 더 더 작기 때문에 왼쪽 노드인 5와 다시 비교한다.</li>
  <li>5와 비교했을 때도 더 작기 때문에 또 왼쪽 노드로 이동하여 2와 비교한다.</li>
  <li>2와 비교했을 때도 더 작은데 왼쪽 노드가 비어있기 때문에 2의 왼쪽 노드에 삽입한다.</li>
</ol>

<p><br /></p>

<h2 id="이진-탐색-트리의-삭제">이진 탐색 트리의 삭제</h2>

<p><strong>삽입</strong>은 leaf노드의 위치만 잘 찾아서 삽입만 하면 되는 <strong>삭제</strong>는 좀 더 까다롭습니다. leaf노드만 삭제 되는 것이 아니라 <span style="color:red">트리 구조 중간에 위치한 노드도 삭제 될 수 있기 때문이다.</span></p>

<p>삭제 과정을 한 번 보겠다.</p>

<p><br /></p>

<p>[<strong>과정</strong>]</p>

<ul>
  <li>삭제 데이터의 위치를 찾는다.</li>
  <li><strong>이때 데이터의 위치는 세 가지로 나뉘어 진다.</strong>
    <ol>
      <li>삭제할 데이터가 leaf인 경우</li>
      <li>한 개의 자식 노드를 가질 경우</li>
      <li>두 개의 자식 노드를 가질 경우</li>
    </ol>
  </li>
</ul>

<p><br /></p>

<p>이 세 가지 경우를 아래와 같은 이진 탐색 트리에 대해서 생각해 보겠다.</p>

<p><img src="https://user-images.githubusercontent.com/79521972/154208639-2a2aa982-6769-4556-9dec-a832e924504f.png" alt="image" /></p>

<p><br /></p>

<p><strong>1. 삭제 할 데이터가 leaf 노드인 경우</strong></p>

<p><img src="https://user-images.githubusercontent.com/79521972/154214616-1a7dc68f-b7e5-4972-a53a-508ac54c711b.png" alt="image" /></p>

<p>삭제 할 데이터가 leaf인 경우 그림 상에서 2와 8을 의미한다. 이때는 null을 부모 노드에게 리턴시켜서 자신을 가리키던 자식 포인터를 null로 바꿔주면 된다.</p>

<p><br /></p>

<p><strong>2. 한 개의 자식 노드를 가질 경우</strong></p>

<p><img src="https://user-images.githubusercontent.com/79521972/154215065-28b38d37-c484-4155-b6e8-6045aeef7fab.png" alt="image" /></p>

<p>삭제하고자 하는 노드가 한 개의 자식 노드를 가질 경우에 <strong>해당 노드의 자식 노드를</strong> 1의 부모 노드였던 3의 자식 노드를 가리키던 포인터와 연결 시켜 주면 된다.</p>

<p>그러면 다음과 같이 되어 이진 탐색 트리의 속성이 유지 되는 것이다.</p>

<p><img src="https://user-images.githubusercontent.com/79521972/154215226-3e96aa6b-7361-4506-8973-660df0003d08.png" alt="image" /></p>

<p><br /></p>

<p><strong>3. 두 개의 자식 노드를 가질 경우</strong></p>

<p>삭제 하고자 하는 노드가 두 개의 자식 노드를 가질 경우에는 두 가지 옵션이 존재한다.</p>

<ul>
  <li><strong>왼쪽 서브 트리의 최댓값과 교체</strong></li>
  <li><strong>오른쪽 서브 트리의 최솟값과 교체</strong></li>
</ul>

<p><img src="https://user-images.githubusercontent.com/79521972/154215357-9aa0601a-5c51-4843-bb49-fb892f19944b.png" alt="image" /></p>

<p>나는 두 번째 방법인 오른쪽 서브 트리의 최솟값과 교체하는 방법을 사용해 보겠다.</p>

<p>이때 오른쪽 서브 트리의 최솟값, 즉 inorder 순회에서 다음 노드는 successor 노드라고 한다.</p>

<p>과정은 다음과 같다.</p>

<ol>
  <li>삭제할 노드를 찾는다.</li>
  <li>삭제할 노드의 successor 노드를 찾는다.</li>
  <li>삭제할 노드와 successor 노드의 값을 바꾼다.</li>
  <li>successor 노드를 삭제한다.(연결을 끊는다.)</li>
</ol>

<p><br /></p>

<p>7의 오른쪽 서브 트리에는 8과 9가 존재하여 이 중 최솟값인 8(successor 노드)과 삭제하고자 하는 노드 7을 교체한다.</p>

<p>이런 과정을 통해 8이라는 데이터가 중복되기 때문에 leaf 노드의 8을 지워주어야 한다.</p>

<p><img src="https://user-images.githubusercontent.com/79521972/154215658-86d9de1e-f57a-427f-946a-060b2946431d.png" alt="image" /></p>

<p>이때 지워야 하는 8은 leaf 노드이기 때문에 위 1번 방법으로 null을 대입하는 것으로 삭제를 해 주면 다음과 같이 된다.</p>

<p><img src="https://user-images.githubusercontent.com/79521972/154215712-df11bee3-edf3-4eae-9651-db6b85cd3fc7.png" alt="image" /></p>

<p>결과적으로 이진 탐색 트리의 구조가 망가지지도 않았고 원하는 노드만 삭제를 했기 때문에 깔끔하게 진행이 된 것을 확인 할 수 있다.</p>

<p><br /></p>

<h3 id="이진-탐색-트리의-검색search">이진 탐색 트리의 검색(Search)</h3>

<p>이진 탐색 트리에서 특정 요소의 위치를 찾는 연산이다.</p>

<p>과정은 다음과 같다.</p>

<p><br /></p>

<p>[<strong>과정</strong>]</p>

<ol>
  <li>루트에서부터 출발한다.</li>
  <li>검색 값을 루트 노드와 비교한다.
    <ul>
      <li>루트보다 작으면 왼쪽에 대해 재귀 호출을 진행하고, 크다면 오른쪽에 대해 재귀 호출을 진행한다.</li>
    </ul>
  </li>
  <li>일치하는 값을 찾을 때까지 절차를 반복한다.</li>
  <li>만약 검색 값이 없다면 null을 반환한다.</li>
</ol>

<p><br /></p>

<h2 id="이진-탐색-트리-구현">이진 탐색 트리 구현</h2>

<p>이제는 그럼 코드로 구현해 보겠습니다. 이진 탐색 트리는 오히려 코드로 보면서 이해하는 것이 더 도움이 되실 수 있습니다.</p>

<p><br /></p>

<p><strong>ITree 인터페이스</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">tree</span><span class="o">;</span>
 
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ITree</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="no">T</span> <span class="n">val</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">delete</span><span class="o">(</span><span class="no">T</span> <span class="n">val</span><span class="o">);</span>
    <span class="kt">boolean</span> <span class="nf">contains</span><span class="o">(</span><span class="no">T</span> <span class="n">val</span><span class="o">);</span>
    <span class="kt">int</span> <span class="nf">size</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>트리 구조에 필요한 기능(메소드)들을 inteface를 선언하여 포로토타입으로 선언하였다.</p>

<p>이외의 preorder, inorder, postorder와 같은 탐색 기능은 따로 트리 클래스에서 구현해 보도록 하겠다</p>

<p><br /></p>

<p><strong>BinarySearchTree 클래스</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">tree</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BinarySearchTree</span><span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="kd">implements</span> <span class="nc">ITree</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="노드-클래스"><strong>노드 클래스</strong></h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="no">T</span> <span class="n">data</span><span class="o">;</span>
    <span class="nc">Node</span> <span class="n">left</span><span class="o">;</span>
    <span class="nc">Node</span> <span class="n">right</span><span class="o">;</span>
    
    <span class="nc">Node</span><span class="o">(</span><span class="no">T</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;}</span>
    
    <span class="nc">Node</span><span class="o">(</span><span class="no">T</span> <span class="n">data</span><span class="o">,</span> <span class="nc">Node</span> <span class="n">left</span><span class="o">,</span> <span class="nc">Node</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>노드를 사용하여 구현할 것이기 때문에 노드 클래스를 만들어 준다.</p>

<p><br /></p>

<h3 id="멤버-변수"><strong>멤버 변수</strong></h3>

<p>루트 노드를 가리키는 변수와 트리 구조 크기를 나타내는 변수 size를 선언합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="nc">Node</span> <span class="n">root</span><span class="o">;</span>
<span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="생성자"><strong>생성자</strong></h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nf">BinarySearchTree</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">root</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">size</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>루트 노드가 시작이기 때문에 값에 null을 대입하고 size는 0으로 초기화 시킨다.</p>

<p><br /></p>

<h3 id="min-minnode"><strong>min(), minNode()</strong></h3>

<p>트리의 데이터 중 가장 작은 값(최솟값)을 찾아주는 메소드이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="no">T</span> <span class="nf">min</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">minNode</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">root</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="no">T</span> <span class="nf">minNode</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="no">T</span> <span class="n">minData</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">data</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">minData</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">data</span><span class="o">;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>가장 왼쪽</strong>의 값을 가져 오는 것이기 때문에 루트 노드부터 시작하여 left 자식 노드를 계속 타고 들어가서 가장 마지막 값을 반환하면 된다.</p>

<p><strong>minNode()</strong> :</p>

<ul>
  <li>
    <p>minData에는 최솟값을 계속해서 업데이트를 해 줄 것이다.</p>
  </li>
  <li>
    <p>반복문을 통해 left노드가 null일 때까지 반복해 준다.</p>
  </li>
  <li>반복문 안의 내용은 현재의 노드를 left노드로 계속해서 초기화 하면서 타고 들어가며, 각 노드의 데이터를 minData변수에 업데이트를 해 준다.</li>
  <li>그러면 반복문이 끝났을 때는 더 이상 타고 들어갈 곳이 없는 가장 왼쪽 노드의 값을 가져오게 된다.</li>
</ul>

<p><strong>min()</strong> :</p>

<p>루트 노드부터 시작하여 타고 내려가기 때문에 인자로 루트 노드를 넘겨 minNode()의 리턴값을 리턴합니다.</p>

<p><br /></p>

<p><strong>max(), minMax()</strong></p>

<p>max() 메소드는 위의 min() 메소드와 다르게 최댓값을 찾는 것이므로 방향만 바꾸어 <strong>가장 오른쪽</strong> 값을 가져오도록 합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="no">T</span> <span class="nf">max</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">maxNode</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">root</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="no">T</span> <span class="nf">maxNode</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="no">T</span> <span class="n">maxData</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">data</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">maxData</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">data</span><span class="o">;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">node</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="전위-탐색---preorder"><strong>전위 탐색 - preOrder()</strong></h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">preOrder</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">preorderTree</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">root</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">preorderTree</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">visited</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">visited</span><span class="o">;</span>
    
    <span class="n">visited</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">data</span><span class="o">);</span>
    <span class="n">preorderTree</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">visited</span><span class="o">);</span>
    <span class="n">preorderTree</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">visited</span><span class="o">);</span>
    
    <span class="k">return</span> <span class="n">visited</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<ol>
  <li>노드 방문</li>
  <li>왼쪽 서브 트리 preorder</li>
  <li>오른쪽 서브 트리 preorder</li>
</ol>

<p>전위 탐색의 순서에 맞게 코드를 구현했다.</p>

<p><strong>preorderTree</strong>()</p>

<p>visited는 노드가 방문 했음을 기록하는 리스트 객체이고 이곳에 방문한 node의 데이터를 반복적으로 넣어준다.</p>

<p>그리고 왼쪽 서브트리에 대해 반복적으로 재귀 호출을 진행하고 완료되면 오른쪽 서브 트리에 대해 반복적으로 재귀 호출이 진행되도록 한다.</p>

<p>그리고 재귀가 종료조건 없이 계속해서 호출되면 오류가 발생할 수 있기 때문에 if문으로 node가 null일 때, 즉 leaf 노드의 다음 노드를 방문 시 return 하여 종료하도록 메소드 가장 앞에 작성해 주었다.</p>

<ul>
  <li>재귀 호출을 통해 left에 대한 탐색이 모두 종료가 되어야 return visited를 하면서 종료가 되고 자연스럽게 다음 코드인 right에 대한 재귀 탐색이 이루어 지게 되는 구조이다.</li>
</ul>

<p><br /></p>

<h3 id="중위-탐색---inorder"><strong>중위 탐색 - inOrder()</strong></h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">inOrder</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">inorderTree</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">root</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">inoderTree</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">visited</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">visited</span><span class="o">;</span>
    
    <span class="n">inorderTree</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">visted</span><span class="o">);</span>
    <span class="n">visited</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">data</span><span class="o">);</span>
    <span class="n">inorderTree</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">visited</span><span class="o">);</span>
    
    <span class="k">return</span> <span class="n">visited</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<ol>
  <li>왼쪽 서브 트리 preorder</li>
  <li>노드 방문</li>
  <li>오른쪽 서브 트리 preorder</li>
</ol>

<p>중위 탐색의 순서에 맞게 코드를 구현했다.</p>

<p>코드 방식은 앞서 설명한 전위 탐색과 순서만 다르지 굉장히 비슷하기 때문에 자세한 설명은 생략하도록 하겠다</p>

<p><br /></p>

<h3 id="후위-탐색---postorder"><strong>후위 탐색 - postOrder()</strong></h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">postOrder</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">postorderTree</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">root</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">postoderTree</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">visited</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">visited</span><span class="o">;</span>
    
    <span class="n">postorderTree</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">visted</span><span class="o">);</span>
    <span class="n">postorderTree</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">visited</span><span class="o">);</span>
    <span class="n">visited</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">data</span><span class="o">);</span>
    
    <span class="k">return</span> <span class="n">visited</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<ol>
  <li>왼쪽 서브 트리 preorder</li>
  <li>오른쪽 서브 트리 preorder</li>
  <li>노드 방문</li>
</ol>

<p>중위 탐색의 순서에 맞게 코드를 구현했다.</p>

<p>코드 방식은 앞서 설명한 전위 탐색, 중위 탐색과 순서만 다르지 굉장히 비슷하기 때문에 자세한 설명은 생략하도록 하겠다.</p>

<p><br /></p>

<h3 id="containst-val"><strong>contains(T val)</strong></h3>

<p>인자로 넘겨준 값이 존재하는 지를 판단하는 메소드로 이 역시도 재귀 호출을 통해 구현해 보도록 하겠다. 그러기 위해서 별도로 containsNode() 메소드를 만들어 준다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">contains</span><span class="o">(</span><span class="no">T</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">containsNode</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">root</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">containsNode</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">,</span> <span class="no">T</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    
    <span class="c1">// a.compareTo(b)</span>
    <span class="c1">// a &lt; b : -1</span>
    <span class="c1">// a == b : 0</span>
    <span class="c1">// a &gt; b : 1</span>
    
    <span class="c1">//val과 node.data가 같은 경우</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">val</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">data</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span> 
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="c1">//val이 node.data보다 작은 경우</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">val</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">data</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">containsNode</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">//val이 node.data보다 큰 경우</span>
    <span class="k">return</span> <span class="nf">containsNode</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
    
<span class="o">}</span>
</code></pre></div></div>

<p><strong>containsNode()</strong></p>

<p>루트 노드부터 인자로 받아온 값과 비교하는 연산(compareTo() )을 진행하여 일치하면 true를 리턴하고 그렇지 않은 경우는 다음과 같이 진행한다.</p>

<ul>
  <li>찾고자 하는 값이 현재 노드의 데이터보다 <u>작은</u> 경우 left노드를 타고 들어가 재귀적으로 계속해서 판단을 진행한다.</li>
  <li>찾고자 하는 값이 현재 노드의 데이터 보다 <u>큰</u> 경우 right노드를 타고 들어가 재귀적으로 계속해서 판단을 진행한다.</li>
</ul>

<p>if문으로 종료조건을 달아준다.</p>

<ul>
  <li>현재 노드가 null인 경우(leaf 노드에서 다음 노드를 타고 들어간 경우)에 종료 된다.</li>
</ul>

<p><br /></p>

<h3 id="insertt-val-insertnodenode-node-t-val"><strong>Insert(T val), insertNode(Node node, T val)</strong></h3>

<p>삽입 같은 경우도 마찬가지로 값 비교를 통해 작다면 left노드에 크다면 right노드에 삽입을 진행해 주어야 한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="no">T</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">root</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">insertNode</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">root</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">size</span><span class="o">++;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="nc">Node</span> <span class="nf">insertNode</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">,</span> <span class="no">T</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Node</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">//leaf노드를 찾는 과정</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">val</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">data</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">node</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">insertNode</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">val</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">data</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">node</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">insertNode</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>
    <p>첫 시작을 root 노드로 한다.</p>
  </li>
  <li>
    <p>node가 null인 경우 데이터를 삽입할 수 있는 경우 이기 때문에 val 데이터를 가진 노드를 생성(노드 객체 생성)하여 리턴하면 insert()메소드에서 이를 다시 루트 노드로 대입하여 이 노드를 가지고 insertNode() 메소드가 호출된다.</p>
  </li>
  <li>
    <p>만약 자식 노드가 있다면 값을 비교하여 삽입하고자 하는 값이 루트 값보다 더 작다면 left노드를 계속 타고 들어가 삽입하려는 시도를 재귀적으로 한다.</p>
  </li>
  <li>
    <p>마찬가지로 삽입하고자 하는 값이 루트 값보다 더 크다면 right 노드를 타고들어가 삽입하려는 것을 재귀 호출을 이용하여 구현한다.</p>
  </li>
</ul>

<p><br /></p>

<h3 id="deletet-val"><strong>delete(T val)</strong></h3>

<p>삭제 연산도 재귀 호출로 진행된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">delete</span><span class="o">(</span><span class="no">T</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">deleteNode</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">root</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="nc">Node</span> <span class="nf">deleteNode</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">,</span> <span class="no">T</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    
    <span class="c1">//삭제할 노드를 찾으러 들어가는 과정</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">val</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">data</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">node</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">deleteNode</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">val</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">data</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">node</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">deleteNode</span><span class="o">(</span><span class="n">node</span> <span class="n">right</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">// val == node.data : 삭제할 노드를 찾은 경우    </span>
        <span class="k">this</span><span class="o">.</span><span class="na">size</span><span class="o">--;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//삭제할 노드가 leaf 노드인 경우</span>
            <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="na">left</span>
          <span class="o">}</span>
        
        <span class="n">node</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">minNode</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span><span class="c1">//successor 노드 찾기</span>
        <span class="n">node</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">deleteNode</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">node</span><span class="o">.</span><span class="na">data</span><span class="o">);</span><span class="c1">//successor노드와 삭제 노드를 바꾸고 삭제</span>
      <span class="o">}</span>
    <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>삭제하려고 하는 값의 위치를 찾기 위해서 해당 값과 현재 노드의 데이터 값을 재귀 연산으로 비교하여 위치를 찾아 나간다.</p>

<ul>
  <li>만약 비교를 했을 때 삭제하고자 하는 값이 루트 값보다 더 작으면 왼쪽 서브 트리 어딘가에 값이 위치해 있을 것이다.
    <ul>
      <li>그래서 left 노드를 타고 들어가며 재귀 호출을 해 준다.</li>
    </ul>
  </li>
  <li>반대 경우에는(삭제하고자 하는 값이 루트 값보다 더 크면)
    <ul>
      <li>right노드를 타고 들어가는 재귀 호출을 한다.</li>
    </ul>
  </li>
  <li>만약 위치를 찾은 경우(val == node.data)에는
    <ul>
      <li>삭제이므로 size를 1 감소 시킨다.</li>
      <li>삭제 하고자 하는 노드가 <strong><u>leaf 노드</u></strong>인 경우 <strong>null을 리턴</strong>시켜 부모 노드의 자식 노드와 연결 시킨다.
        <ul>
          <li>left노드가 null이면 해당 노드는 이진 트리 특성에 따라 leaf 노드일 것이기 때문에 해당 노드의 right 노드, 즉 null을 반환한다.</li>
        </ul>
      </li>
      <li>삭제 하고자 하는 노드의 자식 노드가 <strong><u>1개</u></strong>인 경우
        <ul>
          <li>left 노드는 비어있지 않으면서 right 노드가 비어있는 경우는 자식 노드가 1개인 경우이므로</li>
          <li>해당 노드의 자식 노드를 리턴해 준다.</li>
        </ul>
      </li>
      <li>삭제 하고자 하는 노드의 자식 노드가 <u>**2개**</u>인 경우
        <ul>
          <li>오른쪽 서브 트리의 <mark>최솟값</mark>을 삭제할 노드의 위치로 가져오는 방법 사용한다.</li>
          <li>가져온 위치의 노드는 삭제 되어야 하므로 deleteNode메소드를 재귀 호출하여 노드의 오른쪽 서브 트리에 값을 가져온 노드 데이터가 삭제된 서브 트리가 위치 하도록 해 준다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>마지막으로 삭제한 node를 반환하여 함수를 종료한다.</li>
</ul>

<p><br /></p>

<h3 id="size"><strong>size()</strong></h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">size</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>size함수는 간단하게 변수를 리턴하면서 마무리 해 준다.</p>

<p><br /></p>

<h2 id="관련된-문제">관련된 문제</h2>

<p><a href="https://www.acmicpc.net/problem/9934">백준 9934번 완전 이진 트리</a></p>

<p><br /></p>

<h3 id="자료구조-시간-복잡도-비교">자료구조 시간 복잡도 비교</h3>

<ul>
  <li>평균 시간 복잡도(Average)</li>
</ul>

<table>
  <thead>
    <tr>
      <th>자료구조</th>
      <th>Access</th>
      <th>Search</th>
      <th>Insertion</th>
      <th>Deletion</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Array</td>
      <td>O(1)</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>Stack</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>Queue</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>Singly Linked List</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>Doubly Linked List</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>Hash Table</td>
      <td>O(1)</td>
      <td>O(1)</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>Binary Search Tree</td>
      <td>O(log<sub>2</sub>n)</td>
      <td>O(log<sub>2</sub>n)</td>
      <td>O(log<sub>2</sub>n)</td>
      <td>O(log<sub>2</sub>n)</td>
    </tr>
    <tr>
      <td>AVL Tree</td>
      <td>O(log<sub>2</sub>n)</td>
      <td>O(log<sub>2</sub>n)</td>
      <td>O(log<sub>2</sub>n)</td>
      <td>O(log<sub>2</sub>n)</td>
    </tr>
    <tr>
      <td>B Tree</td>
      <td>O(log<sub>2</sub>n)</td>
      <td>O(log<sub>2</sub>n)</td>
      <td>O(log<sub>2</sub>n)</td>
      <td>O(log<sub>2</sub>n)</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>최악의 경우 시간 복잡도(Worst)</li>
</ul>

<table>
  <thead>
    <tr>
      <th>자료구조</th>
      <th>Access</th>
      <th>Search</th>
      <th>Insertion</th>
      <th>Deletion</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Array</td>
      <td>O(1)</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>Stack</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>Queue</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>Singly Linked List</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>Doubly Linked List</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>Hash Table</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>Binary Search Tree</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>AVL Tree</td>
      <td>O(log<sub>2</sub>n)</td>
      <td>O(log<sub>2</sub>n)</td>
      <td>O(log<sub>2</sub>n)</td>
      <td>O(log<sub>2</sub>n)</td>
    </tr>
    <tr>
      <td>Binary Tree</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>B Tree</td>
      <td>O(log<sub>2</sub>n)</td>
      <td>O(log<sub>2</sub>n)</td>
      <td>O(log<sub>2</sub>n)</td>
      <td>O(log<sub>2</sub>n)</td>
    </tr>
  </tbody>
</table>

:ET