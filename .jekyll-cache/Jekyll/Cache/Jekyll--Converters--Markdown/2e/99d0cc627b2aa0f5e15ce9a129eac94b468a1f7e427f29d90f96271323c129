I"d<p><br /></p>

<h2 id="dynamic-programming---다이나믹-프로그래밍">Dynamic Programming - 다이나믹 프로그래밍</h2>

<p>이번 시간에는 다이나믹 프로그래밍(동적 계획법 ,DP)에 대해서 배워 보도록 하자.</p>

<h4 id="1-다이나믹-프로그래밍이란">1. 다이나믹 프로그래밍이란?</h4>

<p><code class="language-plaintext highlighter-rouge">Dynamic Programming 줄여서 DP(또는 동적 계획법)</code>는 <span style="color:red">특정 범위까지의 값을 구하기 위해서 그것과 다른 범위까지의 값을 이용하여 효율적으로 값을 구하는 알고리즘 설계 기법</span>이다.</p>

<p>위의 말을 쉽게 말해 아래와 같이 말할 수 있다.</p>

<ul>
  <li>하나의 큰 문제를 여러 개의 작은 문제로 나누어 그 결과를 저장하여 다시 큰 문제를 해결할 때 사용하는 것</li>
  <li>큰 문제를 작은 문제로 쪼개서 그 답을 저장해 두었다가 <strong>재활용</strong>(기억하며 풀기)</li>
</ul>

<h4 id="2-왜-dp를-쓰는-것일까">2. 왜 DP를 쓰는 것일까?</h4>

<p>사실 일반적인 재귀(Naive Recursion)방식 또한 DP와 매우 유사하다고 볼 수 있는데, 차이점은 일반적인 재귀를 단순히 사용할 때 작은 문제 하나에서 작은 문제가 있다면 이를 계속 반복하여야 하기 때문에 규모가 큰 계산에서 굉장히 비효율적이게 될 수 있다는 것이다.</p>

<p>DP의 예시인 피보나치 수열을 보면서 왜 DP를 사용하는 지 이해해 보도록하자.</p>

<p>피보나치 수열은 재귀함수로도 풀 수 있는 유명한 문제이다.</p>

<p>피보나치 수열은 다음과 같다.</p>

<ul>
  <li>1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144 …</li>
</ul>

<p>이를 구하고 싶을 때 재귀로 함수를 구성하는 방법은 매우 단순하다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return f(n) = f(n-1) + f(n-2)
</code></pre></div></div>

<p>그런데 f(n-1), f(n-2)에서 각 함수를 1번씩 호출하면 동일한 값을 2번씩 구하게 되고 이로 인해 100번째 피보나치 수를 구하기 위해 호출되는 함수의 횟수는 기하급수 적으로 증가한다.(약 <strong>7해번 이상 함수 호출</strong>, 아마 죽을 때까지 계산을 해야할 수도 있다.)</p>

<p>코딩 문제는 그 문제 자체만 풀면 되긴 하지만 만약 입력 조건의 범위가 매우 큰 경우에 위와 같이 굉장히 오랜 시간 걸릴 수 있다는 것이다.</p>

<p><br /></p>

<p><img src="https://user-images.githubusercontent.com/79521972/154906849-34a2419d-f80d-4235-970f-f7d4a33f064b.png" alt="image" /></p>

<p>그러나 한 번 구한 작은 문제의 결과 값을 저장해두고 재사용 한다면 어떨까? 앞에서 계산된 값을 다시 반복할 필요가 없이 약 200회 내에 계산이 가능해진다.</p>

<p>즉, 매우 효율적으로 문제를 해결할 수 있게 된다. 시간복잡도를 기준으로 아래와 같이 개선이 가능하다.
시간 복잡도 측면에서<strong>O(n^2) → O(f(n)) 로 개선</strong>이 가능해 진다. (다항식 수준으로, 문제에 따라 다름.)</p>

<p><br /></p>

<h5 id="분할-정복divide-and-conquer과의-차이점">분할 정복(Divide and Conquer)과의 차이점?</h5>

<p>사실 다이나믹 프로그래밍의 정의를 보면 분할 정복과 크게 다를 것이 없어보인다.</p>

<p>분할 정복과 다이나믹 프로그래밍 모두 주어진 문제를 작은 문제로 작게 쪼개서 서브 문제들을 해결하고 이를 토대로 큰 문제를 해결한다는 점에서 비슷하게 보일 수 있다.</p>

<p>둘의 차이점은</p>

<ul>
  <li>분할 정복의 경우, 분할된 하위 문제가 동일하게 <strong>중복이 일어나지 않는 경우</strong>에 쓰이고</li>
  <li>다이나믹 프로그래밍의 경우, 분할된 하위 문제가 동일하게 <strong>중복이 일어나는 경우</strong>에 쓰이는 것이다.</li>
</ul>

<p><br /></p>

<h4 id="3-dp의-사용-조건">3. DP의 사용 조건</h4>

<p>앞서 배운 그리디 알고리즘과 마찬가지로 DP도 사용 조건이 있다.</p>

<ol>
  <li><span style="color: red">Overlapping Subproblems(겹치는 부분 문제)</span></li>
  <li><span style="color: red">Optimal Substructure(최적 부분 구조)</span></li>
</ol>

<p><br /></p>

<p><mark>①Overlapping subproblems</mark></p>

<p>DP는 기본적으로 문제를 나누고 그 문제의 결과 값을 재활용해서 전체 답을 구한다. 그래서 <strong>동일한 작은 문제들이 반복해서 나타나는 경우</strong>에 사용이 가능하다.</p>

<p>즉, DP는 부분 문제의 결과를 저장해서 다시 계산하지 않을 수 있어야 하는데, 해당 부분 문제(subproblems)가 반복적으로 나타나지 않는다면 재사용이 불가능하니 부분 문제가 중복되지 않는 경우에는 사용할 수 없다.</p>

<p><br /></p>

<p><mark>②Optimal Substructure(최적 부분 구조)</mark></p>

<p>부분 문제(subproblems)의 최적 결과 값을 사용해 전체 문제의 최적 결과를 낼 수 있는 경우를 의미한다. 그래서 특정 문제의 <span style="color:blue">정답은 문제의 크기와는 상관없이 항상 동일하다.</span></p>

<p><br /></p>

<h4 id="dp를-사용하는-경우">DP를 사용하는 경우</h4>

<p>DP는 특정한 경우에 사용하는 알고리즘이 아니라 하나의 방법론이기 때문에 다양한 문제해결에 쓰일 수 있다. 그렇기 때문에 DP를 적용할 수 있는 문제인지 아닌지를 알아내는 것부터 가 시작이다.</p>

<p><br /></p>

<p>과정은 다음과 같이 진행된다.</p>

<ol>
  <li>DP로 풀 수 있는 문제인지 확인</li>
  <li>문제의 변수 파악</li>
  <li>변수 간 <strong>관계식(점화식)</strong> 만들기</li>
  <li><mark>메모하기(Memoization or tabulation)</mark></li>
  <li>기저 상태 파악하기</li>
  <li>구현하기</li>
</ol>

<p><br /></p>

<ol>
  <li><strong>DP로 풀 수 있는 문제인지 확인</strong></li>
</ol>

<p>이 부분부터 상당히 어려운데 DP의 조건에 의해 현재 직면한 문제가 작은 문제들로 쪼개질 수 있는 지, 즉 하나의 함수로 표현될 수 있는지를 판단해야 한다.</p>

<p>즉, 위의 조건들을 면밀히 하나씩 만족되는 지 체크를 해 본다.</p>

<p>일반적으로 특정 데이터 내 최대화나 최소화 계산을 한다거나 특정 조건 내에서 데이터를 세야하는 경우, 확률 등의 계산을 할 때 DP를 통해 푸는 경우가 많이 있다.</p>

<p><br /></p>

<ol>
  <li><strong>문제의 변수 파악</strong></li>
</ol>

<p>DP는 현재 변수에 따라서 나오는 결과 값을 찾고 그것을 전달함으로써 재사용하는 과정을 거친다. 즉, 문제 내에서 변수의 개수를 알아내야 한다는 것, 이것을 영어로 <code class="language-plaintext highlighter-rouge">"state"</code>를 결정한다고 한다.</p>

<p>예를 들어, <strong>피보나치 수열</strong>에서는 n번째 숫자를 구하는 것이므로 ‘n’이 변수가 된다. 그 변수가 얼마이냐에 따라 결과값이 다르지만 그 결과를 재사용하는 것이다.</p>

<p>또한, 문자열 간의 차이를 구할 때는 문자열의 길이, Edit 거리 등 2가지 변수를 사용한다.</p>

<p><br /></p>

<ol>
  <li><strong>변수 간 관계식 만들기</strong></li>
</ol>

<p>변수들에 의해 결과 값이 달라지지만 동일한 변수값인 경우 결과는 동일하다. 또한 우리는 그 결과값을 그대로 이용할 것이므로 그 관계식을 만들어낼 수 있어야 한다.</p>

<p>그러한 식을 <strong>점화식</strong>이라고 부르며 그를 통해 우리면 짧은 코드 내에서 반복/재귀를 통해 문제가 자동으로 해결되도록 구축할 수 있게 된다.</p>

<p>예를 들어 피보나치 수열에서는 f(n) = f(n-1) + f(n-2) 였다. 이는 변수의 개수, 문제의 상황마다 모두 다를 수 있다.</p>

<p><br /></p>

<ol>
  <li><strong>메모하기</strong></li>
</ol>

<p>영어로 Memoization. 사실 이 DP의 핵심은 Memoization이라고 봐도 무방하다.</p>

<p>변수 간 관계식까지 정상적으로 생성되었다면 <strong>변수의 값에 따른 결과를 저장</strong>해야 한다. 이것을 메모한다고 하여 <strong>Memoization</strong>이라고 부르는 것이다.</p>

<p>변수 값에 따른 결과를 저장할 배열 등을 미리 만들고 그 결과를 나올 때마다 배열 내에 저장하고 그 저장된 값을 재사용하는 방식으로 문제를 해결해 나간다.</p>

<p>이 결과 값을 저장할 때는 보통 배열을 쓰며 변수의 개수에 따라 배열의 차원이 1~3차원 등 다양할 수 있다.</p>

<p><br /></p>

<ol>
  <li><strong>기저 상태 파악하기</strong></li>
</ol>

<p>여기까지 진행했으면, <strong>가장 작은 문제</strong>의 상태를 알아야 한다. 보통 몇 가지 예시를 직접 손으로 테스트하여 구성하는 경우가 많다.</p>

<p><strong>피보나치 수열</strong>을 예시로 들면, f(0) = 0, f(1) = 1과 같은 방식이다. 이후 두 가지 숫자를 더해가며 값을 구하지만 가장 작은 문제는 저 2개로 볼 수 있다.</p>

<p>우리가 초등학교, 중학교 시절 점화식을 배울 때 0이나 1의 값을 넣어보고 이를 토대로 식을 이끌어 내는 것과 마찬가지라고 볼 수 있다.</p>

<p>해당 기저 문제에 대해 파악 후 미리 <strong>배열</strong> 등에 저장해두면 된다. 이 경우, 피보나치 수열은 매우 간단했지만 문제에 따라 좀 복잡할 수 있다.</p>

<p><br /></p>

<ol>
  <li><strong>구현하기</strong></li>
</ol>

<p>위와 같이 DP를 사용할 수 있는 판이 깔렸다면 DP를 사용해야 한다. 이 때 사용하는 방법에는 두 가지 방식으로 나뉘는데 다음과 같다.</p>

<p>1) Bottom-Up (Tabulation 방식) - 반복문 사용
2) Top-Down (Memoization 방식) - 재귀(Naive Recursion) 사용</p>

<p><br /></p>

<h3 id="memoization">Memoization?</h3>

<p>Memorization(메모리제이션)과 엄연히 다른 개념이므로 착각하면 안된다.</p>

<p><code class="language-plaintext highlighter-rouge">메모이제이션</code>은 앞서 말했듯 동적 프로그래밍에서는 작은 문제들이 반복되고 이 작은 문제들의 결과값이 항상 같은데, 이러한 점을 이용해서 한 번 계산한 작은 문제를 저장해 놓은 후 이것을 다시 사용하는 것을 말한다.</p>

<p><br /></p>

<p>피보나치를 한 번 예로 들어보겠다. 피보나치는 1, 1, 2, 3, 5, 8, …의 수를 이루게 된다. 즉, <code class="language-plaintext highlighter-rouge">다음 수열 = 이전 수열 + 두 단계 전 수열의 합</code>이라는 점화식을 가지는 순열이다.</p>

<p>이를 재귀 함수로 풀면 훨씬 간단하게 풀 수 있지만 n의 크기가 증가함에 따라 호출해야 하는 함수의 수가 기하급수적으로 증가하기 때문에 적당한 수의 범위 내에서만 가능하다는 단점이 있다.</p>

<p><br /></p>

<p>또한 이렇게 피보나치를 재귀함수로 풀게될 경우, 했던 작업을 계속해서 또 하게 되는 문제가 발생하는데, 이럴 때 이번 시간에 배운 <code class="language-plaintext highlighter-rouge">동적 계획법의 조건 두 가지</code>를 상기해보면 이를 동적 계획법(Dynamic Programmin)으로 풀 수 있음을 알 수 있다.</p>

<p><br /></p>

<ol>
  <li>작은 문제들이 반복 된다.
    <ul>
      <li>f(5)를 구하기 위해서는 f(4), f(3)이 필요하고, 다시 f(4)를 구하기 위해서는 f(3), f(2)가 필요하고…. 이런 식으로 작은 문제들이 반복되는 구조이다.</li>
    </ul>
  </li>
  <li>같은 문제는 구할 때 마다 정답이 같다.
    <ul>
      <li>피보나치 수열은 첫 번째와 두 번째 수열은 각각 1로 고정되어있다. 또한 세 번째 수열의 결과는 언제나 2이며, 4 번째 수열 역시 2,3 번째 수열을 통해 구하므로 언제나 항상 같은 값이 나옴을 알 수 있다.</li>
    </ul>
  </li>
</ol>

<p><br /></p>

<h3 id="구현-방법"><span style="color:red">구현 방법</span></h3>

<p><u>**Bottom-Up**</u>(작은 문제부터 차근차근)</p>

<p>아래에서 부터 계산을 수행하면서 이를 통해 누적된 것으로 전체 큰 문제를 해결해 나가는 방법이다.</p>

<p>Memoization을 위해 dp 배열을 만들고 이를 1차원이라고 가정하자. dp[0]이 기저 상태이고 dp[n]을 구하여 한다고 했을 때 Bottom-Up은 <strong>dp[0]</strong>부터 시작해서 반복문을 통해 점화식으로 결과를 도출하여 dp[n]까지 그 값을 이동시켜 재활용하는 방식이다.</p>

<p>이는 <strong>Tabulation</strong>이라고도 하는데, 그 이유는 반복을 통해 dp[0]부터 하나씩 채우는 과정을 “table-filling”이라고 하며, 이 table에 저장된 값에 직접 접근하여 재활용하기 때문에 Tabulation이라고 한다.</p>

<p><br /></p>

<p><strong><u>Top-Down</u></strong></p>

<p>위와 다르게 dp[0]에서 시작하는 대신 dp[n]을 찾아내기 위해서 위에서부터 바로 호출을 진행한다.</p>

<p>dp[0] 상태까지 내려간 다음 해당 결과 값을 재귀를 통해 이동시켜 재활용하는 방식이다.</p>

<p>이것은 또한 이미이전에 계산을 완료한 경우에는 단순히 메모리에 저장되어 있던 내역을 꺼내서 활용하면 되기 때문에 <strong>가장 최근 상태 값을 메모</strong>해 두었다고 해서 <strong>Memoization</strong>이라고 부르는 것이다.</p>

<p><br /></p>

<h3 id="코드로-구현java">코드로 구현(Java)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">packge</span> <span class="n">com</span><span class="o">.</span><span class="na">test</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Fibonacci</span><span class="o">{</span>
    <span class="c1">// DP 를 사용 시 작은 문제의 결과값을 저장하는 배열</span>
    <span class="c1">// Top-down, Bottom-up 별개로 생성하였음(큰 의미는 없음)</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">topDown_memo</span><span class="o">;</span> 
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">bottomup_table</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">30</span><span class="o">;</span>
        <span class="n">topDown_memo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="n">bottomup_table</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        
        <span class="kt">long</span> <span class="n">startTime</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">naiveRecursion</span><span class="o">(</span><span class="n">n</span><span class="o">));</span>
        <span class="kt">long</span> <span class="n">endTime</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"일반 재귀 소요 시간 : "</span> <span class="o">+</span> <span class="o">(</span><span class="n">endTime</span> <span class="o">-</span> <span class="n">startTime</span><span class="o">));</span>
        
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
        
        <span class="n">startTime</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">topDown</span><span class="o">(</span><span class="n">n</span><span class="o">));</span>
        <span class="n">endTime</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Top-Down DP 소요 시간 : "</span> <span class="o">+</span> <span class="o">(</span><span class="n">endTime</span> <span class="o">-</span> <span class="n">startTime</span><span class="o">));</span>
        
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
        
        <span class="n">startTime</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">bottomUp</span><span class="o">(</span><span class="n">n</span><span class="o">));</span>
        <span class="n">endTime</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Bottom-Up DP 소요 시간 : "</span> <span class="o">+</span> <span class="o">(</span><span class="n">endTime</span> <span class="o">-</span> <span class="n">startTime</span><span class="o">));</span>
    <span class="o">}</span>
    
    <span class="c1">// 단순 재귀를 통해 Fibonacci를 구하는 경우</span>
    <span class="c1">// 동일한 계산을 반복하여 비효율적으로 처리가 수행됨</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">naiveRecursion</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nf">naiveRecursion</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">naiveRecursion</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">// DP Top-Down을 사용해 Fibonacci를 구하는 경우</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">topDown</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
        <span class="c1">// 기저 상태 도달 시, 0, 1로 초기화</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="k">return</span> <span class="n">topDown_memo</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        
        <span class="c1">// 메모에 계산된 값이 있으면 바로 반환!</span>
        <span class="k">if</span><span class="o">(</span><span class="n">topDown_memo</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">topDown_memo</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        
        <span class="c1">// 재귀를 사용하고 있음!</span>
        <span class="n">topDown_memo</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">=</span> <span class="n">topDown</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">topDown</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">);</span>
        
        <span class="k">return</span> <span class="n">topDown_memo</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="o">}</span>
    
    <span class="c1">// DP Bottom-Up을 사용해 Fibonacci를 구하는 경우</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">bottomUp</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
        <span class="c1">// 기저 상태의 경우 사전에 미리 저장</span>
        <span class="n">bottomup_table</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">bottomup_table</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        
        <span class="c1">// 반복문을 사용하고 있음!</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="c1">// Table을 채워나감!</span>
            <span class="n">bottomup_table</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">bottomup_table</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">bottomup_table</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">bottomup_table</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>결과</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>832040
일반 재귀 소요 시간 : 9

832040
Top-Down DP 소요 시간 : 0

832040
Bottom-Up DP 소요 시간 : 0
</code></pre></div></div>

<p><br /></p>

<h3 id="top-down-vs-bottom-up">Top down vs. Bottom up</h3>

<p><code class="language-plaintext highlighter-rouge">Top-down</code>의 경우 소스의 가독성이 증가된다는 장점이 있는 반면 작성하기 어렵다는 단점이 있다.</p>

<p><code class="language-plaintext highlighter-rouge">Bottom-up</code>의 경우 문제를 풀기는 쉽지만 소스의 가독성은 어렵다는 단점이 있습니다.</p>

<p><br />
따라서 둘 중 어느 것도 더 좋지도 나쁘지도 않고 때에 따라서 더 편한 방법으로 푸는 것이 가장 좋다!</p>

<p><br /></p>

<h3 id="동적-프로그래밍동적-계획법-tip">동적 프로그래밍(동적 계획법) Tip!</h3>

<p>동적 프로그래밍으로 푸는 문제는 먼저 이 문제의 작은 문제를 구조화 하는 것부터 시작해야 한다. dp[0], dp[1], dp[2], dp[3] 이렇게 작은 문제를 점차 해결 하다 보면 규칙을 발견할 수 있을 것이고 dp[4]를 해결할 즈음에는 이전에 구해놓은 작은 문제들을 이용하여 점화식을 도출해 낸다.</p>

<p><br /></p>

:ET