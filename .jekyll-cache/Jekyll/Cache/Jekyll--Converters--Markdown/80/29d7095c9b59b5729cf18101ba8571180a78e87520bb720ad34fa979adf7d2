I"ۉ<p><br /></p>

<p>리액트 네이티브에 대한 소개와 개발 환경 세팅을 진행하면서 발생한 문제점들에 대해서 서술하였다.</p>

<h1 id="chapter-1-리액트-네이티브-개발-환경-갖추기">Chapter 1. 리액트 네이티브 개발 환경 갖추기</h1>

<h2 id="리액트-네이티브-소개">리액트 네이티브 소개</h2>

<p>리액트 네이티브를 소개하기 전에 리액트 프레임워크에 대해서 먼저 알아보자면 <strong>리액트</strong>는 2013년에 페이스북에서 발표한 오픈소스 자바스크립트 프레임워크이다.</p>

<p><strong>네이티브(native)</strong>라는 단어는 <code class="language-plaintext highlighter-rouge">운영체제를 만들 때 사용한 프로그래밍 언어와 똑같은 언어로 만든</code>이라는 의미를 내포하고 있는 것으로 네이티브 앱은 모바일 운영체제(안드로이드-자바, IOS-objectC, 오브젝티브-C)로 만든 앱을 의미한다.</p>

<p>네이티브 앱은 실행 속도가 빠른 장점이 있지만 습득해야 할 지식이 많고 똑같은 기능을 안드로이드와 ios용으로 따로 만들어야 한다.</p>

<p>그래서 <strong>크로스플랫폼</strong>이라는 것이 등장하였는데 이는 하나의 소스 코드로 여러 운영체제에서 동작하는 앱을 개발 할 수 있다. 네이티브 앱보다는 조금 느리지만 개발 시간 비용을 크게 단축, 절약할 수 있다는 장점도 있다.</p>

<p><br /></p>

<p>우리가 앞으로 사용할 리액트 네이티브는 <strong>브릿지 방식</strong>으로 동작한다. 또한 웹 브라우저에서 자바 스크립트 엔진 부분만 떼어 자바 스크립트 코드로 구현된 ‘View’ 클래스를 네이티브 쪽 안드로이드 프레임워크(안드로이드 스튜디오), 아이폰(iOS) UIKit 프레임 워크의 ‘View’ 클래스 호출로 연결하는 방식으로 동작하고 이를 브릿지 방식이라고 한다.</p>

<p><br /></p>

<h3 id="리액트-네이티브-개발-환경">리액트 네이티브 개발 환경</h3>

<p>리액트 네이티브 개발환경은 기본적으로 Node.js 개발 환경과 같다. 나는 Node.js 설치 후 VScode 편집기로 코드를 작성하였다.</p>

<p>맥과 Windows에서 리액트 네이티브 개발 환경하는 방법은 다르기 때문에 운영체제에 맞는 개발 환경을 설정한다.</p>

<p><br /></p>

<h4 id="운영체제별-개발할-수-있는-앱">운영체제별 개발할 수 있는 앱</h4>

<table>
  <thead>
    <tr>
      <th>개발 운영체제</th>
      <th>안드로이드 앱 개발</th>
      <th>iOS 앱 개발</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>윈도우 10</td>
      <td>가능</td>
      <td>불가능</td>
    </tr>
    <tr>
      <td>맥</td>
      <td>가능</td>
      <td>가능</td>
    </tr>
    <tr>
      <td>리눅스</td>
      <td>가능</td>
      <td>불가능</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>정리하자면 다음과 같다.
    <ul>
      <li>Node.js 설치 후 Visual Studio Code(VScode) 편집기로 코드 작성이 가능하다.</li>
      <li>안드로이드 앱의 경우, 윈도우, 맥, 리눅스 운영체제에서 개발 가능</li>
      <li>iOS 앱의 경우, 맥에서만 개발 가능</li>
    </ul>
  </li>
</ul>

<p>안드로이드 앱은 안드로이드 스튜디오 설치를 요구하는데 이는 윈도우10, 맥, 리눅스 운영체제 모두에서 설치가 되기 때문에 모든 운영체제에서 개발할 수 있지만 iOS앱은 애플이 제공하는 Xcode 개발 도구가 필요한데 이는 오직 맥에서만 동작하므로 다른 운영체제(윈도우, 리눅스)에서는 개발할 수 없는 것이다.</p>

<p><br /></p>

<h3 id="타입스크립트로-리액트-네이티브-앱을-만드는-이유">타입스크립트로 리액트 네이티브 앱을 만드는 이유</h3>

<p><strong>자바 스크립트</strong>는 <strong>타입(type) 기능이 없는 언어</strong>이므로 개발자의 사소한 입력 오류 등을 알아채지 못한다.(컴파일을 하기 전까지는 알지 못함.) 따라서 자바스크립트로 개발을 하면 어디서 어떤 오류가 발생했는지 알기 어려워 디버깅이 쉽지 않다. 이는 곧 개발과 유지 보수 비용을 높이는 원인이 된다.</p>

<p>그러나 <strong>타입스크립트</strong>는 자바스크립트와 100% 호환하면서도 <strong>타입 기능을 제공</strong>하므로 자연스럽고 알기 쉬운 구문을 코드를 작성할 수 있다. 그리고 타입스크립트 컴파일러는 코드에 문제가 있으면 <strong>미리</strong> 문제의 원인을 친절하게 알려주기 때문에 자바스크립트의 단점을 극복할 수 있다.</p>

<p>추가적으로 <strong>run-time error</strong>는 실행을 하고 나서 발생하는 오류이기 때문에 상당히 프로그래머 입장에서는 곤란한 오류이다. 그렇기 때문에 이를 사전에 방지하지 못하는 자바스크립트의 단점을 보완하여 나온 것이 타입스크립트라고 보면 될 것 같다.</p>

<p>그러나 브라우저는 자바스크립트로 돌아가기 때문에 타입스크립트로 작성한 .ts파일이 자바스크립트로 변환되어야 하는데 이는 알아서 자동으로 해주니 걱정할 필요도 없다.</p>

<blockquote>
  <p>이러한 장점으로 인해 리액트 팀은 리액트나 리액트 네이티브를 사용할 때 타입스크립트를 사용하라고 권한다.</p>
</blockquote>

<p><br /></p>

<h2 id="윈도우에서-개발-환경-갖추기">윈도우에서 개발 환경 갖추기</h2>

<p>윈도우에서 리액트 네이티브를 사용하기 위해선 다음과 같은 프로그램을 설치한다.</p>

<ul>
  <li>node.js
    <ul>
      <li>리액트 네이티브 개발은 node.js 버전에 영향을 받는다. 따라서 지원이 확실한 LTS버전을 사용하는 것이 권장된다.</li>
    </ul>
  </li>
  <li>JDK
    <ul>
      <li>리액트 네이티브를 사용하여 안드로이드 앱을 만드려면 안드로이드 SDK 빌드 도구가 필요하기 때문에 JDK를 설치한다.</li>
    </ul>
  </li>
  <li>비주얼 스튜디오(Vscode)
    <ul>
      <li>비주얼 스튜디오는 마이크로소프트에서 제공하는 오픈소스 편집기로 모든 소스코드가 이곳에 저장되어 관리한다.</li>
    </ul>
  </li>
  <li>안드로이드 스튜디오
    <ul>
      <li>안드로이드 앱을 만드려면 구글이 제공하는 안드로이드 스튜디오를 설치해야 한다.</li>
      <li>이 안드로이드 스튜디오에서 추가적으로 안드로이드 SDK또한 설치를 해 준다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h4 id="installed-build-tools-revision-3100-is-corrupted-remove-and-install-again-using-the-sdk-manager">Installed Build Tools revision 31.0.0 is corrupted. Remove and install again using the SDK Manager.</h4>

<p>처음에 설치한 안드로이드 스튜디오에서 에뮬레이터를 돌려보려고 했을 때 위와 같은 오류가 발생하였고 구글링을 통해 알아본 결과 주된 원인은 다음 두 파일이 없기 때문이었다.</p>

<ol>
  <li>dx.bat</li>
  <li>dx.jar</li>
</ol>

<p>그래서 31.0.0이 설치된 곳의 경로로 가보면(“C:\Users\user\AppData\Local\Android\Sdk\build-tools\31.0.0”) dx.bat과 lib 폴더에 d8.jar가 있는데 이 두 파일의 이름을 각각 d8 -&gt; dx로 바꾸어 주었더니 해결되었다.</p>

<p><img src="https://user-images.githubusercontent.com/79521972/175042098-cd1e329e-4c44-409e-aa04-231d4012f835.png" alt="image" /></p>

<p><br /></p>

<h4 id="manifest-merger-failed--apps-targeting-android-12-and-higher-are-required-to-specify-an-explicit-value-for-androidexported-when-the-corresponding-component-has-an-intent-filter-defined-see-httpsdeveloperandroidcomguidetopicsmanifestactivity-elementexported-for-details">Manifest merger failed : Apps targeting Android 12 and higher are required to specify an explicit value for <code class="language-plaintext highlighter-rouge">android:exported</code> when the corresponding component has an intent filter defined. See https://developer.android.com/guide/topics/manifest/activity-element#exported for details.</h4>

<p>앞선 오류를 해결했더니 다시 또 다른 오류가 발생하였는데 이는 AndroidManifest.xml에 android:exported=”true” 구문을 추가해 줌으로써 해결할 수 있었다.</p>

<p><img src="https://user-images.githubusercontent.com/79521972/175044925-be5d4531-0eb8-4447-bbd0-e9f405cab3c9.png" alt="image" /></p>

<p><br /></p>

<p>그래서 최종적으로 에뮬레이터를 생성하여 실행시켜 보았을 때 다음과 같은 화면이 에뮬레이터에 나오면 에뮬레이터 준비는 다 된 것이다.</p>

<p><img src="https://user-images.githubusercontent.com/79521972/175045011-4a0a4db0-a414-47d5-a7a0-badc408f3ab8.png" alt="image" style="zoom:50%;" /></p>

<h3 id="첨언">첨언</h3>

<p>보통 이 과정에서 문제가 되는 것은 환경변수의 문제인 경우가 많았다. 이는 구글에 쳐보면 많은 해결 방법이 나오고 나 또한 해당 문제를 겪어 올바른 환경 변수 설정으로 문제를 해결할 수 있었다.</p>

<p>또한 에뮬레이터를 실행할 때 installBug가 나타날 경우가 있는데 이는 AVD manager에서 해당 에뮬레이터 설정에서 wipe data를 통해 용량을 정리해 주면 된다.</p>

<h2 id="vscode-환경설정">VScode 환경설정</h2>

<ul>
  <li>
    <p>타입스크립트 설치</p>

    <ul>
      <li>터미널에서: <code class="language-plaintext highlighter-rouge">npm i -g typescript ts-node</code></li>
    </ul>
  </li>
  <li>
    <p>prettier 확장 기능 설치 및 동작 환경 설정</p>

    <ul>
      <li>
        <p>vscode 확장 메뉴에서 prettier를 다운 받고 setting.json에 대한 설정을 한다.</p>
      </li>
      <li>
        <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"terminal.integrated.defaultProfile.windows"</span><span class="p">:</span><span class="w"> </span><span class="s2">"PowerShell"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"editor.wordWrap"</span><span class="p">:</span><span class="w"> </span><span class="s2">"on"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"editor.formatOnSave"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
  </span><span class="nl">"[typescript]"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"editor.formatOnPaste"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
    </span><span class="nl">"editor.formatOnSave"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
    </span><span class="nl">"editor.defaultFormatter"</span><span class="p">:</span><span class="w"> </span><span class="s2">"esbenp.prettier-vscode"</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"editor.defaultFormatter"</span><span class="p">:</span><span class="w"> </span><span class="s2">"esbenp.prettier-vscode"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"editor.tabSize"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w">
  </span><span class="nl">"prettier.semi"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span><span class="p">}</span><span class="w">
    
</span></code></pre></div>        </div>
      </li>
      <li>
        <p>이를 통해 파일을 저장할 때 항상 포맷(즉, 린트) 기능을 수행한다. 그리고 타입스크립트 파일일 때는 포맷 프로그램으로 앞서 설치한 prettier를 실행한다.</p>
      </li>
      <li>
        <p>prettier를 사용하려면 디렉터리에 .prettierrc.js 파일을 만들어야 하는데 이 파일은 prettier가 소스 코드를 포맷할 때 참조하는 파일이기에 .js 파일로 구현된다.</p>
      </li>
      <li>
        <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">arrowParens</span><span class="p">:</span> <span class="dl">'</span><span class="s1">avoid</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">bracketSameLine</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">bracketSpacing</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="na">singleQuote</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">trailingComma</span><span class="p">:</span> <span class="dl">'</span><span class="s1">all</span><span class="dl">'</span><span class="p">,</span>
<span class="p">};</span>
    
</code></pre></div>        </div>
      </li>
      <li>
        <p>각각에 해당하는 기능을 알고 싶으면 다음 링크를 통해 원하는 설정을 할 수 있다.</p>

        <ul>
          <li><a href="https://prettier.io/docs/en/configuration.html">https://prettier.io/docs/en/configuration.html</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h1 id="chapter-2-리액트-네이티브-기본-다지기">Chapter 2. 리액트 네이티브 기본 다지기</h1>

<p>최종적으로 에뮬레이터 작동까지 확인하였으면 이제 타입스크립트용 리액트 네이티브 프로젝트를 생성하고 ch02_1 디렉터리를 대상으로 vscode를 실행한다.(디렉터리 명은 마음대로 해도 된다.)</p>

<p>프로젝트를 생성하는 명령어는 앞으로 새 프로젝트를 생성해야 할 때마다 실행해야 하기 때문에 외워두면 좋다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> npx react-native init ch02_1 <span class="nt">--template</span> react-native-template-typescript
</code></pre></div></div>

<ul>
  <li>여기서 사용하는 npx 명령어(혹은 npm)가 가끔씩 에러를 띄우는 경우가 있는데 이는 해당 명령어를 치는 터미널의 경로가 이 프로젝트를 생성한 폴더 안이어야 하기 때문이다. 때문에 항상 명령어를 치기 전에 올바른 경로에 있는지를 확인해야 한다.</li>
</ul>

<p><br /></p>

<p>기본적인 App.tsx 파일 세팅은 다음과 같다. -&gt; 이는 화면 좌측 상단에 Hello, world를 띄우는 가장 기초적인 단계로 이제 화면에 무언갈 구성할 수 있게 되었다.</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span><span class="nx">Text</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react-native</span><span class="dl">'</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// console.log('App called')</span>
  <span class="kd">const</span> <span class="nx">textElement</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="nx">Text</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Hello, world!</span><span class="dl">'</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">textElement</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<p>앱이 잘 동작하는지 확인하기 위해서는 터미널을 동시에 두 개를 켜고 하나에서는 <code class="language-plaintext highlighter-rouge">npm start</code>를 나머지 하나에서는 <code class="language-plaintext highlighter-rouge">npm run android</code>를 친다.</p>

<ul>
  <li>이는 package.json에 설정된 script 명령이다.</li>
</ul>

<p>그러면 안드로이드 에뮬레이터에 hello world가 찍힌 것을 볼 수 있을 것이다.</p>

<p><br /></p>

<h2 id="dom과-렌더링">DOM과 렌더링</h2>

<p>앞선 1장에서 살펴봤듯이 리액트 네이티브 프레임워크는 리액트 프레임워크에 기반을 둔 기술이다. 이 때문에 리액트 네이티브의 동작 원리를 이해하려면 먼저 리액트의 동작 원리를 알아야 한다.</p>

<p>그런데 리액트의 동작 원리를 이해하려면 이번엔 물리 DOM(physical DOM)과 가상 DOM(virtual DOM)이란 개념을 알아야 한다.</p>

<p><br /></p>

<blockquote>
  <p>기존 웹서버에서 HTML 문서를 생성하여 웹 브라우저로 전송하는 정적 HTML방식에서 벗어나 웹 브라우저에서 자바 스크립트 코드를 실행하여 동적으로 HTML을 생성하는 방식으로 동작하는 웹 기술로, 이것이 발전하여 오늘날의 리액트와 같은 프론트엔드 프레임워크가 되었다.</p>

  <blockquote>
    <p>잘 생각해 보면 과거에는 댓글을 달면 해당 페이지가 새로고침 되었다면 요즘에는 새로고침되지 않더라도 댓글이 딱! 하고 나오는 것을 알 수 있을 것이다.</p>
  </blockquote>
</blockquote>

<p><br /></p>

<ul>
  <li>DOM이란?
    <ul>
      <li><strong>웹 페이지를 이루는 태그들을 자바스크립트가 이용할 수 있게끔 브라우저가 트리구조로 만든 객체 모델을 의미한다.</strong></li>
      <li>말 뜻 그대로 문서 객체 모델을 의미하며 문서 객체(html, head, body와 같은 태그)를 자바스크립트가 이용할 수 있는(memorable) 객체를 의미한다.</li>
      <li>정리하자면 DOM은 <code class="language-plaintext highlighter-rouge">HTML과 스크립팅 언어(자바스크립트)를 서로 이어주는 역할</code>이라고 보면 된다.</li>
    </ul>
  </li>
</ul>

<p>DHTML 방식은 자바 스크립트가 <code class="language-plaintext highlighter-rouge">&lt;div&gt;Hello world!&lt;/div&gt;</code>와 같은 텍스트를 만드는 것이 아니라 객체 지향 언어의 상속 관계로 설계한 문서 객체 모델(Document Object Model, DOM) 타입스크립트 객체를 생성하는 방식으로 동작한다.</p>

<p>비록 웹브라우저는 <code class="language-plaintext highlighter-rouge">&lt;div&gt;, &lt;h1&gt;</code>과 같은 HTML 형태로 보여주지만 자바스크립트 코드 관점에서는 <code class="language-plaintext highlighter-rouge">&lt;div&gt;</code>는 <strong>HTMLDivElement 클래스의 인스턴스</strong>이고 <code class="language-plaintext highlighter-rouge">&lt;h1&gt;</code>은 <strong>HTMLHeadingElement 클래스의 인스턴스</strong>이다.</p>

<p>이러한 클래스를 <strong>DOM</strong>이라 부르고 DOM 클래스의 인스턴스를 <strong>DOM객체</strong>라고 한다.</p>

<p>DOM 객체는 무수히 많아서 <strong>트리구조</strong>를 이루고 있고 이를 <strong>DOM 구조</strong>라 한다.</p>

<blockquote>
  <p>그래서 웹 브라우저가 HTML을 parsing하여 자바스크립트 DOM 구조로 만드는 것을 렌더링(rendering)이라 한다.</p>
</blockquote>

<p><br /></p>

<h3 id="물리-dom과-가상-dom">물리 DOM과 가상 DOM</h3>

<p>리액트 프레임워크에는 독특하게 물리 DOM과 가상 DOM이 나누어져 있는데 이 둘의 차이는 다음과 같다.</p>

<ul>
  <li>물리 DOM(physical DOM)
    <ul>
      <li>웹 브라우저에서 자바스크립트 코드가 생성하는 실제 DOM 구조</li>
    </ul>
  </li>
  <li>가상 DOM(virtual DOM)
    <ul>
      <li>리액트 코드가 생성한 자바스크립트 객체 구조</li>
    </ul>
  </li>
</ul>

<p>리액트는 특정 시점에 이 가상 DOM 구조를 물리 DOM 구조로 만드는데 , 이를 <code class="language-plaintext highlighter-rouge">리액트가 렌더링한다.</code>라고 하고 이 기능을 수행하는 패키지를 렌더러(renderer)라는 것으로 따로 구분을 해 두었다</p>

<p><br /></p>

<blockquote>
  <p>리액트 프레임워크 vs. 리액트 네이티브 프레임워크</p>

  <blockquote>
    <p>리액트는 가상 DOM 구조를 react-dom이란 렌더러(DOM 렌더러) 패키지를 사용하여 물리 DOM 구조로 렌더링하는 방식으로 동작</p>
  </blockquote>

  <blockquote>
    <p>리액트 네이티브는 react-native 라는 렌더러(네이티브 렌더러) 패키지를 사용하여 렌더링하는 방식으로 동작하는 프레임워크</p>
  </blockquote>
</blockquote>

<h3 id="그래서-가상-dom이-왜-나온건데">그래서 가상 DOM이 왜 나온건데?</h3>

<p>요즘 흔히 접하는 큰 규모의 웹 애플리케이션(트위터,페이스북)은 스크롤바를 내릴 수록 수많은 데이터가 로딩된다. 그리고 각 데이터를 표현하는 요소들이 있다.</p>

<p>요소 개수가 몇 백 개, 몇 천 개 단위로 많은 규모가 큰 웹 애플리케이션에서 DOM에 직접 접근하여 변화를 주다 보면 성능 이슈가 조금씩 발생하기 시작한다.</p>

<p>즉 느려진다는 말인데 이것이 정확한 말은 아니다.</p>

<p>DOM자체는 빠르다.  읽고 쓸 때의 성능은 자바스크립트 객체를 처리 할 때의 성능과 비교하여 다르지 않다.</p>

<p>단, 웹브라우저 단에서 DOM 변화가 일어나면 웹브라우저가 CSS를 다시 연산하고 레이아웃을 구성하고, 페이지를 리-페인트 즉 렌더링이 일어 나는 이 과정에서 시간이 허비되는 것이다.</p>

<p>그리고 이 렌더링 과정은 상황에 따라 여러번 반복하여 발생할 수 있고, 돔이 추가,삭제 혹은 태그 위치가 변하는 경우 렌더링이 일어납니다.</p>

<blockquote>
  <p>렌더링 : 브라우저 로딩 과정 중 스타일 이후의 과정(스타일-&gt; 레이아웃 -&gt; 페인트 -&gt; 합성)을 렌더링이라고 한다.</p>
</blockquote>

<p><strong>결론</strong></p>

<p>속도적인 부분과 많은 일을 수행하다 버그가 발생하거나 브라우저가 죽는 일 등등의 일을 개선하고자</p>

<p>가상돔(<em>Virtual DOM</em>)이 나왔다.</p>

<p><br /></p>

<h3 id="react-패키지의-역할">react 패키지의 역할</h3>

<p>리액트 네이티브 프레임워크는 react라는 패키지를 사용하며 react 패키지는 App.tsx와 같은 파일을 가상 DOM 구조로 만드는 역할을 하는 패키지이다.</p>

<p>네이티브 렌더러는 <strong>리액트 요소</strong>를 안드로이드 프레임워크나 iOS용 UIKit 프레임워크의 화면 UI 객체로 바꿔주는 역할을 한다.</p>

<p><br /></p>

<h3 id="브리지-방식-렌더링">브리지 방식 렌더링</h3>

<p><strong>리액트</strong>는 모든 것이 자바스크립트로 동작하기에 React.render라는 DOM 렌더러의 동작을 코드로 확인할 수 있지만,</p>

<p><strong>리액트 네이티브</strong>는 네이티브 렌더러의 모습을 확인할 수 없는데, 이는 리액트 네이티브 프로젝트의 android와 ios 디렉터리에 있는 자바나 오브젝티브-C로 구현한 <strong>네이티브 모듈 쪽에서 렌더링이 진행되기 때문이다.</strong></p>

<p>네이티브 모듈 쪽에는 JavaScriptCore라는 이름의 자바스크립트 엔진이 동작하고 이 C++ 언어로 구현된 JavaScriptCore 엔진은 안드로이드에서는 JNI(Java Native Interface) 방식으로, iOS에서는 오브젝티브-C의 FFI 방식으로 연결되어 동작한다.</p>

<blockquote>
  <p>엔진과 라이브러리는 같은 개념인데 일반적으로 코드 분량이 방대한 라이브러리를 엔진이라고 부르는 경향이 있다.</p>
</blockquote>

<p>리액트 네이티브 전용 패키지에는 항상 자바스크립트 스레드에서 동작하는 쪽과 UI 스레드에서 동작하는 쪽이 따로 있다. 때문에 자바스크립트 쪽만 설치하고 UI 스레드에서 동작하는 쪽을 설치하지 않으면 패키지가 정상 동작하지 않는다.</p>

<p>npx react-native link, npx pod-install 과 같은 명령은 앞으로 네이티브에서 동작하는 부분을 설치하는 것을 의미한다고 알고 있으면 된다.</p>

<p>(현재 일자, 22-06-29를 기준으로 npx react-native link는 동작하지 않음)</p>

<p><br /></p>

<h3 id="reactcreateelement-api가-하는-일">React.createElement API가 하는 일</h3>

<p>리액트와 리액트 네이티브에서 React.createElement API는 <strong>가장 저수준 기능</strong>으로 서 가상 DOM 객체를 생성한다.</p>

<p>HTML로 웹 브라우저에 ‘Hello world’ 등의 텍스트를 출력하려면 다음과 같이 작성한다.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;p&gt;</span>
    Hello world!
<span class="nt">&lt;/p&gt;</span>
</code></pre></div></div>

<p>그러면 웹 브라우저가 렌더링하여 해당 내용을 화면에 웹 페이지를 표시한다.</p>

<p><br /></p>

<p>자바스크립트로 앞선 HTML 텍스트와 동일한 효과를 구현하면 다음과 같은 코드를 통해 <strong>물리 DOM 객체</strong>를 생성할 수 있다.</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">pElement</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">)</span>
<span class="nx">pElemenet</span><span class="p">.</span><span class="nx">innerText</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Hello JavaScript</span><span class="dl">'</span>
</code></pre></div></div>

<p>그리고 이 물리 DOM 객체는 <strong>다음의 코드</strong>가 반드시 나와야 렌더링 되어 화면에 나타나는데 HTML과 달리 자바스크립트 세계에서는 이처럼<code class="language-plaintext highlighter-rouge"> DOM 객체 생성 과정</code>과 <code class="language-plaintext highlighter-rouge">렌더링</code> 등 두 과정이 필요하게 된다.</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">pElement</span><span class="p">)</span>
</code></pre></div></div>

<p><br /></p>

<p>이제 <strong>리액트</strong> 프레임워크를 통해서 앞의 <strong>자바스크립트 효과</strong>를 구현해 볼 것인데 가장 먼저 가상 DOM 객체를 생성해 준다.</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">pElement</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Hello React World</span><span class="dl">'</span><span class="p">)</span>
</code></pre></div></div>

<p><br /></p>

<p>다음과 같은 코드로 이 pELement 가상 DOM 객체를 물리 DOM 객체로 변환하여 화면에 표시할 수 있다.</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">ReactDOM</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react-dom</span><span class="dl">'</span>

<span class="nx">ReactDOM</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span><span class="nx">pElement</span><span class="p">,</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">)</span>
</code></pre></div></div>

<p><br /></p>

<p>리액트 네이비브도 리액트와 동일하게 가상 DOM 객체를 생성한다.</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">textElement</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="nx">Text</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Hello world!</span><span class="dl">'</span><span class="p">)</span>
</code></pre></div></div>

<p>그러나 리액트 네이티브 렌더러는 네이티브에서 동작하기 때문에 다음처럼 가상 DOM 객체를 <strong>네이티브로 넘겨주는 방식</strong>으로 동작한다.</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">textElement</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="nx">Text</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Hello world!</span><span class="dl">'</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">textElement</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<p>react-native-cli(Not expo)는 네이티브 모듈에서 동작하는 자바스크립트 엔진이 가상 DOM 객체를 넘겨주는 App의 존재를 알 수 있도록 다음 내용의 index.js 파일을 만든다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// index.js</span>
<span class="k">import</span> <span class="p">{</span><span class="nx">AppRegistry</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react-native</span><span class="dl">'</span>
<span class="k">import</span> <span class="nx">App</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./App</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span><span class="nx">name</span> <span class="k">as</span> <span class="nx">appName</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./app.json</span><span class="dl">'</span>

<span class="nx">AppRegistry</span><span class="p">.</span><span class="nx">registerComponent</span><span class="p">(</span><span class="nx">appName</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">App</span><span class="p">)</span>
</code></pre></div></div>

<p>또한 네이티브 모듈에서 동작하는 자바 스크립트 엔진이 위 파일의 존재를 알 수 있도록 다음과 같은 코드를 가진 자바 파일도 만들어 준다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MainApplication.java</span>
<span class="o">(...</span><span class="na">생략</span><span class="o">...)</span>
<span class="nd">@Override</span>
<span class="kd">protected</span> <span class="nc">String</span> <span class="nf">getJSMainModulName</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="s">"index"</span>
<span class="o">};</span>
<span class="o">(...</span><span class="na">생략</span><span class="o">...)</span>
</code></pre></div></div>

<p><br /></p>

<p>이제 리액트 네이티브 앱을 폰(혹은 에뮬레이터)에서 실행하면 MainApplication.java가 실행되고 자바스크립트 스레드에서 실행되는 자바스크립트 엔진이 getJSMainModuleName을 통해 index.js 파일의 존재를 알게 된다.</p>

<p>이 index.js 파일을 통해 App의 존재를 알고 App을 호출하여 얻은 가상 DOM 객체를 브리지를 통해 네이티브로 넘겨 마침내 ‘Hello world!’를 출력한다.</p>

<p><br /></p>

<h3 id="안드로이드-네이티브-모듈과-npm-run-android-명령과의-관계">안드로이드 네이티브 모듈과 npm run android 명령과의 관계</h3>

<p>npm run adroid 명령은 사실 다음과 같은 안드로이드 앱 빌드 명령을 실행한다. 이 명령은 명령 줄 방식으로 안드로이드 스튜디오에서 빌드 명령을 실행하는 것과 같다.</p>

<blockquote>
  <p>이 명령을 실행하기 위해선 항상 안드로이드 스튜디오의 에뮬레이터가 미리 실행되어 있어야 함을 명심하라.</p>
</blockquote>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>android
./gradlew installDebug
</code></pre></div></div>

<p>그런데 이 안드로이드 빌드 명령은 리액트 네이티브 앱을 에뮬레이터에 설치만 할 뿐 실행은 하지 않기 때문에<code class="language-plaintext highlighter-rouge"> npm run android </code>명령을 사용하는 것이다.</p>

<p><br /></p>

<ul>
  <li>npm run android:
    <ul>
      <li>타입스크립트 코드와는 상관없이 android 디렉터리만을 대상으로 자바 언어로 작성한 네이티브 앱(ch02_1/android) 부분을 빌드하여 에뮬레이터에 앱을 설치하는 명령이다.</li>
    </ul>
  </li>
  <li>npm start:
    <ul>
      <li>설치된 앱이 처음 구동될 때(Not hot-reloading) 앱이 수신해야 할 ES5 자바스크립트 코드로 컴파일된 타입스크립트 코드 번들을 제공하는 메트로 서버를 실행하는 명령이다.</li>
    </ul>
  </li>
</ul>

<p>npm start가 선행 되어야 함 (npm run android보다)</p>

<p><br /></p>

<blockquote>
  <p>새로운 프로젝트 시작 전이나 새로운 패키지를 설치할 때는 메트로 서버를 중지해야 한다.</p>
</blockquote>

<p><br /></p>

<h2 id="jsx-구문">JSX 구문</h2>

<p><strong>JSX 구문</strong>은 React.createElement 대신 가상 DOM 객체를 쉽게 만들 수 있다.</p>

<p>리액트나 리액트 네이티브 코드 작성자는 복잡한 여러 번의 React.createElement 호출 코드를 작성하는 대신 훨씬 간결한 JSX 코드만 작성하면 되기 때문에 빠르고 간결한 코드를 작성할 수 있으므로 개발 생산성이 대폭 향상된다.</p>

<p>JSX 구문이 있는 타입스크립트 코드는 확장자가 .tsx 이며 JSX 구문이 있는 코드는 다음 import 문이 필요하다.</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span>
</code></pre></div></div>

<p>흥미롭게도 이는 마치 자바스크립트나 타입스크립트 문법에 XML 구문이 있는 것처럼 사용한다. 리액트와 리액트 네이티브에서는 이처럼 자바스크립트와 XML 구문을 결합해 사용하는 코드를 JSX라고 한다.</p>

<p><br /></p>

<p>페이스북은 JSX 구문을 컴파일하고자 @babel/plugin-transform-react-jsx라는 바벨 플러그인을 실행해 여러 개의 React.createElement 함수를 호출하는 평범한 자바스크립트로 변환한다. 타입스크립트 컴파일러 tsc도 바벨의 이런 동작 방식과 비슷하게 JSX 코드를 만나면 React.createElement 함수 호출 자바스크립트로 변환한다.</p>

<p>때문에 JSX 구문이 주는 이런 간편성은 개발 생선성의 대폭 증가로 이어졌고 이에 더하여 세상에서 가장 인기있는 프론트엔드 자바스크립트 프레임워크가 되는데 큰  역할을 했다.</p>

<p>그런데 JSX 구문이 있는 타입스크립트 코드는 확장자가 .tsx여야 한다. 또한 JSX 구문이 있는 코드는 <code class="language-plaintext highlighter-rouge">import React from 'react'</code> import 문이 필요하다.</p>

<p><br /></p>

<h2 id="마크업-언어-용어">마크업 언어 용어</h2>

<p>HTML 마크업 언어 &lt; XML 마크업 언어</p>

<ul>
  <li>XML은 태그나 속성을 맘대로 확장할 수 있기 때문에</li>
  <li>HTML은 문서를 구성하는 요소의 태그 이름이 모두 고정되어 있음</li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"root"</span> <span class="na">style=</span><span class="s">"display: flex"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;h1&gt;</span>
        Hello world
    <span class="nt">&lt;/h1&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div>

<p>위처럼 div와 같은 태그를 꺽쇠 기호(&lt;&gt;)로 감싼 시작 태그를 <code class="language-plaintext highlighter-rouge">&lt;div&gt;</code>처럼 만들고 <code class="language-plaintext highlighter-rouge">&lt;/div&gt;</code>처럼 태그 이름 앞에 ‘/’ 기호를 추가한 끝 태그로 감싼 <code class="language-plaintext highlighter-rouge">&lt;div&gt;&lt;/div&gt;</code>형태가 기본이다.</p>

<ul>
  <li>시작 태그에는 id, style과 같은 속성(attribute)을 함께 기술할 수 있으며 항상 속성값은 작은 따옴표나 큰따옴표로 감싸야한다.</li>
  <li>시작태그와 끝 태그 사이에는 <code class="language-plaintext highlighter-rouge">&lt;h1&gt;Hello world&lt;/h1&gt;</code>와 같은 자식 요소를 삽입할수 있는데 자식요소란 XML 요소나 문자열을 의미한다.
    <ul>
      <li>문자열이 자식 요소인 경우 따옴표는 생략한다.</li>
      <li>자식 요소가 없다면 <code class="language-plaintext highlighter-rouge">&lt;div /&gt;</code> 형태로 표현할 수 있는데, 이를 스스로 닫는 태그(self-closing tag)라 한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>
    <p>createElemenet 사용 방법</p>

    <ul>
      <li>
        <div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">가상_DOM_객체</span> <span class="o">=</span> <span class="nx">createElement</span><span class="p">(</span><span class="nx">컴포넌트_이름_또는_문자열</span><span class="p">,</span> <span class="nx">속성_객체</span><span class="p">,</span> <span class="nx">자식_컴포넌트</span><span class="p">)</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>따라서 아래 두 표현은 같은 것이다.</p>
      </li>
      <li>
        <div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">textElement</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="nx">Text</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Hello world!</span><span class="dl">'</span><span class="p">)</span>
</code></pre></div>        </div>
      </li>
      <li>
        <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;Text&gt;</span>Hello world!<span class="nt">&lt;/Text&gt;</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>XML 파서(parse)가 이를 React.createElement(Text, null, ‘Hello word!’) 자바스크립트 코드로 변환해 준다면 이 텍스트를 자바스크립트에서 이용할 수 있다. JSX 구문은 이런 아이디어에서 비롯된 것이다.</p>

        <ul>
          <li>위에서 언급한  @babel/plugin-transform-react-jsx 바벨 플러그인이 이 아이디어를 구현한 parser이다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="jsx-구문에서-중괄호-의-의미">JSX 구문에서 중괄호 {}의 의미</h2>

<p>JSX는 다음 코드에서 보듯 XML 마크업 구조에 중괄호({ })를 사용하여 자바스크립트 코드를 감싸는 형태의 문법을 제공한다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="nc">Text</span><span class="p">&gt;</span>
	<span class="si">{</span><span class="nx">person</span><span class="si">}</span>
<span class="p">&lt;/</span><span class="nc">Text</span><span class="p">&gt;</span>
</code></pre></div></div>

<p>이런 식으로 자바스크립트의 변수값을 XML 구문 안에 표현할수 있다.</p>

<p><br /></p>

<h2 id="xml-요소-간의-자식-관계와-컴포넌트-간의-자식-관계의-유사성">XML 요소 간의 자식 관계와 컴포넌트 간의 자식 관계의 유사성</h2>

<p>XML은 요소를 부모 자식 관계로 표현하는데 보통 부모 태그가 자식 태그를 감싼 형태이다.</p>

<p>그리고 JSX 문은 React.createElement 호출이므로 JSX 문 자체를 변수에 담을 수 있고 이 과정까지 생략하고 다음처럼 함수의 반환값으로 사용하는 것이 일반적이다.</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">&lt;</span><span class="nc">SafeAreaView</span><span class="p">&gt;&lt;</span><span class="nc">Text</span><span class="p">&gt;</span>Hello JSX world!<span class="p">&lt;/</span><span class="nc">Text</span><span class="p">&gt;&lt;/</span><span class="nc">SafeAreaView</span><span class="p">&gt;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="표현식과-실행문-그리고-jsx">표현식과 실행문 그리고 JSX</h2>

<p>JSX 코드 안에는 반드시 return 키워드 없이 값을 반환해야 한다. 즉 실행문(if와 같은)은 그 자체로는 ‘값’이 아니기 때문에 JSX 코드 안에서 사용하지 못하고 오로지 표현식만이 포함되어 있어야 한다.</p>

<p>또한 해당 코드 안에는 가상 DOM 객체를 반드시 포함해야 하기 때문에 이를 구성하는 코드 한 줄 한 줄이 모드 React.createElement 호출 코드로 변환되어야 하는데 이로 변환 될 수 없는(console.log()) 와 같은 것은 오류를 일으킬 것이다.</p>

<p>이럴 때는 해당 코드는 JSX 문 바깥에 두어서 해결하도록 한다. 혹은 단축 평가 형태로 구현한다. 따라서 다음과 같은 코드는 오류를 일으키지 않고 정상 동작한다.</p>

<h3 id="조건에-따라-분기되는-jsx-문-작성법">조건에 따라 분기되는 JSX 문 작성법</h3>

<ol>
  <li>if문을 JSX 문 바깥쪽에 구현하여 문제 해결</li>
</ol>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span><span class="nx">SafeAreaView</span><span class="p">,</span> <span class="nx">Text</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react-native</span><span class="dl">'</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">isLoading</span> <span class="o">=</span> <span class="kc">true</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">isLoading</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">&lt;</span><span class="nc">SafeAreaView</span><span class="p">&gt;</span>
                <span class="si">{</span><span class="nx">isLoading</span> <span class="o">&amp;&amp;</span> <span class="p">&lt;</span><span class="nc">Text</span><span class="p">&gt;</span>Loading...<span class="p">&lt;/</span><span class="nc">Text</span><span class="p">&gt;</span><span class="si">}</span>
                <span class="si">{</span><span class="o">!</span><span class="nx">isLoading</span> <span class="o">&amp;&amp;</span> <span class="p">&lt;</span><span class="nc">Text</span><span class="p">&gt;</span>Hello JSX world!<span class="p">&lt;/</span><span class="nc">Text</span><span class="p">&gt;</span><span class="si">}</span>
            <span class="p">&lt;/</span><span class="nc">SafeAreaView</span><span class="p">&gt;</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>조건문을 단축 평가 코드로 바꿔 문제 해결</li>
</ol>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span><span class="nx">SafeAreaView</span><span class="p">,</span> <span class="nx">Text</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react-native</span><span class="dl">'</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">isLoading</span> <span class="o">=</span> <span class="kc">true</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">isLoading</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">&lt;</span><span class="nc">SafeAreaView</span><span class="p">&gt;</span>
                <span class="si">{</span><span class="nx">isLoading</span> <span class="o">&amp;&amp;</span> <span class="p">&lt;</span><span class="nc">Text</span><span class="p">&gt;</span>Loading...<span class="p">&lt;/</span><span class="nc">Text</span><span class="p">&gt;</span><span class="si">}</span> /* this means isLoading ? <span class="p">&lt;</span><span class="nc">Text</span><span class="p">&gt;</span>Loading...<span class="p">&lt;/</span><span class="nc">Text</span><span class="p">&gt;</span> : undefined
                <span class="si">{</span><span class="o">!</span><span class="nx">isLoading</span> <span class="o">&amp;&amp;</span> <span class="p">&lt;</span><span class="nc">Text</span><span class="p">&gt;</span>Hello JSX world!<span class="p">&lt;/</span><span class="nc">Text</span><span class="p">&gt;</span><span class="si">}</span>
            <span class="p">&lt;/</span><span class="nc">SafeAreaView</span><span class="p">&gt;</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>JSX 문을 변수에 담아 문제 해결</li>
</ol>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span><span class="nx">SafeAreaView</span><span class="p">,</span> <span class="nx">Text</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react-native</span><span class="dl">'</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">isLoading</span> <span class="o">=</span> <span class="kc">true</span>
    <span class="kd">const</span> <span class="nx">children</span> <span class="o">=</span> <span class="nx">isLoading</span> <span class="p">?</span> <span class="p">(</span>
        <span class="p">&lt;</span><span class="nc">Text</span><span class="p">&gt;</span>Loading...<span class="p">&lt;/</span><span class="nc">Text</span><span class="p">&gt;</span>
    <span class="p">)</span> <span class="p">:</span> <span class="p">(</span>
        <span class="p">&lt;</span><span class="nc">Text</span><span class="p">&gt;</span>Hello JSX world!<span class="p">&lt;/</span><span class="nc">Text</span><span class="p">&gt;</span>	
    <span class="p">)</span>
    <span class="k">return</span> <span class="p">&lt;</span><span class="nc">SafeAreaView</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">children</span><span class="si">}</span><span class="p">&lt;/</span><span class="nc">SafeAreaView</span><span class="p">&gt;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="배열과-jsx-구문">배열과 JSX 구문</h2>

<p>여러개의 JSX 문을 배열 형태로 만들어 이를 자식 컴포넌트로 넘겨줄 수도 있다.</p>

<p><br /></p>

<p>이 때 주의해야 할 점이 있는데 여러 개의 자식 컴포넌트가 있을 때는 반드시 XML 작성 원칙을 준수해야 한다.</p>

<ul>
  <li><mark>XML 문법에서 부모 요소 없이는 여러 개의 XML 요소를 만들 수 없다.</mark></li>
</ul>

<p>JSX 역시 XML이므로 여러 개의 컴포넌트를 배열로 담은 children 변수가 부모 컴포넌트 없이 홀로 {children} 형태로 존재해서는 안된다.</p>

<p><br /></p>

<h3 id="배열-만들어-보기">배열 만들어 보기</h3>

<p>Array 클래스가 제공하는 map 메서드를 사용하여 내용이 조금씩 다른 컴포넌트 배열을 만들어 보자.</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span><span class="nx">SafeAreaView</span><span class="p">,</span> <span class="nx">Text</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react-native</span><span class="dl">'</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">children</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">fill</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">notUsed</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">&lt;</span><span class="nc">Text</span><span class="p">&gt;</span>Hello world! <span class="si">{</span><span class="nx">index</span><span class="si">}</span><span class="p">&lt;/</span><span class="nc">Text</span><span class="p">&gt;)</span>
    
    <span class="k">return</span> <span class="p">&lt;</span><span class="nc">SafeAreaView</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">children</span><span class="si">}</span><span class="p">&lt;/</span><span class="nc">SafeAreaView</span><span class="p">&gt;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>100의 아이템을 undefined로 하는 배열을 만들어 이를 모두 null로 채우고(undefined 아이템에는 map을 적용할 수 없음) map을 통해 Text 컴포넌트를 만든다.</p>

<p><br /></p>

<h2 id="faker-모듈">faker 모듈</h2>

<p>faker 모듈은 그럴듯한 가짜 데이터를 생성하는 것을 도와주는 패키지이다.</p>

<p>개발을 할 때 그럴듯한 아바타, 텍스트, 이미지 파일이 필요한데 이 패키지에서 이러한 다양한 가짜 데이터를 제공해 준다.</p>

<ul>
  <li>설치 : <code class="language-plaintext highlighter-rouge">npm i faker</code> , <code class="language-plaintext highlighter-rouge">npm i -D @types/faker</code></li>
  <li>우리는 타입스크립트를 사용하기 때문에 위 두 모듈을 다 다운 받는다.</li>
  <li>참고로 모듈을 설치할 때는 항상 메트로 서버를 중단시키고 다운을 받아야 한다.(메트로 서버 실행 도중에는 node_modules가 락 상태가 되기 때문에)</li>
</ul>

<h2 id="faker-모듈을-설치하면서-발생한-문제">faker 모듈을 설치하면서 발생한 문제</h2>

<p>계속해서 faker 모듈을 import 하면 선언되지 않았다고 하는 문제가 발생하였다.</p>

<p>-&gt; 5.5.3 버전을 명시하여 설치하였더니 해결함</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm i faker
npm i faker@5.5.3
npm i @types/faker@5.5.3
</code></pre></div></div>

<p><br /></p>

<h2 id="가짜-데이터-생성">가짜 데이터 생성</h2>

<p>다음과 같은 파일들을 src/data 디렉터리 밑에 만든다.</p>

<ul>
  <li>IPerson.ts: id, name, image 등 각 속성의 타입 정보를 저장</li>
  <li>util.ts: 배열을 만들고, 랜덤 숫자를 생성하고 unsplash.com에서 랜덤 이미지를 얻고, ui-avatar.com으로부터 이름에 따른 랜덤 아바타 이미지를 얻는 콜백함수들을 생성한다.</li>
  <li>faker.ts: 실제로 랜덤하게 얻을 데이터를 faker 모듈의 여러 함수를 통해 각 변수에 저장시킨다.
    <ul>
      <li>널 병합 연산자: <code class="language-plaintext highlighter-rouge">??</code> 는 연산자 앞의 값이 null이나 undefined라면 연산자 뒤의 값을 사용하라는 의미의 연산이다.</li>
    </ul>
  </li>
  <li>
    <p>createRandomPerson.ts</p>

    <ul>
      <li>
        <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="kd">type</span> <span class="p">{</span><span class="nx">IPerson</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./IPerson</span><span class="dl">'</span>
<span class="k">import</span> <span class="o">*</span> <span class="k">as</span> <span class="nx">F</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./faker</span><span class="dl">'</span>
<span class="k">import</span> <span class="o">*</span> <span class="k">as</span> <span class="nx">U</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./util</span><span class="dl">'</span>
    
<span class="k">export</span> <span class="kd">const</span> <span class="nx">createRandomPerson</span> <span class="o">=</span> <span class="p">():</span> <span class="nx">IPerson</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">anme</span> <span class="o">=</span> <span class="nx">F</span><span class="p">.</span><span class="nx">randomName</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="na">id</span><span class="p">:</span> <span class="nx">F</span><span class="p">.</span><span class="nx">randomId</span><span class="p">()</span>
        <span class="na">createdDate</span><span class="p">:</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">,</span>
        <span class="p">...</span>
        <span class="na">counts</span><span class="p">:</span> <span class="p">{</span>
        	<span class="na">comment</span><span class="p">:</span> <span class="nx">U</span><span class="p">.</span><span class="nx">random</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span>
            <span class="na">retweet</span><span class="p">:</span> <span class="nx">U</span><span class="p">.</span><span class="nx">random</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span>
            <span class="na">heart</span><span class="p">:</span> <span class="nx">U</span><span class="p">.</span><span class="nx">random</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
    	<span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>이제 그럴 듯한 가짜 데이터를 가진 IPerson 타입 객체는 createRandomPerson 함수를 호출하면 얻을 수 있게 되었다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p>그리고 위와 같이 src/data 디렉터리의 파일을 사용하는 코드의 import 문을 간결하게 하고자 index.ts 파일을 다음처럼 작성한다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="o">*</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./util</span><span class="dl">'</span>
<span class="k">export</span> <span class="o">*</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./faker</span><span class="dl">'</span>
<span class="k">export</span> <span class="o">*</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./IPerson</span><span class="dl">'</span>
<span class="k">export</span> <span class="o">*</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./createRandomPerson</span><span class="dl">'</span>
</code></pre></div></div>

<p>그래서 <code class="language-plaintext highlighter-rouge">import * as D from './src/data'</code>를 하면 위 파일을 모두 import 할 수 있게 된다.</p>

<p><br /></p>

<p>이렇게 만든 객체는 JSX에서 사용할 때는 <code class="language-plaintext highlighter-rouge">&lt;Text&gt;JSON.stringify(person, null, 2)&lt;/Text&gt;</code>와 같이 문자열로 변환하여 사용해야 하는데 이는 XML 구문에서 자식 요소는 문자열이거나 XML 요소여야 하기 때문이다.</p>

<p>그래서 JSON.stringify(객체, null, 2) 함수를 사용하여 2개의 공백 문자를 속성값에 붙여 보기 좋게 출력 되도록 한다.</p>

<p><br /></p>

<h2 id="리액트-네이티브가-제공하는-두-가지-서비스">리액트 네이티브가 제공하는 두 가지 서비스</h2>

<ol>
  <li>코어 컴포넌트
    <ul>
      <li>View, Text</li>
      <li>화면에 어떤 내용을 렌더링 해야 할 때</li>
    </ul>
  </li>
  <li>API
    <ul>
      <li>Platform, Alert</li>
      <li>폰의 하드웨어나 운영체제가 제공하는 기능이 필요할 때</li>
    </ul>
  </li>
</ol>

<h3 id="사용자-컴포넌트">사용자 컴포넌트</h3>

<p>컴포넌트: UI를 담당하는 클래스</p>

<p>리액트 네이티브 프레임워크에서는 객체지향 방식인 클래스 컴포넌트를 사용했다.</p>

<p>하지만 그 이후 단순히 함수로 구현할 수 있는 함수 컴포넌트(Function Component)가 도입되었고 최근 리액트 훅 기능이 새로 도입되면서 근래에는 이 함수 컴포넌트와 리액트 훅을 사용할 것을 장려한다.</p>

<ul>
  <li>리액트 훅은 함수 컴포넌트에서만 사용 가능</li>
</ul>

<p><br /></p>

<p><strong>사용자 컴포넌트</strong>: 리액트 네이티브가 제공하는 코어 컴포넌트를 화면에 렌더링해야 한다.</p>

<ul>
  <li>또한 앱 사용자의 화면 터치나 텍스트 입력 등을 이벤트 형태로 얻어 이에 따른 적절한 내용을 코어 컴포넌트에 알려 화면에 반영하는 일도 해야 한다.</li>
</ul>

<p><br /></p>

<h3 id="클래스-컴포넌트-만들기">클래스 컴포넌트 만들기</h3>

<p>함수 컴포넌트를 주요 사용할 것이기 때문에 이 부분은 그렇게 중요하게 다루지 않아도 된다.</p>

<p>클래스 컴포넌트는 반드시 react 패키지가 제공하는 Component 클래스를 상속해야 한다.</p>

<p>그런데 컴포넌트를 제작하는 목적이 <strong>코어 컴포넌트</strong>를 화면에 렌더링하는 일이므로 리액트와 리액트 네이티브는 클래스 컴포넌트가 <strong>render라는 이름의 메서드</strong>를 가져야 한다고 강제한다</p>

<ul>
  <li>render 메서드가 반환하는 것은 다음으로 제한된다.
    <ul>
      <li>null</li>
      <li>undefiend</li>
      <li>React.createElement 호출로 얻은 반환값</li>
      <li>JSX 문</li>
    </ul>
  </li>
  <li>
    <p>사용 형식</p>

    <ul>
      <li>
        <p>ClassComponent.tsx</p>

        <ul>
          <li>
            <div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span><span class="nx">Component</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span><span class="nx">Text</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react-native</span><span class="dl">'</span>
<span class="k">import</span> <span class="o">*</span> <span class="k">as</span> <span class="nx">D</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">../data</span><span class="dl">'</span>
      
<span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="nx">D</span><span class="p">.</span><span class="nx">createRandomPerson</span><span class="p">()</span>
<span class="k">export</span> <span class="k">default</span> <span class="kd">class</span> <span class="nx">ClassComponent</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
    <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">&lt;</span><span class="nc">Text</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="p">&lt;/</span><span class="nc">Text</span><span class="p">&gt;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
      <li>
        <p>App.tsx</p>

        <ul>
          <li>
            <div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span><span class="nx">SafeAreaView</span><span class="p">,</span> <span class="nx">Text</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react-native</span><span class="dl">'</span>
<span class="k">import</span> <span class="nx">ClassCompnenet</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./src/screen/ClassComponent</span><span class="dl">'</span>
      
<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="p">&lt;</span><span class="nc">SafeAreaView</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nc">ClassComponent</span> <span class="p">/&gt;</span>
        <span class="p">&lt;/</span><span class="nc">SafeAreaView</span><span class="p">&gt;</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="화살표-방식-함수-컴포넌트-만들기">(화살표 방식) 함수 컴포넌트 만들기</h3>

<p>보통 속성이 없는 컴포넌트는 function 키워드를 사용하여 작성하는 것이 편리하고 속성이 있는 경우 화살표 함수로 만드는 것이 편리하다.</p>

<p>우리가 앞서 작성했던 App.tsx 에서는 function 키워드만을 사용했는데 App 컴포넌트에는 속성이 없었기 때문이었다.</p>

<ul>
  <li>
    <p>사용 형식</p>

    <ul>
      <li>
        <p>ClassComponent.tsx</p>

        <ul>
          <li>
            <div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span><span class="nx">Component</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span><span class="nx">Text</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react-native</span><span class="dl">'</span>
<span class="k">import</span> <span class="o">*</span> <span class="k">as</span> <span class="nx">D</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">../data</span><span class="dl">'</span>
      
<span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="nx">D</span><span class="p">.</span><span class="nx">createRandomPerson</span><span class="p">()</span>
<span class="k">export</span> <span class="k">default</span> <span class="nx">ArrowComponent</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">&lt;</span><span class="nc">Text</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="p">&lt;/</span><span class="nc">Text</span><span class="p">&gt;</span>
<span class="p">}</span>
<span class="k">export</span> <span class="k">default</span> <span class="nx">ArrowComponent</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
      <li>
        <p>App.tsx</p>

        <ul>
          <li>
            <div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span><span class="nx">SafeAreaView</span><span class="p">,</span> <span class="nx">Text</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react-native</span><span class="dl">'</span>
<span class="k">import</span> <span class="nx">ClassCompnenet</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./src/screen/ArrowComponent</span><span class="dl">'</span>
      
<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="p">&lt;</span><span class="nc">SafeAreaView</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nc">ArrowComponent</span> <span class="p">/&gt;</span>
        <span class="p">&lt;/</span><span class="nc">SafeAreaView</span><span class="p">&gt;</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>클래스 컴포넌트
    <ul>
      <li>Component 클래스를 사용해야 하고 render 메소드를 구현해야 하는 등 이것저것 알고 있어야 할 것이 많다.</li>
    </ul>
  </li>
  <li>함수 컴포넌트
    <ul>
      <li>단순히 JSX 구문을 반환한다는 정도만 알면 충분하다.</li>
    </ul>
  </li>
</ul>

<p>따라서 함수 컴포넌트가 클래스 컴포넌트보다 만들기 더 편하다.</p>

<p><br /></p>

<h3 id="속성이란">속성이란?</h3>

<ul>
  <li><strong>클래스의 멤버 변수</strong></li>
</ul>

<p>리액트 네이티브는 컴포넌트의 속성이 바뀌면 이를 즉각 화면에 반영해야 한다.</p>

<p>리액트와 리액트 네이티브에서는 바뀐 속성값을 화면에 반영하는 것을 <strong>재렌더링</strong>한다고 한다.</p>

<p>따라서 속성이란 <code class="language-plaintext highlighter-rouge">클래스 속성 + 재렌더링</code>을 의미한다.</p>

<p><br /></p>

<h3 id="jsx-속성-설정-구문">JSX 속성 설정 구문</h3>

<p>JSX는 XML이기 때문에 모든 속성은 따옴표(“ “ 혹은 ‘ ‘)로 감싸야 한다.</p>

<p>이에 따라 string 타입과 달리 age와 같은 number 타입은 string으로 되면 안되기 때문에 중괄호 기호로 감싸준다. (ex. age={23})</p>

<ul>
  <li>또한 객체 ({}로 묶여져 있는 형태의 구조) 도 { }안에 넣어준다.</li>
</ul>

<p><br /></p>

<h3 id="속성을-왜-사용해">속성을 왜 사용해?</h3>

<p>앞의 ArrowComponent.tsx는 person이란 변수에 담긴 데이터를 화면에 렌더링 한다.</p>

<p>그런데 person 부분을 ArrowComponent.tsx가 아닌 App.tsx 쪽에 아래와 같이 구현하고 싶다고 하면 즉, 부모 컴포넌트 App의 데이터를 자식 컴포넌트 ArrowComponent 쪽으로 전달하고 싶다고 하면,</p>

<p><mark>속성은 이처럼 부모 컴포넌트가 자식 컴포넌트 쪽으로 데이터를 전달하고 싶을 때 사용한다.</mark></p>

<h2 id="함수-컴포넌트의-타입">함수 컴포넌트의 타입</h2>

<p>속성을 가진 함수 컴포넌트를 만들려면 먼저 함수 컴포넌트의 타입을 알아야 한다.</p>

<p><br /></p>

<p>초반에 배웠던 createElement 함수 정의를 보면 FunctionComponent&lt;p&gt; 와 ComponentClass&lt;p&gt; 라는 제네릭 타입을 볼 수 있다.</p>

<p>여기서 타입 변수 p는 Property의 첫 글자이다.</p>

<p>그런데 FunctionComponent는 이름이 너무 길므로 react 패키지는 좀 더 간결한 이름인 FC 타입을 제공한다.</p>

<p>결론적으로 FunctionComponent는 FC 타입이라고 하고 함수 컴포넌트의 타입은 FC이다.</p>

<p><br /></p>

<h2 id="import-type-구문">import type 구문</h2>

<p>타입스크립트 3.8 버전에 새로 등장한 import type 구문에 대해 알아보자</p>

<p>다음 코드에서 FC 타입은 import type 구문을 사용하지만 Component 클래스는 단순히 import 구문을 사용한다.</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">type</span> <span class="p">{</span><span class="nx">FC</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span><span class="nx">Component</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span>
</code></pre></div></div>

<p>타입은 타입스크립트가 코드를 자바스크립트로 컴파일 할 때만 필요한 정보이다. 타입스크립트 코드가 자바 스크립트 코드로 컴파일 되고 나면 타입 관련 내용은 자바스크립트 코드에서는 완전히 사라진다.</p>

<p>이와 달리 클래스는 물리적으로 동작하는 메소드와 속성을 가지기 때문에 자바스크립트 코드로 변환해도 컴파일된 형태 그 자체 그대로 남아있다.</p>

<p>이러한 이유로 앞 코드에서 FC는 컴파일하면 사라지는 정보이기 때문에 import type 구문을 사용한다.</p>

<p>정리하면 import type을 사용하는 이유는 다음과 같다.</p>

<ul>
  <li>FC와 같이 타입스크립트 컴파일 때만 필요한 타입을 명시하기 위해</li>
</ul>

<p><br /></p>

<h2 id="함수-컴포넌트-구현하기-by-using-typescript">함수 컴포넌트 구현하기 by using Typescript</h2>

<ul>
  <li>&lt;Person person={person} /&gt; 형태의 코드가 가능하도록 Person 컴포넌트에 person 속성을 만드는 것을 목표로 한다.</li>
</ul>

<p><br /></p>

<ul>
  <li>
    <p>person 속성</p>

    <ul>
      <li>
        <div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span><span class="nx">Component</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span><span class="nx">Text</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react-native</span><span class="dl">'</span>
<span class="k">import</span> <span class="o">*</span> <span class="k">as</span> <span class="nx">D</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">../data</span><span class="dl">'</span>
    
<span class="k">export</span> <span class="nx">type</span> <span class="nx">PersonProps</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">person</span><span class="p">:</span> <span class="nx">D</span><span class="p">.</span><span class="nx">IPerson</span>
<span class="p">}</span>
<span class="kd">const</span> <span class="nx">Person</span><span class="p">:</span> <span class="nx">FC</span><span class="o">&lt;</span><span class="nx">PersonProps</span><span class="o">&gt;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>Person 컴포넌트의 함수 몸통</p>

    <ul>
      <li>
        <p>Person 컴포넌트의 함수 몸통은 1번방식으로 구현할 수 있지만 코드가 길기 때문에 <code class="language-plaintext highlighter-rouge">매개변수에 적용하는 비구조화 할당 구문</code>을 적용하여 2번과 같이 구현을 한다.</p>
      </li>
      <li>
        <div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Person</span><span class="p">:</span> <span class="nx">FC</span><span class="o">&lt;</span><span class="nx">PersonProps</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">{</span><span class="nx">person</span><span class="p">}</span> <span class="o">=</span> <span class="nx">props</span>
    <span class="k">return</span> <span class="p">&lt;</span><span class="nc">Text</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="p">&lt;/</span><span class="nc">Text</span><span class="p">&gt;</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Person</span><span class="p">:</span> <span class="nx">FC</span><span class="o">&lt;</span><span class="nx">PersonProps</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">({</span><span class="nx">person</span><span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">&lt;</span><span class="nc">Text</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="p">&lt;/</span><span class="nc">Text</span><span class="p">&gt;</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>합친 코드</p>

    <ul>
      <li>
        <div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span><span class="nx">Component</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span><span class="nx">Text</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react-native</span><span class="dl">'</span>
<span class="k">import</span> <span class="o">*</span> <span class="k">as</span> <span class="nx">D</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">../data</span><span class="dl">'</span>
    
<span class="k">export</span> <span class="nx">type</span> <span class="nx">PersonProps</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">person</span><span class="p">:</span> <span class="nx">D</span><span class="p">.</span><span class="nx">IPerson</span>
<span class="p">}</span>
<span class="kd">const</span> <span class="nx">Person</span><span class="p">:</span> <span class="nx">FC</span><span class="o">&lt;</span><span class="nx">PersonProps</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">({</span><span class="nx">person</span><span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">&lt;</span><span class="nc">Text</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="p">&lt;/</span><span class="nc">Text</span><span class="p">&gt;</span>
<span class="p">}</span>
<span class="k">export</span> <span class="k">default</span> <span class="nx">Person</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<p>이를 통해 &lt;Person person={person} /&gt;와 같이 Person 컴포넌트에게 person 속성을 전달할 수 있게 되었다.</p>

<p><br /></p>

<h2 id="scrollview-코어-컴포넌트와-key-속성">ScrollView 코어 컴포넌트와 Key 속성</h2>

<p>데이터를 한 화면 안에 모두 볼 수 없을 때 스크롤 기능이 있어야 하는데 리액트 네이티브에서는 ScrollView 코어 컴포넌트를 제공한다.</p>

<p>그래서 위에서 만든 Person 컴포넌트를 여러개 만들어서 보려고 하려면 Person 컴포넌트를 이 ScrollView의 자식 컴포넌트로 만들면 ScrollView가 제공하는 스크롤 기능을 이용해 모든 Person 컴포넌트를 볼 수 있다.</p>

<p>다음 App.tsx는 100개의 D.IPerson 타입 객체를 만들어 people 변수에 저장한다. 그리고 Person 컴포넌트 100개를 만들어 각 Person 컴포넌트의 person 속성에 D.IPerson 타입 객체를 전달한다.</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">Children</span><span class="p">,</span> <span class="nx">Component</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">SafeAreaView</span><span class="p">,</span> <span class="nx">ScrollView</span><span class="p">,</span> <span class="nx">Text</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react-native</span><span class="dl">"</span>
<span class="k">import</span> <span class="nx">ClassComponent</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./src/screens/ClassComponent</span><span class="dl">"</span>
<span class="k">import</span> <span class="nx">ArrowComponent</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./src/screens/ArrowComponent</span><span class="dl">"</span>
<span class="k">import</span> <span class="o">*</span> <span class="k">as</span> <span class="nx">D</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./src/data</span><span class="dl">'</span>
<span class="k">import</span> <span class="nx">Person</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./src/screens/Person</span><span class="dl">"</span>

<span class="c1">//const person = D.createRandomPerson()</span>
<span class="kd">const</span> <span class="nx">people</span> <span class="o">=</span> <span class="nx">D</span><span class="p">.</span><span class="nx">makeArray</span><span class="p">(</span><span class="mi">100</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">D</span><span class="p">.</span><span class="nx">createRandomPerson</span><span class="p">)</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">children</span> <span class="o">=</span> <span class="nx">people</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">person</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span>
    <span class="p">&lt;</span><span class="nc">Person</span> <span class="na">key</span><span class="p">=</span><span class="si">{</span><span class="nx">person</span><span class="p">.</span><span class="nx">id</span><span class="si">}</span> <span class="na">person</span><span class="p">=</span><span class="si">{</span><span class="nx">person</span><span class="si">}</span> <span class="p">/&gt;</span>
  <span class="p">))</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;</span><span class="nc">SafeAreaView</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nc">ScrollView</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">children</span><span class="si">}</span><span class="p">&lt;/</span><span class="nc">ScrollView</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nc">SafeAreaView</span><span class="p">&gt;</span>
  <span class="p">)</span>
<span class="p">}</span>
<span class="c1">//const person = D.createRandomPerson()</span>
<span class="c1">//&lt;Text&gt;{JSON.stringify(person, null, 2)}&lt;/Text&gt;</span>
</code></pre></div></div>

<p>person.id라는 속성을 추가한 이유</p>

<ul>
  <li>앞서 <code class="language-plaintext highlighter-rouge">데이터 배열을 컴포넌트의 배열로 만들기</code> 화면에서 ‘Each child in a list have a unique “key”…’ 라는 경고 메시지가 나왔는데 이유는 다음과 같다.
    <ul>
      <li>모든 리액트, 리액트 네이티브 컴포넌트는 <strong>key</strong>, children, ref 등 3개 속성을 <strong>기본적</strong>으로 가진다.</li>
      <li>이 중 key 속성은 리액트 프레임워크가 컴포넌트의 렌더링 속도를 최적화 하는 데 필요한 속성이다.</li>
      <li>해당 경고는 모든 자식 컴포넌트는 구분할 수 있는 키값을 가져야 한다. 라는 뜻이다.</li>
      <li>그래서 리액트 네이티브로 하여금 여러 컴포넌트 (위에서는 Person) 을 구분할 수 있도록 key 속성에 person.id 값을 설정한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="컴포넌트의-이벤트-속성">컴포넌트의 이벤트 속성</h2>

<p>사용자가 버튼을 터치하거나 텍스트를 입력했을 때 발생하는 이벤트를 처리하는 방법을 알아보자</p>

<p><br /></p>

<h3 id="이벤트-속성">이벤트 속성</h3>

<ul>
  <li>리액트 네이티브 속성 중에는 onPress, onChangeText처럼 이름에 항상 ‘on~’이란 접두사가 붙는 속성이 있는데 이를 <strong>이벤트 속성</strong>이라고 한다.</li>
  <li>이 이벤트 속성에는 항상 <strong>콜백 함수</strong>를 설정해야 하는데, 이를 이벤트 <code class="language-plaintext highlighter-rouge">콜백 함수</code> 또는 <code class="language-plaintext highlighter-rouge">이벤트 처리기</code>라고 한다.</li>
</ul>

<p><br /></p>

<h3 id="button-코어-컴포넌트">Button 코어 컴포넌트</h3>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="nc">Button</span> <span class="na">title</span><span class="p">=</span><span class="s">"home"</span> <span class="na">color</span><span class="p">=</span><span class="s">"blue"</span> <span class="na">onPress</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">home pressed.</span><span class="dl">'</span><span class="p">)</span><span class="si">}</span> <span class="p">/&gt;</span>
</code></pre></div></div>

<ul>
  <li>Button 코어 컴포넌트의 속성
    <ul>
      <li>onPress</li>
      <li>title -&gt; 반드시 설정해야 함</li>
      <li>color</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="alert-api">Alert API</h3>

<p>API: Application Programming Interface의 약자로 리액트 네이티브에서 API는 JSX 구문에서 사용되는 <strong>코어 컴포넌트</strong>와는 달리 타입스크립트 코드에서 사용하는 <strong>기능</strong>을 의미한다.</p>

<ul>
  <li>
    <p>정적 메서드인 alert() 를 제공</p>

    <ul>
      <li>static alert(타이틀, 메시지)</li>
    </ul>
  </li>
  <li>
    <div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">return</span> <span class="p">(</span>
	<span class="p">&lt;</span><span class="nc">SafeAreaView</span><span class="p">&gt;</span>
    	<span class="p">&lt;</span><span class="nc">Button</span> <span class="na">title</span><span class="p">=</span><span class="s">'home'</span>
            <span class="na">onPress</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">Alert</span><span class="p">.</span><span class="nx">alert</span><span class="p">(</span><span class="dl">'</span><span class="s1">home pressed.</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">message</span><span class="dl">'</span><span class="p">)</span><span class="si">}</span> <span class="p">/&gt;</span>
    <span class="p">&lt;/</span><span class="nc">SafeAreaView</span><span class="p">&gt;</span>
<span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><br /></p>

<h3 id="터처블-코어-컴포넌트">터처블 코어 컴포넌트</h3>

<p>그런데 Button이 가지는 한가지 문제점은 디자인에 융통성이 없다는 것이다. 때문에 리액트 네이티브는 접두어 ‘Touchable~’이 붙는 다음 두 가지 코어 컴포넌트를 제공한다.</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span><span class="nx">TouchableOpacity</span><span class="p">,</span> <span class="nx">TouchableHighlight</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react-native</span><span class="dl">'</span>
</code></pre></div></div>

<p>이 두 컴포넌트의 특징은 다음 2가지로 요약할 수 있다.</p>

<p>1) 컴포넌트 영역에 터치가 일어나면 onPress 이벤트 속성에 설정된 이벤트 핸들러 콜백 함수를 호출한다.
2) 단 한 개의 자식 컴포넌틈만 올 수 있다.</p>

<p><br /></p>

<ul>
  <li>TouchableOpacity: 터치가 일어나면 컴포넌트 바탕색의 투명도를 바꾸는 방식으로 효과를 줌.</li>
</ul>

<p>사실 Text 컴포넌트도 onPress 이벤트 속성을 제공한다.</p>

<p><br /></p>

<h3 id="textinput-코어-컴포넌트">TextInput 코어 컴포넌트</h3>

<ul>
  <li>
    <p>TextInput 코어 컴포넌트의 특징</p>

    <ol>
      <li>
        <p>defaultValue 속성에 초깃값을 설정할 수 있다.</p>
      </li>
      <li>
        <p>입력된 텍스트는 value 속성값으로 얻을 수 있다.</p>
      </li>
      <li>
        <p>텍스트가 입력될 때 <strong>onChangeText</strong> 이벤트 처리기를 실행한다.</p>
      </li>
      <li>
        <p>placeholder 속성을 사용하여 어떤 값을 설정해야 하는지 문자열로 출력할수 있다.</p>
      </li>
      <li>
        <p>editable 속성값에 false를 설정하면 입력을 못하게(disable)할 수 있다.</p>
      </li>
      <li>
        <p>keyboardType 속성에 ‘default’, ‘numeric’, ‘email-address’등의 값을 설정할 수 있다.</p>
      </li>
      <li>
        <p>포커스를 가지게 하는 focus 메서드와 포커스를 잃게 하는 blur 메서드가 있다.</p>
      </li>
      <li>
        <p>텍스트를 입력할 수 있는 상태(포커스를 가진 상태)가 되면 onFocus 이벤트를 호출하고 텍스트를 입력할 수 없는 상태(포커스를 잃은 상태) 가 되면 onBlur 이벤트를 호출한다.</p>
      </li>
      <li>
        <p>텍스트 입력이 모두 끝나면 onEndEditing 이벤트를 호출한다.</p>
      </li>
      <li>
        <p>자식 요소를 가지지 못한다.</p>
      </li>
    </ol>
  </li>
</ul>

<p>onChangeText 속성에 설정할 수 있는 콜백 함수는 다음과 같은 함수 시그니처(function signature)를 가진다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>함수 시그니처
onchangeText(text: string) =&gt; void
</code></pre></div></div>

<ul>
  <li>함수 시그니처:
    <ul>
      <li>타입스크립트 언어에서 모든 변수는 어떤 타입을 가진다. 그리고 함수도 어떤 타입을 가진다.</li>
      <li>여기서 함수 선언문에서 함수 이름만 제외한 부분을 함수 타입, 즉 함수 시그니처라 한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>
    <p>onFocus와 onBlur, onEndEditing에는 아무런 매개변수도 없는 콜백 함수를 설정한다. 다음 코드는 TextInput의 전형적인 사용 예이다.</p>

    <ul>
      <li>
        <div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">SafeAreaView</span><span class="p">,</span> <span class="nx">Alert</span><span class="p">,</span> <span class="nx">Button</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react-native</span><span class="dl">"</span>
<span class="k">import</span> <span class="p">{</span><span class="nx">TouchableOpacity</span><span class="p">,</span> <span class="nx">TouchableHighlight</span><span class="p">,</span> <span class="nx">Text</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react-native</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span><span class="nx">TextInput</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react-native</span><span class="dl">'</span>
    
<span class="kd">const</span> <span class="nx">onPress</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">Alert</span><span class="p">.</span><span class="nx">alert</span><span class="p">(</span><span class="dl">'</span><span class="s1">home pressed.</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">message</span><span class="dl">'</span><span class="p">)</span>
    
<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;</span><span class="nc">SafeAreaView</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nc">Button</span> <span class="na">title</span><span class="p">=</span><span class="s">'home'</span> <span class="na">onPress</span><span class="p">=</span><span class="si">{</span><span class="nx">onpress</span><span class="si">}</span> <span class="p">/&gt;</span>
      <span class="p">&lt;</span><span class="nc">TouchableOpacity</span> <span class="na">onPress</span><span class="p">=</span><span class="si">{</span><span class="nx">onpree</span><span class="si">}</span><span class="p">&gt;</span>
      	<span class="p">&lt;</span><span class="nc">Text</span><span class="p">&gt;</span>TouchableOpcity<span class="p">&lt;/</span><span class="nc">Text</span><span class="p">&gt;</span>    
      <span class="p">&lt;/</span><span class="nc">TouchableOpacity</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nc">TouchableHighlight</span> <span class="na">onPress</span><span class="p">=</span><span class="si">{</span><span class="nx">onpree</span><span class="si">}</span><span class="p">&gt;</span>
      	<span class="p">&lt;</span><span class="nc">Text</span><span class="p">&gt;</span>TouchableHighlight<span class="p">&lt;/</span><span class="nc">Text</span><span class="p">&gt;</span>    
      <span class="p">&lt;/</span><span class="nc">TouchableHighlight</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nc">TextInput</span>
          <span class="na">placeholder</span><span class="p">=</span><span class="s">"enter your name"</span>
          <span class="na">onChangeText</span><span class="p">=</span><span class="si">{</span><span class="p">(</span><span class="nx">text</span><span class="p">:</span> <span class="nx">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span><span class="si">}</span>
          <span class="na">onFocus</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">onFocus</span><span class="dl">'</span><span class="p">)</span><span class="si">}</span>
          <span class="na">onBlur</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">onBlur</span><span class="dl">'</span><span class="p">)</span><span class="si">}</span>
          <span class="na">onEndEditing</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">onEndEditing</span><span class="dl">'</span><span class="p">)</span><span class="si">}</span>
          <span class="p">/&gt;</span>
    <span class="p">&lt;/</span><span class="nc">SafeAreaView</span><span class="p">&gt;</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>이 코드는 TextInput을 터치하여 포커스를 가지게 한 것이다. TextInput이 포커스를 가지면 화면 아래에서 위쪽으로 키보드가 올라온다.</p>
      </li>
      <li>
        <p>메트로 서버를 실행하고 에뮬레이터에서 해당 코드가 실행되면 아래의 과정이 이루어 짐을 알 수 있게 된다.</p>

        <ul>
          <li>TextInput을 터치하면 onFocus 이벤트가 발생한다.</li>
          <li>‘Hello’를 입력하는 동안 onChangeText 이벤트가 5번 발생하고 현재 TextInput에 표시한 텍스트를 출력한다.</li>
          <li>그리고 ‘Enter’ 입력은 onEndEditing 이벤트를 발생시킨다.</li>
          <li>화면 다른 곳을 터치하면 TextInput은 포커스를 잃게 되어 onBlur 이벤트가 발생한다.</li>
        </ul>
      </li>
      <li>
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>onFocus
H
He
Hel
Hell
Hello
onEndEditing
onBlur
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

:ET