I"S<p>이번 시간에는 위상정렬에 대해서 배워 보도록 할 것이다.</p>

<p><br /></p>

<h3 id="위상-정렬이란">위상 정렬이란?</h3>

<p>어떤 일을 하는 순서를 찾는 알고리즘으로 <strong>방향 그래프</strong>에 존재하는 각 정점들의 선행 순서를 위배하지 않으면서 모든 정점(vertex)을 나열하는 것이다.</p>

<p>그래프가 DAG가 아닌 경우 그래프에 대한 위상 정렬은 불가능하다.</p>

<ul>
  <li><mark>비순환 방향 그래프</mark>(DAG: Directed Acyclic Graph)에서 정점을 선형으로 정렬하는 것(순서대로 출력)</li>
  <li>순서가 있는 task에서 순서를 찾아주는 알고리즘</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/79521972/154828367-4d066c12-3d7c-4455-9f2c-56e4c5d1acfe.png" alt="image" /></p>

<p>그래프 방문 결과가 <u>순서대로</u> 출력 되어야 하기 때문에 그래프의 <code class="language-plaintext highlighter-rouge">시작 지점</code>과 <code class="language-plaintext highlighter-rouge">방향</code>이 존재해야 하기 때문에 그래프에 cycle이 있으면 위상 정렬로 sorting하는 것이 불가능함.</p>

<p>리스트와 같은 경우 그 자체가 순서이지만 그래프처럼 비선형적(non-linear)이지만 순서가 있는 구조에서는 이 순서를 찾아주는 알고리즘 자체를 의미.</p>

<p><br /></p>

<p><strong>위상 정렬 예시</strong>로는 대학교 선수과목이 있다.</p>

<p><img src="https://user-images.githubusercontent.com/79521972/155874457-ed6a26af-c1d0-438c-8840-d47ff1d64576.png" alt="image" /></p>

<p>위 그림은 우리 과의 선수과목 이수 체계도를 나타낸 것이며 여기서 특정 수강과목에 선수과목이 있다면 그 선수과목부터 수강을 해야 한다. 여기서 위상 정렬은 특정 수강과목을 위해 필요한 선수과목의 정렬이다.</p>

<p><br /></p>

<p>이 외에도 컴파일 작업순서 결정, git과 같은 버전 히스토리 관리, 교착 상태 탐지 등이 위상 정렬을 사용한다.</p>

<p><br /></p>

<h3 id="구현-방법">구현 방법</h3>

<h4 id="in-degree-방법bfs-방식">In-degree 방법(BFS 방식)</h4>

<p>[<strong>동작 방식</strong>]</p>

<ol>
  <li>모든 정점마다 in-degree 수를 설정한다.</li>
  <li>
    <p>in-degree가 0인 정점은 방문한 것으로 표시하고 큐에 해당 정점을 추가한다.</p>
  </li>
  <li>큐가 빌 때까지 순회하며 다음 작업을 수행한다.
    <ul>
      <li>큐의 앞 요소를 dequeue()를 통해 가져와 리스트에 append한다.</li>
      <li>dequeue()한 정점에 인접 정점 중 방문하지 않은 정점의 indegree를 하나 감소시킨다.</li>
      <li>in-degree 감소 후 값이 0이면 해당 정점은 queue에 enqueue()하고 방문한 것으로 표시한다.</li>
    </ul>
  </li>
</ol>

<p><br /></p>

<p>그림으로 자세히 보자.</p>

<p><strong>Queue(큐) 사용</strong>: 진입 차수를 계산하며 sorting하는 방식</p>

<ul>
  <li>진입 차수(indegree) - 한 노드에 들어오는 다른 간선의 수</li>
</ul>

<ol>
  <li>모든 vertex의 indegree 수를 세기</li>
  <li>큐에 indegree가 0인 vertex를 삽입
    <ul>
      <li>자신을 향해 들어오는 edge가 없으면 출발 노드이기 때문</li>
    </ul>
  </li>
  <li>큐에서 vertex를 꺼내 연결된(나가는 방향, outdegree) edge 제거</li>
  <li>3번에서 indegree가 0이 된 vertex를 큐에 삽입(enqueue)</li>
  <li>큐가 빌 때까지 3~4 반복</li>
</ol>

<ul>
  <li>만약 cycle이 존재하는 그래프라면, 모든 노드를 돌기 전에 큐가 비기 때문에 정렬이 종료된다.</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/79521972/154829129-0e7c4668-9444-49ac-a354-a09a308cf880.png" alt="image" /></p>

<p><br /></p>

<h4 id="위상-정렬이-불가능한-경우"><strong>위상 정렬이 불가능한 경우</strong></h4>

<ul>
  <li>그래프 내 cycle이 존재하는경우(C &lt;-&gt; E)</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/79521972/154829825-13aa663c-b2a9-444e-bbc9-8cfdd5f8d1d7.png" alt="image" /></p>

<p>cycle에 속하는 vertex가 있다면 해당 vertex는 항상 진입차수 indegree 가 1 이상이기 때문에 큐에 삽입 될 수 없기 때문이다.</p>

<p><br /></p>

<ul>
  <li>처음부터 진입차수가 0인 vertex가 존재하지 않는 경우</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/79521972/154829828-a373751e-a74f-44d3-abbd-df7b2c7a6cda.png" alt="image" /></p>

<p>큐에 넣을 수 있는 vertex가 없기 때문에 위상 정렬이 불가능</p>

<p><br /></p>

<h3 id="stackdfs"><strong>stack(DFS)</strong></h3>

<p>[<strong>동작 방식</strong>]</p>

<p>DFS 방식에서는 in-degree를 사용하지 않고 재귀 혹은 스택을 사용한다.</p>

<ol>
  <li>모든 정점을 순회하면서 미방문 정점에 대해서 DFS를 수행한다.</li>
  <li>DFS 수행 방식
    <ul>
      <li>하나의 정점에서 시작한다.</li>
      <li>방문표시를 하면서 간선을 따라 다음 정점으로 방문한다.</li>
      <li>더이상 방문할 간선이 존재하지 않으면 리스트 맨 앞에 정점을 추가하고 백트래킹을 통해 이전 정점으로 되돌아가면서 미방문 간선이 있는지 체크한다.</li>
      <li>방문 가능한 간선이 만약 있다면 다시 간선을 따라서 다음 정점으로 이동한다.</li>
      <li>모든 정점을 탐색할 때까지 위 과정을 반복한다.</li>
    </ul>
  </li>
</ol>

<p><img src="https://user-images.githubusercontent.com/79521972/155874737-88d436c3-1166-433d-a9e8-8f8cd00b3ff2.png" alt="image" /></p>

<p><br /></p>

<p>이해를 위해 다음 그림을 보자.</p>

<ul>
  <li>DFS 역순으로 진행</li>
</ul>

<p>앞에서 진행했던 그래프와 동일한 그래프로 진행</p>

<p><img src="https://user-images.githubusercontent.com/79521972/154830182-402a77d4-8981-41e1-b66d-0f7ae5c8831a.png" alt="image" /></p>

<ol>
  <li><strong>시작은 동일하게 A vertex부터 시작</strong>
    <ul>
      <li>다음으로 이어지는 B나 C둘 중 어느 것이라도 상관 없지만 B로 선택</li>
    </ul>
  </li>
  <li><strong>A - B - D - F - E - G 순으로 방문</strong></li>
  <li><strong>이의 역순인 G - E- F - D - B 순으로 스택에 삽입</strong>
    <ul>
      <li>A노드는 아직 탐색할 노드(C)가 남아있기 때문에 스택에 삽입 하지는 않음</li>
    </ul>
  </li>
  <li><strong>A에서 C로 방문하기 때문에 이를 뒤집은 C -&gt; A순으로 스택에 삽입</strong></li>
  <li><strong>방문을 할 노드가 더 이상 남아있지 않다면 스택에 위에서 부터 순서대로 정렬이 된 것</strong>
    <ul>
      <li>A - C - B - D - F - E - G</li>
    </ul>
  </li>
</ol>

<p><img src="https://user-images.githubusercontent.com/79521972/154830147-3236a64b-3953-48af-82bf-0b0f02b23589.png" alt="image" /></p>

<p><br /></p>

<h3 id="위상-정렬-구현">위상 정렬 구현</h3>

<ul>
  <li>queue를 이용한 구현</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GraphAlogorithms</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Lists</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">bfs</span><span class="o">(</span><span class="n">iGraph</span><span class="o">,</span> <span class="kt">int</span> <span class="n">from</span><span class="o">)</span> <span class="o">{...}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">iGrpah</span><span class="o">,</span> <span class="kt">int</span> <span class="n">from</span><span class="o">)</span> <span class="o">{...}</span>
    
    <span class="c1">//queue를 이용한 방법</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">topologicalSortIndegree</span><span class="o">(</span><span class="nc">IGraph</span> <span class="n">graph</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//&lt;vertex, indegree 갯수&gt;</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">indegreeCounter</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">getIndegrees</span><span class="o">();</span> <span class="c1">//1</span>
        
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        
        <span class="nc">IQueue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyLinkdQueue</span><span class="o">&lt;&gt;();</span>
        
        <span class="c1">//2</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">graph</span><span class="o">.</span><span class="na">getVertexes</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">indegreeCounter</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
            
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">nn</span> <span class="o">:</span> <span class="n">graph</span><span class="o">.</span><span class="na">getNodes</span><span class="o">(</span><span class="n">node</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">indegreeCounter</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">nn</span><span class="o">))</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">indegreeCounter</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nn</span><span class="o">);</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">nn</span><span class="o">);</span>
                    <span class="o">}</span>
                    <span class="n">indegreeCounter</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nn</span><span class="o">,</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>    
<span class="o">}</span>
</code></pre></div></div>

<p>parameter: 그래프 타입</p>

<p>return 타입: List &lt; Integer&gt;</p>

<ol>
  <li>
    <p>모든 vertex의 indegree 수를 세기</p>
  </li>
  <li>큐에 indegree가 0인 vertex(시작 노드) 삽입
    <ul>
      <li>if문을 통해 indegree 가 0인 것만 큐에 삽입</li>
    </ul>
  </li>
  <li>큐에서 vertex를 꺼내 연결된(나가는 방향) edge 제거
    <ul>
      <li>시작 노드와 연결된 노드들을 하나씩 nn에 가져와 indegreecounter에 존재한다면 그 노드의 진입차수에 -1</li>
      <li>실제로 edge를 제거하게 되면 그 노드를 향한 진입차수 indegree가 1이 줄어드는 것이기 때문</li>
    </ul>
  </li>
  <li>3번에서 indegree(진입차수)가 0이 된 vertex를 큐에 삽입</li>
  <li>큐가 빌 때까지 3~4 반복</li>
</ol>

<p><br /></p>

<ul>
  <li>스택을 이용한 구현</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Stack 구현 </span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">topologicalSort</span><span class="o">(</span><span class="nc">IGraph</span> <span class="n">graph</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="nc">IStack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyStack</span><span class="o">&lt;&gt;();</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
    
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">vertexes</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">getVertexes</span><span class="o">();</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Integer</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">vertexes</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">vertex</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">//dfs</span>
            <span class="n">topologicalSort</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="n">vertex</span><span class="o">,</span> <span class="n">visited</span><span class="o">,</span> <span class="n">stack</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="k">while</span> <span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">topologicalSort</span><span class="o">(</span><span class="nc">IGraph</span> <span class="n">graph</span><span class="o">,</span> <span class="kt">int</span> <span class="n">vertex</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">visited</span><span class="o">,</span> <span class="nc">Istack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">visited</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">veretex</span><span class="o">);</span>
    
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">getNodes</span><span class="o">(</span><span class="n">vertex</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Integer</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nodes</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">n</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">topologicalSort</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">visisted</span><span class="o">,</span> <span class="n">stack</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">vertex</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>parameter: 탐색 그래프, vertex, visited, stack</p>

<ul>
  <li>result: 결과를 출력하기 위한 리스트</li>
  <li>stack: DFS 탐색 결과를 저장하기 위한 스택</li>
  <li>visited: 중복 방지를 위해 방문 정보를 저장하는 Set</li>
</ul>

<ol>
  <li>방문하지 않은 노드들에 한하여 dfs 탐색을 진행
    <ul>
      <li>노드와 연결된 노드들에 대하여 만약 방문했던 노드라면 방문하지 않고 방문하지 않은 경우에만 재귀 호출을 통해 DFS탐색을 계속해서 진행</li>
    </ul>
  </li>
  <li>DFS가 <strong>종료</strong>되었을 때 stack에 vertex를 삽입
    <ul>
      <li>이러한 순서로 vertex를 역순으로 스택에 삽입 가능</li>
      <li>만약 DFS 탐색을 하기 전 stack에 push를 한다면 시작 노드가 스택에 맨 처음에 삽입(정방향) 되는 경우가 생겨버림</li>
    </ul>
  </li>
  <li>스택이 빌 때까지 stack에 있는 데이터를 하나씩 출력</li>
</ol>

<p><br /></p>

<h2 id="관련된-post">관련된 Post</h2>

<ul>
  <li>자료 구조 <a href="https://speardragon.github.io/lecture/data%20structure%20and%20algorithms/algorithm/tree/Algorithm-CH7.-Tree(%ED%8A%B8%EB%A6%AC)/"><u>트리(Tree)</u></a></li>
  <li>자료 구조 <a href="https://speardragon.github.io/lecture/data%20structure%20and%20algorithms/algorithm/graph/Algorithm-CH9-1.-Graph(%EA%B7%B8%EB%9E%98%ED%94%84)/"><u>그래프(Graph)</u></a></li>
  <li><a href="https://speardragon.github.io/lecture/data%20structure%20and%20algorithms/algorithm/graph/Algorithm-CH9-2.-%EB%84%88%EB%B9%84-%EC%9A%B0%EC%84%A0-%ED%83%90%EC%83%89(BFS)(%EA%B7%B8%EB%9E%98%ED%94%84-%ED%83%90%EC%83%89)/"><u>너비 우선 탐색(BFS, Breath-First Search)</u></a></li>
  <li><a href="https://speardragon.github.io/lecture/data%20structure%20and%20algorithms/algorithm/graph/Algorithm-CH9-3.-%EA%B9%8A%EC%9D%B4-%EC%9A%B0%EC%84%A0-%ED%83%90%EC%83%89(DFS)(%EA%B7%B8%EB%9E%98%ED%94%84-%ED%83%90%EC%83%89)/"><u>깊이 우선 탐색(DFS, Depth-First Search)</u></a></li>
</ul>

:ET