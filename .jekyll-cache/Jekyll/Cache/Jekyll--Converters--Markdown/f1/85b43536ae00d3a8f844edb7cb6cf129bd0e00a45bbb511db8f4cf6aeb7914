I"/<p><br /></p>

<h2 id="multicycle-processor-performance">Multicycle Processor Performance</h2>

<ul>
  <li>Instructions take different number of cycles
    <ul>
      <li>3 cycles: beq, j</li>
      <li>4 cycles: R-Type, sw, addi</li>
      <li>5 cycles: lw</li>
    </ul>
  </li>
  <li>CPI is weighted average</li>
  <li>SPECINT2000 benchmark:
    <ul>
      <li>25% loads</li>
      <li>10% stores</li>
      <li>11% branches</li>
      <li>2% jumps</li>
      <li>52% R-type</li>
    </ul>
  </li>
</ul>

<p><strong>Average CPI</strong> = (0.11 + 0.02)(3) + (0.52 + 0.10)(4) + (0.25)(5) = 4.12</p>

<p><br /></p>

<p>Multicycle critical path: <strong>Tc</strong> = t<sub>pcq_ALUout</sub> + t<sub>mux </sub>+ max(t<sub>ALU</sub> + t<sub>mux</sub>, t<sub>mem</sub>) + t<sub>setup</sub></p>

<ul>
  <li>write ëŠ” readë³´ë‹¤ ì¡°ê¸ˆ ê±¸ë¦¬ê³ </li>
  <li>register fileì€ memoryë³´ë‹¤ ì¡°ê¸ˆ ê±¸ë¦°ë‹¤.(ë¹ ë¥´ë‹¤)</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/79521972/163916051-6231ccba-5a19-4015-8045-957effb91092.png" alt="image" /></p>

<p><br /></p>

<h2 id="multicycle--performance-example">Multicycle  Performance Example</h2>

<p><img src="https://user-images.githubusercontent.com/79521972/163916368-89f5b8ae-f402-4aae-840e-a70ea3fda7c7.png" alt="image" /></p>

<p><strong>Tc</strong> = t<sub>pcq_ALUout</sub> + t<sub>mux </sub>+ max(t<sub>ALU</sub> + t<sub>mux</sub>, t<sub>mem</sub>) + t<sub>setup</sub></p>

<p>= Tc = t<sub>pcq_ALUout</sub> + t<sub>mux </sub>+ t<sub>mem</sub> + t<sub>setup</sub></p>

<p>=  [30 + 25 + 250 + 20] ps</p>

<p>= 325 ps</p>

<p><br /></p>

<h2 id="ì¤‘ìš”í•œ-ì˜ì œì‹œí—˜ì—-ë‚˜ì˜´">ì¤‘ìš”í•œ ì˜ì œ(ì‹œí—˜ì— ë‚˜ì˜´)</h2>

<p>For a program with 100 billion instructions executing on a multicycle  MIPS processor</p>

<ul>
  <li>CPI = 4.12</li>
  <li>Tc = 325 ps
    <ul>
      <li>singleì—ì„œëŠ” 925ps ì˜€ëŠ”ë° clock cycleì„ 1/5 í•œ ê²ƒ ì¹˜ê³ ëŠ” ë„ˆë¬´ ê¸¸ë‹¤.</li>
      <li>ê·¸ ì´ìœ ëŠ”?</li>
    </ul>
  </li>
</ul>

<p>Execution Time</p>

<p>= (# instructions) Ã— CPI Ã— Tc</p>

<p>= (100 Ã— 109 )(4.12)(325 Ã— 10-12)</p>

<p>= 133.9 seconds</p>

<p>This is slower than the single-cycle processor (92.5 seconds). Why?</p>

<ol>
  <li>ì œì¼ ë§ì´ ê±¸ë¦¬ëŠ” ê²Œ clock cycleì„ ì •í•˜ëŠ”ë° clockì„ ì •í™•íˆ ì´ë¶„í•˜ê²Œ ë‚˜ëˆ„ì§€ ì•Šì•˜ë‹¤.
    <ul>
      <li>Not even balenced</li>
      <li>Not all steps same length</li>
    </ul>
  </li>
  <li>
    <p>ìë¥´ë‹¤ë³´ë©´ ë‹¤ìŒ cycleì— ê³„ì‚°í•˜ê¸° ìœ„í•´ ì €ì¥í•˜ê¸° ìœ„í•œ register(f/f)ê°€ ì¤‘ê°„ì¤‘ê°„ì— ë“¤ì–´ê°€ëŠ”ë° registerì—ì„œëŠ” t<sub>pcq</sub>, t<sub>setup</sub> ì´ë¼ëŠ” overheadë¡œ ì¸í•´ clockì´ ì •í™•í•˜ê²Œ 5ë°° ë¹¨ë¼ì§€ì§€ ëª»í•˜ëŠ” ê²ƒì´ë‹¤.</p>

    <ul>
      <li>
        <p>Sequencing overhead for each stop(t<sub>pcq</sub>+ t<sub>setup</sub> = 50 ps)</p>
      </li>
      <li>
        <p>ê·¸ë˜ì„œ CPIì—ì„œ ì†í•´ë³¸ ê²ƒì„ clock cylceì—ì„œ ê°ë‹¹í•  ìˆ˜ ì—†ì—ˆë‹¤.</p>
      </li>
    </ul>
  </li>
</ol>

<p>Q) ì–´ë–»ê²Œ ì´ë¶„í•˜ê²Œ ìª¼ê°œëŠ”ê°€</p>

<p>A) mipsëŠ” data memory ë•Œë¬¸ì— unbalenceê°€ ë°œìƒ</p>

<p><br /></p>

<h2 id="review-single-cycle-processor">Review: Single-Cycle Processor</h2>

<p><img src="https://user-images.githubusercontent.com/79521972/164953152-b0c467aa-821c-4e85-8013-0a2a29ae2a88.png" alt="image" /></p>

<h2 id="review-multicycle-processor">Review: Multicycle Processor</h2>

<p><img src="https://user-images.githubusercontent.com/79521972/163917275-c1874daa-15e7-4cf3-ba73-958731324b8c.png" alt="image" /></p>

<ul>
  <li>ì¥ì 
    <ul>
      <li>resource sharing(memory, ALU)</li>
      <li>faster clock</li>
    </ul>
  </li>
</ul>

:ET