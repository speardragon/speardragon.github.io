I"Ñ<p><br /></p>

<h1 id="111-ì‹œê·¸ë„">11.1 ì‹œê·¸ë„</h1>

<h2 id="introduction">Introduction</h2>

<ul>
  <li>Signals
    <ul>
      <li><strong>Software interrupts</strong> : ì†Œí”„íŠ¸ì›¨ì–´ í”„ë¡œê·¸ë˜ë°ì—ì„œ êµ‰ì¥íˆ ì¤‘ìš”í•œ ì´ë²¤íŠ¸</li>
      <li>provides a way of <strong>handling asynchronous events</strong>
        <ul>
          <li>í”„ë¡œì„¸ìŠ¤ê°€ ì‹¤í–‰ ì¤‘ê°„ì— ì˜ˆê¸°ì¹˜ ì•Šì€ ì‚¬ê±´ì´ ë°œìƒí•  ë•Œ ì´ë¥¼ ì•Œë¦¬ëŠ” ìˆ˜ë‹¨</li>
          <li>E.g. A user types the interrupt key to stop a program.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Signal name
    <ul>
      <li>Begins with â€œSIGâ€.
        <ul>
          <li>E.g. SIGABRT, SIGTERM, SIGALRM, â€¦</li>
        </ul>
      </li>
      <li>Is defined by positive integer constants in
        <ul>
          <li>E.g. #define SIGHUP 1</li>
          <li>Depends on architecture and OS.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p>CPU ë‚´ë¶€ì—ì„œ ë°œìƒí•˜ëŠ” interruptë¥¼ software interruptë¼ê³  í•œë‹¤.</p>

<p><br /></p>

<ul>
  <li>Examples of signal generation
    <ul>
      <li>When user press â€œCtrl-Câ€ on the terminal. (í‚¤ë³´ë“œë¡œë¶€í„° ì¢…ë£Œ ìš”ì²­)
        <ul>
          <li>Generates SIGINT signal.</li>
        </ul>
      </li>
      <li>When user press â€œCtrl-Zâ€ on the terminal. (í‚¤ë³´ë“œë¡œë¶€í„° ì •ì§€ ìš”ì²­)
        <ul>
          <li>Generates SIGSTP signal.</li>
        </ul>
      </li>
      <li>When executes an invalid memory references.
        <ul>
          <li>Generates SIGSEGV signal. (SEGmentation Violation)</li>
        </ul>
      </li>
      <li>When superuser want to kill a process.
        <ul>
          <li>Generates SIGKILL signal.</li>
        </ul>
      </li>
      <li>When a process writes to a pipe after the reader has terminated.
        <ul>
          <li>Generates SIGPIPE signal.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/79521972/169321229-8f21f8f9-6c32-4bd2-9bed-41c8b17cc1f0.png" alt="image" /></p>

<p><br /></p>

<h2 id="ì£¼ìš”-ì‹œê·¸ë„-usrincludesignalh">ì£¼ìš” ì‹œê·¸ë„ /usr/include/signal.h</h2>

<p><img src="https://user-images.githubusercontent.com/79521972/169321381-4b746527-f91f-4921-b740-d721b93bb23c.png" alt="image" /></p>

<h2 id="ì£¼ìš”-ì‹œê·¸ë„">ì£¼ìš” ì‹œê·¸ë„</h2>

<p><img src="https://user-images.githubusercontent.com/79521972/169321457-34c73c6c-c715-4eb0-8460-2905d138bfd5.png" alt="image" /></p>

<p><br /></p>

<h2 id="ì‹œê·¸ë„-ìƒì„±-ì´ìœ ">ì‹œê·¸ë„ ìƒì„± ì´ìœ </h2>

<ul>
  <li><strong>í„°ë¯¸ë„ì—ì„œ ìƒì„±ëœ ì‹œê·¸ë„</strong>
    <ul>
      <li>í‚¤ë³´ë“œë¡œë¶€í„° ì¸í„°ëŸ½íŠ¸ CTRL-C -&gt; SIGINT</li>
      <li>í‚¤ë³´ë“œë¡œë¶€í„° ì •ì§€ CTRL-Z -&gt; SIGSTP</li>
    </ul>
  </li>
  <li><strong>í•˜ë“œì›¨ì–´ ì˜ˆì™¸ê°€ ìƒì„±í•˜ëŠ” ì‹œê·¸ë„</strong>
    <ul>
      <li>0ìœ¼ë¡œ ë‚˜ëˆ„ê¸°  -&gt; SIGFPE</li>
      <li>ìœ íš¨í•˜ì§€ ì•ŠëŠ” ë©”ëª¨ë¦¬ ì°¸ì¡° -&gt; SIGSEGV</li>
      <li>ë¶€ë™ì†Œìˆ˜ì  ì˜¤ë¥˜ -&gt; SIGFPE</li>
      <li>ì •ì „ -&gt; SIGPWR</li>
      <li>Ilegal instruction ì‹¤í–‰,</li>
      <li>ì ‘ê·¼ ë¶ˆê°€ ë©”ëª¨ë¦¬ ì ‘ê·¼ -&gt; SIGSEGV</li>
    </ul>
  </li>
  <li><strong>kill() ì‹œìŠ¤í…œ í˜¸ì¶œ</strong>
    <ul>
      <li>í”„ë¡œì„¸ìŠ¤(ê·¸ë£¹)ì— ì‹œê·¸ë„ ë³´ë‚´ëŠ” ì‹œìŠ¤í…œ í˜¸ì¶œ</li>
      <li>í”„ë¡œì„¸ìŠ¤ì˜ ì†Œìœ ìì´ê±°ë‚˜ <strong>ìŠˆí¼ìœ ì €</strong>ì´ì–´ì•¼ í•œë‹¤.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="ì‹œê·¸ë„-ì¢…ë¥˜">ì‹œê·¸ë„ ì¢…ë¥˜</h2>

<ul>
  <li>ì†Œí”„íŠ¸ì›¨ì–´ ì´ë²¤íŠ¸ ë°œìƒ (software interrupt)
    <ul>
      <li>íƒ€ì´ë¨¸ ë§Œë£Œ</li>
      <li>SIGALRM: ì•ŒëŒ ì‹œê³„ ìš¸ë¦¼</li>
      <li>SIGPIPE: ëŠì–´ì§„ íŒŒì´í”„</li>
      <li>SIGCHLD: <strong>ìì‹ í”„ë¡œì„¸ìŠ¤ê°€ ëë‚¬ì„ ë•Œ ë¶€ëª¨ì— ì „ë‹¬ë˜ëŠ” ì‹œê·¸ë„</strong></li>
      <li>SIGCHLD: ìì‹ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ</li>
      <li>CPU time slice expire
        <ul>
          <li>ì–´ë–¤ í”„ë¡œì„¸ìŠ¤ê°€ CPUë¥¼ 10ì´ˆ ë™ì•ˆ ì“´ë‹¤ê³  ê°€ì •, (IOëŠ” ì•ˆí•˜ê³ ) -&gt; CPU í™œìš© ì¸¡ë©´ì—ì„œ ì¢‹ì„ ì§„ ëª°ë¼ë„ ë©€í‹° ìœ ì € í”„ë¡œì„¸ìŠ¤ ì¸¡ë©´ì—ì„œëŠ” ì¢‹ì§€ ì•Šì€ ê²ƒì´ë‹¤. ì´ ë•Œ CPUë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ìµœëŒ€ ì‹œê°„ì´ ì •í•´ì§„ ê²ƒì´ë‹¤.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="introduction-1">Introduction</h2>

<ul>
  <li>Disposition of the signal(called action).
    <ul>
      <li><strong>Ignore the signal</strong>
        <ul>
          <li><strong>SIGKILL</strong> and <strong>SIGSTOP</strong> cannot be ignored.</li>
        </ul>
      </li>
      <li><strong>Catch the signal</strong>
        <ul>
          <li>We should tell the kernel to call a <strong>signal handler function</strong> whenever the signal occurs.</li>
        </ul>
      </li>
      <li><strong>Execute the default action</strong>
        <ul>
          <li>The default action for most signals is <strong>to terminate</strong>.</li>
          <li>ë””í´íŠ¸ ì•¡ì…˜ì€ ì¢…ë£Œ</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="ì‹œê·¸ë„-ê¸°ë³¸-ì²˜ë¦¬">ì‹œê·¸ë„ ê¸°ë³¸ ì²˜ë¦¬</h2>

<ul>
  <li><strong>ì‹œê·¸ë„ ë¬´ì‹œ(ignore)</strong></li>
  <li><strong>í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ</strong>
    <ul>
      <li>ë¹„ì •ìƒ ì¢…ë£Œ, exit()ì— ì˜í•œ ì •ìƒì¢…ë£Œì™€ ë‹¤ë¦„</li>
    </ul>
  </li>
  <li><strong>ì½”ì–´ ë¤í”„ íŒŒì¼ ìƒì„± ë° í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ</strong>
    <ul>
      <li>í”„ë¡œì„¸ìŠ¤ì˜ ê°€ìƒ ë©”ëª¨ë¦¬ ì´ë¯¸ì§€ í¬í•¨,</li>
      <li>í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ ì‹œì ì˜ ìƒíƒœ ì ê²€ì„ ìœ„í•´ ë””ë²„ê±°ê°€ ì‚¬ìš©</li>
    </ul>
  </li>
  <li>í”„ë¡œì„¸ìŠ¤ ì¤‘ì§€(suspend)</li>
  <li>Stopped</li>
  <li>í”„ë¡œì„¸ìŠ¤ ê³„ì†(resume)</li>
</ul>

<p><br /></p>

<h2 id="signals">Signals</h2>

<ul>
  <li>Signals for terminating processes
    <ul>
      <li>SIGHUP
        <ul>
          <li>This signal is sent to the controlling process(session leader) whenever the sessionâ€˜s terminal disconnects.</li>
          <li>The kernel also sends this signal to each process in the foreground process group when the session leader terminates.</li>
          <li>The default action is to terminate, which makes senseâ€”the signal suggests that the user has logged out.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Signals for terminating processes(cont.)
    <ul>
      <li>SIGINT
        <ul>
          <li>This signal is sent to all processes in the foreground process group when the user enters the interrupt character (usually Ctrl-C).</li>
          <li>It is often used to terminate a runaway program.</li>
          <li>The default behavior is to terminate; however, processes can elect to catch and handle this signal, and generally do so to clean up before terminating</li>
        </ul>
      </li>
      <li>SIGQUIT
        <ul>
          <li>Is similar to SIGINT, but generates a core file.</li>
          <li>The kernel raises this signal for all processes in the foreground process group when the user provides the terminal quit character (usually Ctrl-).</li>
          <li>The default action is to terminate the processes, and generate a core dump (termination with core)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/79521972/169322735-523461a6-b9ee-4bb3-b6b3-ec874c1f2146.png" alt="image" /></p>

<ul>
  <li>Signals for terminating processes(cont.)
    <ul>
      <li>SIGABRT
        <ul>
          <li>abort( ) function sends this signal to the process that invokes it.</li>
          <li>abnormal termination</li>
          <li>process then terminates and generates a core file.</li>
          <li>In Linux, assertions such as assert( ) call abort( ) when the conditional fails.</li>
        </ul>
      </li>
      <li>SIGKILL
        <ul>
          <li>This signal is sent from the kill( ) system call</li>
          <li>The default action is to terminate the process</li>
          <li>cannot be caught or ignored.</li>
        </ul>
      </li>
      <li>SIGTERM
        <ul>
          <li>default signal sent out by the kill command.</li>
          <li>Can be caught</li>
          <li>Terminate the process</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Signals for terminating processes(cont.)
    <ul>
      <li>SIGCHLD(or SIGCLD)
        <ul>
          <li>When a process terminates, it is sent to parent.</li>
          <li>Ignore</li>
          <li>The parent must catch using wait().</li>
          <li>A handler for this signal generally calls wait( ) to determine the childâ€˜s pid and exit code.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Signals for suspending or resuming.
    <ul>
      <li>SIGCONT
        <ul>
          <li>The kernel sends this signal to a process when the process is resumed after being stopped</li>
          <li>By default, this signal is ignored, but processes can catch it if they want to perform an action after being continued.</li>
          <li>This signal is commonly used by terminals or editors, which wish to refresh the screen</li>
        </ul>
      </li>
      <li>SIGSTOP
        <ul>
          <li>This signal is sent only by kill( ).</li>
          <li>It unconditionally stops a process, and</li>
          <li>cannot be caught or ignored.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Signals for suspending or resuming(cont).
    <ul>
      <li>SIGTSTP
        <ul>
          <li>The kernel sends this signal to all processes in the foreground process group when the user provides the suspend character (usually Ctrl-Z).</li>
          <li>Suspend</li>
        </ul>
      </li>
      <li>SIGTTIN
        <ul>
          <li>This signal is sent to a process that is in the background when it attempts to read from its controlling terminal.</li>
          <li>The default action is to stop the process.</li>
        </ul>
      </li>
      <li>SIGTTOU
        <ul>
          <li>This signal is sent to a process that is in the background when it attempts to write to its controlling terminal.</li>
          <li>The default action is to stop the process</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Signals triggered by a physical circumstance
    <ul>
      <li>SIGILL
        <ul>
          <li>illegal hardware instruction</li>
          <li>Terminate</li>
        </ul>
      </li>
      <li>SIGTRAP
        <ul>
          <li>An implementation-defined hardware fault.</li>
          <li>use this signal to transfer control to a debugger when a breakpoint instruction is executed.</li>
          <li>terminate with core</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>SIGBUS
    <ul>
      <li>kernel raises signal when the process incurs a hardware fault other than memory protection, which generates a SIGSEGV.</li>
      <li>On traditional Unix systems, this signal represented various irrecoverable errors, such as unaligned memory access.</li>
      <li>Linux kernel, however, fixes most of these errors automatically, without generating the signal.</li>
      <li>kernel raises this signal when a process improperly accesses a region of memory created via mmap</li>
      <li>Unless this signal is caught, the kernel will terminate the process, and generate a core dump</li>
    </ul>
  </li>
  <li>Signals triggered by a physical circumstance(cont.)
    <ul>
      <li>SIGFPE
        <ul>
          <li>Despite its name, this signal represents any arithmetic exception, and not solely those related to floating-point operations.</li>
          <li>Exceptions include overflows, underflows, and division by zero.</li>
          <li>The default action is to terminate the process and generate a core file, but processes may catch and handle this signal if they want.</li>
        </ul>
      </li>
      <li>SIGSEGV
        <ul>
          <li>This signal, whose name derives from segmentation violation, is sent to a process when it attempts an invalid memory access.</li>
          <li>This includes accessing unmapped memory, reading from memory that is not read-enabled, executing code in memory that is not execute-enabled, or writing to memory that is not write-enabled.</li>
          <li>Processes may catch and handle this signal, but the default action is to terminate the process and generate a core dump.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Signals available for use by the programmer
    <ul>
      <li>SIGUSR1, SIGUSR2
        <ul>
          <li>User-defined signals, for use in application programs</li>
          <li>the kernel never raise them.</li>
          <li>default action is to terminate the process</li>
          <li>Signal generated when a pipe is closed</li>
        </ul>
      </li>
      <li>SIGPIPE
        <ul>
          <li>If a process writes to a pipe, but the reader has terminated, the kernel raises this signal.</li>
          <li>The default action is to terminate the process</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="other-signals">Other Signals</h2>

<ul>
  <li>SIGALRM
    <ul>
      <li>The alarm( ) and settimer( ) (with the ITIMER_REAL flag) functions send this signal to the process that invoked them when an alarm expires.</li>
    </ul>
  </li>
  <li>SIGPROF
    <ul>
      <li>The settimer( ) function, when used with the ITIMER_PROF flag, generates this signal when a profiling timer expires.</li>
      <li>The default action is to terminate the process.</li>
    </ul>
  </li>
  <li>SIGPWR
    <ul>
      <li>This signal is system-dependent. On Linux, it represents a low-battery condition (such as in an uninterruptible power supply, or UPS).</li>
      <li>A UPS monitoring daemon sends this signal to init, which then responds by cleaning up and shutting down the systemâ€”hopefully before the power goes out!</li>
    </ul>
  </li>
  <li>SIGSYS
    <ul>
      <li>kernel sends this signal to a process when it attempts to invoke an invalid system call.</li>
      <li>This can happen if a binary is built on a newer version of the operating system (with newer versions of system calls), but then runs on an older version.</li>
      <li>Properly built binaries that make their system calls through glibc should never receive this signal.</li>
    </ul>
  </li>
  <li>SIGTRAP
    <ul>
      <li>The kernel sends this signal to a process when it crosses a break point.</li>
      <li>Generally, debuggers catch this signal, and other processes ignore it.</li>
    </ul>
  </li>
  <li>SIGURG
    <ul>
      <li>The kernel sends this signal to a process when out-of-band (OOB) data has arrived on a socket.</li>
    </ul>
  </li>
  <li>SIGWINCH
    <ul>
      <li>The kernel raises this signal for all processes in the foreground process group when the size of their terminal window changes.</li>
      <li>By default, processes ignore this signal</li>
      <li>A good example of a program that catches this signal is topâ€”try resizing its window while it is running and watch how it responds.</li>
    </ul>
  </li>
  <li>SIGXFSZ
    <ul>
      <li>The kernel raises this signal when a process exceeds its file size limit.</li>
      <li>The default action is to terminate the process, but if this signal is caught or ignored, the system call that would have resulted in the file size limit being exceeded returns -1, and sets errno to EFBIG</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="alarm">alarm()</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alarm</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sec</span><span class="p">)</span>
<span class="c1">//secì´ˆ í›„ì— í”„ë¡œì„¸ìŠ¤ì— SIGALRM ì‹œê·¸ë„ì´ ë°œìƒë˜ë„ë¡ ì„¤ì •í•œë‹¤.</span>
</code></pre></div></div>

<ul>
  <li>Set a timer that will expire at a specified time in the future.
    <ul>
      <li>secì´ˆ í›„ì— í”„ë¡œì„¸ìŠ¤ì— SIGALRM ì‹œê·¸ë„ì´ ë°œìƒí•œë‹¤.</li>
      <li>ì´ ì‹œê·¸ë„ì„ ë°›ìœ¼ë©´ â€œìëª…ì¢… ì‹œê³„â€ ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•˜ê³  í”„ë¡œê·¸ë¨ì€ ì¢…ë£Œëœë‹¤</li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/79521972/169324027-7b9bd600-086b-4078-83aa-f1b5401dd06f.png" alt="image" /></p>

<ul>
  <li>alarm(0)
    <ul>
      <li>ì´ì „ì— ì„¤ì •ëœ ì•ŒëŒì´ ì·¨ì†Œëœë‹¤.</li>
    </ul>
  </li>
  <li>Default action is to terminate the process, but most processes catch this signal.
    <ul>
      <li>default actionì€ í”„ë¡œì„¸ìŠ¤ë¥¼ ì¢…ë£Œí•˜ì§€ë§Œ ëŒ€ë¶€ë¶„ í”„ë¡œì„¸ìŠ¤ëŠ” user defined handler ì‹¤í–‰</li>
    </ul>
  </li>
  <li>í•œ í”„ë¡œì„¸ìŠ¤ ë‹¹ ì˜¤ì§ í•˜ë‚˜ì˜ ì•ŒëŒë§Œ ì„¤ì •í•  ìˆ˜ ìˆë‹¤.</li>
  <li>There is only one alarm clock per process.
    <ul>
      <li>ì´ì „ì— ì„¤ì •ëœ ì•ŒëŒì´ ìˆìœ¼ë©´ ì·¨ì†Œë˜ê³  ë‚¨ì€ ì‹œê°„(ì´ˆ)ì„ ë°˜í™˜í•œë‹¤.</li>
      <li>ì´ì „ì— ì„¤ì •ëœ ì•ŒëŒì´ ì—†ë‹¤ë©´ 0ì„ ë°˜í™˜í•œë‹¤.</li>
      <li>If, when we call alarm, a previously registered alarm clock for the process has not yet expired, the number of seconds left is returned. The previously registered alarm clock is replaced by the new one.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="alarmc">alarm.c</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cm">/* ì•ŒëŒ ì‹œê·¸ë„ì„ ë³´ì—¬ì£¼ëŠ” í”„ë¡œê·¸ë¨ */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span> 
    <span class="kt">int</span> <span class="n">sec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">alarm</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"ë¬´í•œ ë£¨í”„ </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span> 
        <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> 
        <span class="n">printf</span><span class="p">(</span><span class="s">"%dì´ˆ ê²½ê³¼ </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">++</span><span class="n">sec</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"ì‹¤í–‰ë˜ì§€ ì•ŠìŒ </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> 
<span class="p">}</span> 
</code></pre></div></div>

<p>alarm(5)ì´ í˜¸ì¶œë˜ê³  5ì´ˆê°€ ì§€ë‚˜ë©´ ì•„ë˜ while loopë¥¼ ëˆ í›„ì— ìëª…ì¢… ì‹œê³„ë¥¼ í˜¸ì¶œí•˜ê³  ì¢…ë£Œëœë‹¤.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>alarm
ë¬´í•œ ë£¨í”„
1ì´ˆ ê²½ê³¼
2ì´ˆ ê²½ê³¼
3ì´ˆ ê²½ê³¼
4ì´ˆ ê²½ê³¼
5ì´ˆ ê²½ê³¼
ìëª…ì¢… ì‹œê³„
</code></pre></div></div>

<p><br /></p>

<h1 id="112-ì‹œê·¸ë„-ì²˜ë¦¬">11.2 ì‹œê·¸ë„ ì²˜ë¦¬</h1>

<h2 id="ì‹œê·¸ë„-ì²˜ë¦¬ê¸°">ì‹œê·¸ë„ ì²˜ë¦¬ê¸°</h2>

<ul>
  <li>ì‹œê·¸ë„ì— ëŒ€í•œ ì²˜ë¦¬í•¨ìˆ˜ ì§€ì •
    <ul>
      <li>signal() ì‹œìŠ¤í…œ í˜¸ì¶œ</li>
      <li>â€œì´ ì‹œê·¸ë„ì´ ë°œìƒí•˜ë©´ ì´ë ‡ê²Œ ì²˜ë¦¬í•˜ë¼â€</li>
    </ul>
  </li>
  <li>signal() ì‹œìŠ¤í…œ í˜¸ì¶œ
    <ul>
      <li>ì‚¬ìš©ìê°€ ì •ì˜í•œ ì‹œê·¸ë„ í•¨ìˆ˜ ë“±ë¡</li>
    </ul>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span><span class="n">signal</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span> <span class="p">)))</span>
<span class="c1">//signoì— ëŒ€í•œ ì²˜ë¦¬ í•¨ìˆ˜ë¥¼ funcìœ¼ë¡œ ì§€ì •í•˜ê³  ê¸°ì¡´ì˜ ì²˜ë¦¬í•¨ìˆ˜ë¥¼ ë¦¬í„´í•œë‹¤</span>
</code></pre></div></div>

<ul>
  <li>ì‹œê·¸ë„ ì²˜ë¦¬ í•¨ìˆ˜ func
    <ul>
      <li><strong>SIG_IGN</strong> : ì‹œê·¸ë„ ë¬´ì‹œ
        <ul>
          <li>-&gt; all signals can be ignored, except SIGKILL and SIGSTOP</li>
        </ul>
      </li>
      <li><strong>SIG_DFL</strong> : ê¸°ë³¸ ì²˜ë¦¬
        <ul>
          <li><strong>ì‚¬ìš©ì ì •ì˜ í•¨ìˆ˜ ì´ë¦„</strong> -&gt; most are to terminate process</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="ì˜ˆì œ-almhandlerc-sigalrm">ì˜ˆì œ: almhandler.c (SIGALRM)</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span><span class="kt">void</span> <span class="nf">alarmHandler</span><span class="p">();</span>
<span class="cm">/* ì•ŒëŒ ì‹œê·¸ë„ì„ ì²˜ë¦¬í•œë‹¤. */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span> 
    <span class="kt">int</span> <span class="n">sec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">SIGALRM</span><span class="p">,</span><span class="n">alarmHandler</span><span class="p">);</span> <span class="c1">//ì‚¬ìš©ì ì •ì˜ í•¸ë“¤ëŸ¬ í•¨ìˆ˜ ë“±ë¡- &gt; SIGALRMì„ ë‹¤ìŒ í•¨ìˆ˜ë¡œ ì²˜ë¦¬</span>
    <span class="n">alarm</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="cm">/* ì•ŒëŒ ì‹œê°„ ì„¤ì • */</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"ë¬´í•œ ë£¨í”„ </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%dì´ˆ ê²½ê³¼ </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">++</span><span class="n">sec</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"ì‹¤í–‰ë˜ì§€ ì•ŠìŒ </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">alarmHandler</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"ì¼ì–´ë‚˜ì„¸ìš”</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>alarmhandler
ë¬´í•œ ë£¨í”„
1
1ì´ˆ ê²½ê³¼
2ì´ˆ ê²½ê³¼
3ì´ˆ ê²½ê³¼
4ì´ˆ ê²½ê³¼
5ì´ˆ ê²½ê³¼
ì¼ì–´ë‚˜ì„¸ìš”
</code></pre></div></div>

<p><br /></p>

<h2 id="ì˜ˆì œ-sigint1c-sigint">ì˜ˆì œ: sigint1.c (SIGINT)</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span><span class="kt">void</span> <span class="nf">intHandler</span><span class="p">();</span>
<span class="cm">/* ì¸í„°ëŸ½íŠ¸ ì‹œê·¸ë„ì„ ì²˜ë¦¬í•œë‹¤. */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span><span class="n">intHandler</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span> <span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Cannot handle SIGINT!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="c1">//redundant code (ì˜ˆì™¸ ì²˜ë¦¬)</span>
        <span class="n">exit</span> <span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">pause</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"ì‹¤í–‰ë˜ì§€ ì•ŠìŒ </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">intHandler</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"ì¸í„°ëŸ½íŠ¸ ì‹œê·¸ë„ ì²˜ë¦¬</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"ì‹œê·¸ë„ ë²ˆí˜¸: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">signo</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>sigint1
^cì¸í„°ëŸ½íŠ¸ ì‹œê·¸ë„ ì²˜ë¦¬
ì‹œê·¸ë„ ë²ˆí˜¸: 2
</code></pre></div></div>

<p>ì‚¬ìš©ìê°€ CTRL-Cë¥¼ ëˆ„ë¥´ë©´ SIGINT signal ë°œìƒ -&gt; user defined handler í•¨ìˆ˜ intHandler í˜¸ì¶œ</p>

<p><br /></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span><span class="n">pause</span><span class="p">()</span>
 <span class="err">ì‹œê·¸ë„ì„</span> <span class="err">ë°›ì„</span> <span class="err">ë•Œê¹Œì§€</span> <span class="err">í•´ë‹¹</span> <span class="err">í”„ë¡œì„¸ìŠ¤ë¥¼</span> <span class="err">ì ë“¤ê²Œ</span> <span class="err">ë§Œë“ ë‹¤</span><span class="p">.</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="ì‹œê·¸ë„-ì²˜ë¦¬ê¸°-1">ì‹œê·¸ë„ ì²˜ë¦¬ê¸°</h2>

<ul>
  <li>a process can catch neither <strong>SIGKILL nor SIGSTOP</strong>, so setting up a handler for either of these two signals makes no sense
    <ul>
      <li>SIGKILLì´ë‚˜ SIGSTOPì€ catchí•  ìˆ˜ ì—†ëŠ” signalì´ê¸° ë•Œë¬¸ì— í•´ë‹¹ signalì— ëŒ€í•œ handlerë¥¼ ë§Œë“œëŠ” ê²ƒì€ ì˜ë¯¸ê°€ ì—†ë‹¤.(make no sense)</li>
    </ul>
  </li>
  <li>The handler function <strong>must return void</strong>, which makes sense because (unlike with normal functions) <mark>there is no standard place in the program for this function to return</mark>
    <ul>
      <li>ëŒì•„ê°ˆ ê³³ì´ ì—†ê¸° ë•Œë¬¸ì— (ë¶€ë¥¸ ê³³ì´ ëª…í™•ì¹˜ ì•Šì•„)</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="signal">signal()</h2>

<ul>
  <li>Example
    <ul>
      <li>It possible to use <strong>one signal handler for several signals</strong></li>
      <li>í•œ signal handlerì—ì„œ ì—¬ëŸ¬ signal ì²˜ë¦¬ ( signoì„ í†µí•´ì„œ)</li>
    </ul>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span><span class="kt">void</span> <span class="nf">myhandler</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">signo</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">SIGQUIT</span> <span class="p">:</span> <span class="n">printf</span><span class="p">(</span><span class="s">"SIGQUIT(%d) is caught</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">SIGQUIT</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">SIGTSTP</span> <span class="p">:</span> <span class="n">printf</span><span class="p">(</span><span class="s">"SIGTSTP(%d) is caught</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">SIGTSTP</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">SIGTERM</span> <span class="p">:</span> <span class="n">printf</span><span class="p">(</span><span class="s">"SIGTERM(%d) is caught</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">SIGTERM</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">SIGUSR1</span> <span class="p">:</span> <span class="n">printf</span><span class="p">(</span><span class="s">"SIGUSR1(%d) is caught</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">SIGUSR1</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="nl">default:</span> <span class="n">printf</span><span class="p">(</span><span class="s">"other signal</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span> <span class="c1">//ì›ë˜ëŠ” ì¢…ë£Œë¥¼ ì‹œí‚¤ëŠ” ê²ƒì´ ì¼ë°˜ì , not return</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">SIGQUIT</span><span class="p">,</span> <span class="n">myhandler</span><span class="p">);</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">SIGTSTP</span><span class="p">,</span> <span class="n">SIG_DFL</span><span class="p">);</span> <span class="c1">//use default handler</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">SIGTERM</span><span class="p">,</span> <span class="n">myhandler</span><span class="p">);</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">SIGUSR1</span><span class="p">,</span> <span class="n">myhandler</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(;;)</span>
        <span class="n">pause</span><span class="p">();</span>
<span class="p">}</span>

</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/79521972/169325455-43f246d0-9fbc-42c0-a062-d5f586fee2bc.png" alt="image" /></p>

<ul>
  <li>ì‹¤í–‰</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./a.out
^<span class="se">\ </span>					//SIGQUIT<span class="p">;</span> í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰ ì¤‘ì§€
SIGQUIT<span class="o">(</span>3<span class="o">)</span> is caught
^Z 					//SIGSTP
<span class="o">[</span>1]+ Stopped ./a.out
<span class="nv">$ </span>ps
 PID TTY TIME CMD
15554 pts/2 00:00:00 bash
15587 pts/2 00:00:00 a.out
15588 pts/2 00:00:00 ps
<span class="nv">$ </span><span class="nb">kill </span>15587 		//signoë¥¼ ëª…ì‹œí•˜ì§€ ì•Šìœ¼ë©´ SIGTERM ì‹œê·¸ë„ì„ ë³´ë‚´ í•´ë‹¹ í”„ë¡œì„¸ìŠ¤ë¥¼ ê°•ì œ ì¢…ë£Œì‹œí‚´.
SIGTERM<span class="o">(</span>15<span class="o">)</span> is caught
<span class="nv">$ </span><span class="nb">kill</span> <span class="nt">-USR1</span> 15587
SIGUSR1<span class="o">(</span>10<span class="o">)</span> is caught
<span class="err">$</span>
</code></pre></div></div>

<p>-USR: ì‚¬ìš©ì ì •ì˜ signal</p>

<p><br /></p>

<h2 id="waiting-for-a-signal-any-signal">Waiting for a Signal, Any Signal</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">pause</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>pause( ) system call puts a process to sleep <strong>until it receives a signal</strong> that either is handled or terminates the process</li>
  <li>pause( ) returns only if a caught signal is received, in which case the signal is handled, and pause( ) returns -1, and sets errno to EINTR (invalid signo).</li>
  <li>If the kernel raises an <strong>ignored</strong> signal, the process <strong>does not wake up</strong> (never).</li>
  <li>It performs only two actions.
    <ul>
      <li>First, it puts the process in the interruptible sleep state.</li>
      <li>Next, it calls schedule( ) to invoke the Linux process scheduler to find another process to run.</li>
      <li>As the process is not actually waiting for anything, the kernel will not wake it up unless it receives a signal.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="ex1">Ex1</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// register the same handler for SIGTERM and SIGINT.</span>
<span class="c1">// also reset the behavior for SIGPROF to the default (which is to terminate the process)</span>
<span class="c1">//and ignore SIGHUP (which would otherwise terminate the process):</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">signal_handler</span> <span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signo</span> <span class="o">==</span> <span class="n">SIGINT</span><span class="p">)</span>
        <span class="n">printf</span> <span class="p">(</span><span class="s">"Caught SIGINT!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">signo</span> <span class="o">==</span> <span class="n">SIGTERM</span><span class="p">)</span>
        <span class="n">printf</span> <span class="p">(</span><span class="s">"Caught SIGTERM!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">else</span> <span class="p">{</span> <span class="cm">/* this should never happen */</span>
        <span class="n">fprintf</span> <span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Unexpected signal!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span> <span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">exit</span> <span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Register signal_handler as our signal handler for SIGINT.*/</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span> <span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">signal_handler</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span> <span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Cannot handle SIGINT!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span> <span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="cm">/*Register signal_handler as our signal handler for SIGTERM */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span> <span class="p">(</span><span class="n">SIGTERM</span><span class="p">,</span> <span class="n">signal_handler</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span> <span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Cannot handle SIGTERM!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span> <span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="cm">/* Reset SIGPROF's behavior to the default. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span> <span class="p">(</span><span class="n">SIGPROF</span><span class="p">,</span> <span class="n">SIG_DFL</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span> <span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Cannot reset SIGPROF!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span> <span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="cm">/* Ignore SIGHUP. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span> <span class="p">(</span><span class="n">SIGHUP</span><span class="p">,</span> <span class="n">SIG_IGN</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span> <span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Cannot ignore SIGHUP!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span> <span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(;;)</span>
        <span class="n">pause</span> <span class="p">(</span> <span class="p">);</span>
    <span class="n">Return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>signal handlerë¥¼ user defined handlerë¡œ ì§€ì •í•˜ì§€ ì•Šì€ ê²½ìš°(SIG_DFL, SIG_IGN)ëŠ” ì‚¬ìš©ì ì •ì˜ handlerê°€ ì‹¤í–‰ë˜ì§€ ì•Šê³  ê°ì ì§€ì •ëœ ëŒ€ë¡œ ì²˜ë¦¬ëœë‹¤.</p>

<p><br /></p>

<h2 id="ex2">Ex2</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="c1"> /* sigusr.c */</span><span class="cp">
</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">sig_usr</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* argument is signal number */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signo</span> <span class="o">==</span> <span class="n">SIGUSR1</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"received SIGUSR1</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">signo</span> <span class="o">==</span> <span class="n">SIGUSR2</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"received SIGUSR2</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"received signal %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">signo</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="p">(</span><span class="n">SIGUSR1</span><span class="p">,</span> <span class="n">sig_usr</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"can't catch SIGUSR1"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="p">(</span><span class="n">SIGUSR2</span><span class="p">,</span> <span class="n">sig_usr</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"can't catch SIGUSR2"</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="p">;</span> <span class="p">)</span>
        <span class="n">pause</span><span class="p">(</span> <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>a.out &amp; // start process <span class="k">in </span>background
<span class="o">[</span>1] 4720 job number &amp; process ID
<span class="nv">$ </span><span class="nb">kill</span> â€“USR1 4720 // send SIGUSR1
received SIGUSR1
<span class="nv">$ </span><span class="nb">kill</span> â€“USR2 4720 // send SIGUSR2
received SIGUSR2
<span class="nv">$ </span><span class="nb">kill </span>4720 // send SIGTERM
<span class="o">[</span>1] + Terminated a.out &amp;
</code></pre></div></div>

<p><br /></p>

<h2 id="sigaction-í•¨ìˆ˜">sigaction() í•¨ìˆ˜</h2>

<ul>
  <li>signal()ë³´ë‹¤ <strong>ì •êµí•˜ê²Œ</strong> ì‹œê·¸ë„ ì²˜ë¦¬ê¸°ë¥¼ ë“±ë¡í•˜ê¸° ìœ„í•œ í•¨ìˆ˜
    <ul>
      <li>sigaction êµ¬ì¡°ì²´ë¥¼ ì‚¬ìš©í•˜ì—¬ ì •êµí•œ ì‹œê·¸ë„ ì²˜ë¦¬ ì•¡ì…˜ì„ ë“±ë¡</li>
    </ul>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">sigaction</span><span class="p">(</span><span class="kt">int</span> <span class="n">signum</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sigaction</span> <span class="o">*</span><span class="n">act</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sigaction</span> <span class="o">*</span><span class="n">oldact</span><span class="p">);</span>
<span class="c1">// signum ì‹œê·¸ë„(SIGKILLê³¼ SIGSTOP ì œì™¸)ì´ ìˆ˜ì‹ ë˜ì—ˆì„ ë•Œ, í”„ë¡œì„¸ìŠ¤ê°€ ì·¨í•  ì•¡ì…˜ì„ ë³€ê²½í•˜ëŠ” ë° ì‚¬ìš©ëœë‹¤. // ì´ ì‹œê·¸ë„ì— ëŒ€í•œ ìƒˆë¡œìš´ ì•¡ì…˜ì€ actê°€ ë˜ë©°, ê¸°ì¡´ì˜ ì•¡ì…˜ì€ oldactì— ì €ì¥ëœë‹¤. ì„±ê³µí•˜ë©´ 0ì„ ì‹¤íŒ¨í•˜ë©´ â€“1ë¥¼ ë°˜í™˜í•œë‹¤.</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">sigaction</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sa_handler</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// ì‹œê·¸ë„ ì²˜ë¦¬ê¸°</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sa_sigaction</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
    <span class="n">sigset_t</span> <span class="n">sa_mask</span><span class="p">;</span> <span class="c1">// ì‹œê·¸ë„ì„ ì²˜ë¦¬í•˜ëŠ” ë™ì•ˆ ì°¨ë‹¨í•  ì‹œê·¸ë„ ì§‘í•©</span>
    <span class="kt">int</span> <span class="n">sa_flags</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">void (*sa_handler)(int); // ì‹œê·¸ë„ ì²˜ë¦¬ê¸°</code>
    <ul>
      <li>SIG_IGN : ì‹œê·¸ë„ ë¬´ì‹œ
        <ul>
          <li>-&gt; all signals can be ignored, except SIGKILL and SIGSTOP</li>
        </ul>
      </li>
      <li>SIG_DFL : ê¸°ë³¸ ì²˜ë¦¬</li>
      <li>ì‚¬ìš©ì ì •ì˜ í•¨ìˆ˜ ì´ë¦„</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">void (*sa_sigaction)(int, siginfo_t *, void *); </code>
    <ul>
      <li>sa_flagsì˜ SA_SIGINFO ì¼ ë•Œ sa_handler() ëŒ€ì‹ ì— í˜¸ì¶œë˜ëŠ” ì²˜ë¦¬ê¸°</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">sigset_t sa_mask; // ì‹œê·¸ë„ì„ ì²˜ë¦¬í•˜ëŠ” ë™ì•ˆ ì°¨ë‹¨í•  ì‹œê·¸ë„ ì§‘í•©</code></p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">int sa_flags : ì‹œê·¸ë„ ì²˜ë¦¬ ì ˆì°¨ </code>
    <ul>
      <li>SA_SIGINFO -&gt; sa_flagê°€ sa_handler ëŒ€ì‹ ì— sa_sigactionì„ ì‚¬ìš©í•¨</li>
      <li>SA_NOCLDSTOP -&gt; <mark>signumì´ SIGCHILDì¼ ê²½ìš°, ìì‹ í”„ë¡œì„¸ìŠ¤ê°€ ì¢…ë£Œ/ì¤‘ë‹¨ ë˜ì—ˆ ì„ ë•Œ ë¶€ëª¨ í”„ë¡œì„¸ìŠ¤ì—ê²Œ SIGCHILDë¥¼ ì „ë‹¬ í•˜ì§€ ì•ŠìŒ </mark></li>
      <li>SA_ONESHOT -&gt; ì‹œê·¸ë„ì„ ìˆ˜ì‹ í•˜ë©´ ì„¤ì •ëœ ì•¡ì…˜ì„ í•˜ê³  SIG_DFLë¡œ ì¬ì„¤ì •ë¨</li>
      <li>SA_NOMASK -&gt; ì‹œê·¸ë„ì„ ì²˜ë¦¬í•˜ëŠ” ë™ì•ˆì— ì „ë‹¬ë˜ëŠ” ì‹œê·¸ë„ì€ ì°¨ë‹¨ë˜ì§€ ì•ŠìŒ</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="ì‹œê·¸ë„-ì§‘í•©-í•¸ë“¤ë§-í•¨ìˆ˜">ì‹œê·¸ë„ ì§‘í•© í•¸ë“¤ë§ í•¨ìˆ˜</h2>

<ul>
  <li>#include  &lt;signal.h&gt;</li>
  <li>int sigemptyset(sigset_t *set);
    <ul>
      <li>ì‹œê·¸ë„ ì§‘í•© setì„ ê³µì§‘í•©ìœ¼ë¡œ ì´ˆê¸°í™”</li>
    </ul>
  </li>
  <li>int sigfillset(sigset_t *set);
    <ul>
      <li>ì‹œê·¸ë„ ì§‘í•© setì„ ëª¨ë“  ì‹œê·¸ë„ì„ í¬í•¨í•˜ë„ë¡ ì´ˆê¸°í™”</li>
    </ul>
  </li>
  <li>int sigaddset(sigset_t *set, int signum);
    <ul>
      <li>ì‹œê·¸ë„ ì§‘í•© setì— ì‹œê·¸ë„ signumì„ ì¶”ê°€</li>
    </ul>
  </li>
  <li>int sigdelset(sigset_t *set, int signum);
    <ul>
      <li>ì‹œê·¸ë„ ì§‘í•© setì—ì„œ ì‹œê·¸ë„ signumì„ ì‚­ì œ</li>
    </ul>
  </li>
  <li>int sigismember(sigset_t *set, int signum);
    <ul>
      <li>ì‹œê·¸ë„ signumì´ ì§‘í•© setì˜ ì›ì†Œì¸ì§€ ì—¬ë¶€ ë°˜í™˜</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="sigint2c">sigint2.c</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span><span class="k">struct</span> <span class="n">sigaction</span> <span class="n">newact</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sigaction</span> <span class="n">oldact</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">sigint_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">newact</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">sigint_handler</span><span class="p">;</span> <span class="c1">// ì‹œê·¸ë„ ì²˜ë¦¬ê¸° ì§€ì •</span>
    <span class="n">sigfillset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newact</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">);</span> <span class="c1">// ëª¨ë“  ì‹œê·¸ë„ì„ ì°¨ë‹¨í•˜ë„ë¡ ë§ˆìŠ¤í¬(ì´ˆê¸°í™”)</span>

    <span class="c1">// SIGINTì˜ ì²˜ë¦¬ ì•¡ì…˜ì„ ìƒˆë¡œ ì§€ì •, oldactì— ê¸°ì¡´ ì²˜ë¦¬ ì•¡ì…˜ì„ ì €ì¥</span>
    <span class="n">sigaction</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newact</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldact</span><span class="p">);</span> 
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span> <span class="s">"Ctrl-Cë¥¼ ëˆŒëŸ¬ ë³´ì„¸ìš” !</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> 
        <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> 
    <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/* SIGINT ì²˜ë¦¬ í•¨ìˆ˜ */</span> 
<span class="kt">void</span> <span class="nf">sigint_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span> 
<span class="p">{</span> 
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d ë²ˆ ì‹œê·¸ë„ ì²˜ë¦¬!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">signo</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"ë˜ ëˆ„ë¥´ë©´ ì¢…ë£Œë©ë‹ˆë‹¤.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">sigaction</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldact</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> <span class="c1">// ê¸°ì¡´ ì²˜ë¦¬ ì•¡ì…˜ìœ¼ë¡œ ë³€ê²½</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>sigint2
Ctrl-Cë¥¼ ëˆŒëŸ¬ë³´ì„¸ìš”!
Ctrl-Cë¥¼ ëˆŒëŸ¬ë³´ì„¸ìš”!
^c
2ë²ˆ ì‹œê·¸ë„ ì²˜ë¦¬!
ë˜ ëˆ„ë¥´ë©´ ì¢…ë£Œë©ë‹ˆë‹¤.
Ctrl-Cë¥¼ ëˆŒëŸ¬ë³´ì„¸ìš”!
^c
</code></pre></div></div>

<p>ì‚¬ìš©ìê°€ Ctrl-Cë¥¼ ëˆ„ë¥´ê²Œ ë˜ë©´ ì¢…ë£Œë¥¼ í•˜ê²Œ ëœë‹¤.</p>

<p><br /></p>

<h2 id="execution-and-inheritance">Execution and Inheritance</h2>

<ul>
  <li>When a process is first executed, <strong>all signals</strong> are set to their <strong>default actions</strong>, unless the parent process is ignoring them; in this case, the newly created process will also <strong>ignore</strong> those signals.
    <ul>
      <li>Put another way, any signal caught by the parent is reset to the <strong>default action</strong> in the new process, and all other signals remain the same.
        <ul>
          <li>ì‚¬ìš©ì ì •ì˜ë„ defaultë¡œ ì„¸íŒ…ëœë‹¤.</li>
          <li>This makes sense because a freshly executed process <strong>does not share the address space of its parent</strong>, and thus any registered signal handlers may not exist.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>When a process calls fork( ), the child <strong>inherits</strong> the exact same signal semantics as the parent.
    <ul>
      <li>This also makes sense, as the child and parent share an address space, and thus the parentâ€˜s signal handlers exist in the child</li>
    </ul>
  </li>
  <li>when the shell executes a process <strong>â€œin the backgroundâ€</strong> (or when another background process executes another process), the newly executed process <strong>should ignore the interrupt and quit character</strong>
    <ul>
      <li>Catches the signals in foreground process</li>
    </ul>
  </li>
  <li>Thus, before a shell executes a background process, it should set SIGINT and SIGQUIT to SIG_IGN.
    <ul>
      <li>SIGQUITë‚˜ SIGINTëŠ” í‚¤ë³´ë“œë¡œ ë°›ëŠ” ì…ë ¥ì„ ë°›ì„ ë•Œ ì´ê¸° ë•Œë¬¸ì— backgroundì—ì„œ ë°›ì„ ìˆ˜ ì—†ëŠ” ê²ƒì´ë‹¤.</li>
    </ul>
  </li>
  <li>It is therefore common for programs that handle these signals to first check to make sure they are not ignored</li>
</ul>

<p><br /></p>

:ET