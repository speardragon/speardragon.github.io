I"D<p>이번 시간에는 쉘 정렬(Shell Sort)에 대해서 배워볼 것이다.</p>

<p><br /></p>

<h2 id="1-셸-정렬이란">1. 셸 정렬이란?</h2>

<p><img src="https://user-images.githubusercontent.com/79521972/155940530-287b1003-275b-471e-9f87-09de8766e5ed.gif" alt="vQDGWb" /></p>

<p>셸 정렬은 삽입 정렬의 성질을 이용하고 이를 보완한 삽입 정렬의 일반화 버전이라고 볼 수 있다.</p>

<ul>
  <li><strong>삽입 정렬</strong>의 설명은 <a href="https://speardragon.github.io/lecture/data%20structure%20and%20algorithms/algorithm/sorting/Algorithm-Insert-Sort(%EC%82%BD%EC%9E%85-%EC%A0%95%EB%A0%AC)/"><u><span style="color:blue">이곳</span></u></a>을 참조</li>
</ul>

<p><br /></p>

<p>삽입 정렬의 특징은 다음과 같은 것이 있었다.</p>

<ol>
  <li>입력되는 초기 리스트가 <code class="language-plaintext highlighter-rouge">거의 정렬</code>되어 있을 경우에만 효율적으로 사용 가능하다.</li>
  <li>한 번에 한 요소의 위치만 결정 되기 때문에 비효율적이다.</li>
</ol>

<p><br /></p>

<p>이러한 삽입 정렬의 장점은 뽑아 먹고 단점은 보완한 것이 셸 정렬이다.</p>

<p>그래서 셸 정렬은 기존의 삽입 정렬을 수행하기 전에 전체 데이터를 <code class="language-plaintext highlighter-rouge">거의 정렬된</code> 상태로 만들면 기존의 삽입 정렬을 그대로 처음부터 사용하는 것보다 더 좋은 성능을 발휘할 수 있다는 점에서 착안된 것이다.</p>

<p><br /></p>

<p>우선 셸 정렬은</p>

<p>Memory 상에서 필요 시 상호 위치만 변경될 뿐 추가적인 배열은 생성이 불필요하다는 점에서 <mark>In-place 정렬</mark> 방식이고,</p>

<p>같은 값을 가지는 데이터의 기존 순서 유지를 보장할 수 없다는 점에서 <mark>Unstable 정렬</mark>이다.</p>

<p><br /></p>

<h2 id="2-동작-방식">2. 동작 방식</h2>

<p>셸 정렬의 동작 방식은 삽입 정렬과 동일하다.</p>

<p>그러나 다른 점은 기존 <strong>삽입 정렬</strong>이 삽입 위치를 찾기 위해 인접한 값들끼리만 비교했다면 <strong>셸 정렬</strong>은 <span style="color:red">Gap</span>을 두어 인접하지 않은 값들끼리 비교하는 방식이다.</p>

<p><br /></p>

<p>그리고 이 Gap을 줄여가야 하는데, Gap이 1이 된다면 삽입 정렬과 동일한 상태로 동작하게 된다. 그래서 Gap이 1이 되기 전까지는 전체 데이터가 <code class="language-plaintext highlighter-rouge">거의 정렬된</code> 상태를 유지하는 것이다.</p>

<p><br /></p>

<p>셸 정렬이 Unstable한 이유는 이 Gap을 통해서 인접하지 않은 값들끼리 교환이 일어날 수 있기 때문인데 이제 어떻게 셸 정렬이 동작하는 지 알아보자.</p>

<p><br /></p>

<p>초기 배열의 상태는 다음과 같다.</p>

<table>
  <thead>
    <tr>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
      <th>7</th>
      <th>8</th>
      <th>9</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>20</td>
      <td>35</td>
      <td>-15</td>
      <td>7</td>
      <td>76</td>
      <td>1</td>
      <td>-3</td>
      <td>8</td>
      <td>0</td>
      <td>-50</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p>정렬은 0번 부터 시작하지만 0번과 비교할 데이터는 0 + k 번이다. <span style="color:blue">여기서 k가 바로 우리가 위에서 말했던 Gap이다.</span></p>

<p>이 k를 초기에 (배열의 크기 / 2)로 정하고 시작하자.</p>

<p><br /></p>

<p>1) k = (10/2) = 5인 경우</p>

<p><img src="https://user-images.githubusercontent.com/79521972/155942656-c0412389-889f-4ae3-800d-d35baa1fdf19.png" alt="image" /></p>

<p>같은 높이(행)에 있는 것들끼리 비교하여 정렬한다고 생각하면 된다.</p>

<table>
  <thead>
    <tr>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
      <th>7</th>
      <th>8</th>
      <th>9</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>-3</td>
      <td>-15</td>
      <td>0</td>
      <td>-50</td>
      <td>20</td>
      <td>35</td>
      <td>8</td>
      <td>7</td>
      <td>76</td>
    </tr>
  </tbody>
</table>

<p>위 배열은 간격 별 정렬 후의 1차로 정렬된 상태이다.</p>

<p>1차적인 정렬을 마쳤기 때문에 Gap을 조금씩 줄여야 한다. 되도록 이 Gap은 홀수가 되는 것이 좋기 때문에 다음 Gap 3으로 해 보겠다.</p>

<p><br /></p>

<p>2) k = 3인 경우</p>

<p><img src="https://user-images.githubusercontent.com/79521972/155942903-8f4eeba0-a195-44f4-ab3b-ee1b2ac109ee.png" alt="image" /></p>

<table>
  <thead>
    <tr>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
      <th>7</th>
      <th>8</th>
      <th>9</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>-50</td>
      <td>-15</td>
      <td>1</td>
      <td>-3</td>
      <td>7</td>
      <td>35</td>
      <td>8</td>
      <td>20</td>
      <td>76</td>
    </tr>
  </tbody>
</table>

<p><span style="color:red">마지막으로 Gap을 1로 다시 줄여서 삽입 정렬을 진행한다. </span></p>

<p>이때 Gap이 1일때 삽입 정렬을 시도하는 것은 거의 정렬된 상태에서 삽입 정렬을 시도하는 것이기 때문에 상당히 빠른 퍼포먼스로 정렬을 마무리 할 수 있는 것이다.</p>

<p><br /></p>

<p>3) Gap = 1인 경우, 삽입 정렬 시도</p>

<table>
  <thead>
    <tr>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
      <th>7</th>
      <th>8</th>
      <th>9</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>-50</td>
      <td>-15</td>
      <td>-3</td>
      <td>0</td>
      <td>1</td>
      <td>7</td>
      <td>8</td>
      <td>20</td>
      <td>35</td>
      <td>76</td>
    </tr>
  </tbody>
</table>

<p>위 배열과 같이 모두 정렬이 잘 마무리 된 것을 확인 할 수 있다.</p>

<h2 id="3-셸-정렬-구현">3. 셸 정렬 구현</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.test</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ShellSort</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">intArray</span> <span class="o">=</span> <span class="o">{</span><span class="mi">20</span><span class="o">,</span> <span class="mi">35</span><span class="o">,</span> <span class="o">-</span><span class="mi">15</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">55</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">22</span><span class="o">};</span>

        <span class="c1">// Gap에 따라 정렬 하기 위해 Gap을 이용한 반복문을 생성함</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">gap</span> <span class="o">=</span> <span class="n">intArray</span><span class="o">.</span><span class="na">length</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span> <span class="n">gap</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="n">gap</span> <span class="o">/=</span> <span class="mi">2</span><span class="o">){</span>

            <span class="c1">// Gap의 크기에 맞게 최초 정렬을 시작할 기준을 지정하여 반복문 형성</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">gap</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intArray</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>

                <span class="c1">// i에 지정된 값에 해당하는 Value를 정렬 시를 대비해 미리 저장해 둠</span>
                <span class="kt">int</span> <span class="n">newElement</span> <span class="o">=</span> <span class="n">intArray</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>

                <span class="c1">// j를 이용해 Gap 만큼의 반복 정렬을 수행할 것이므로 따로 저장</span>
                <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>

                <span class="c1">// 해당 반복 정렬을 조건이 참인 경우 수행</span>
                <span class="c1">// 해당 조건은, j의 index 값이 gap보다 커야 하며, j-gap의 index에 지정 된 배열 값이 이전에 저장된 내용보다 큰 경우</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">gap</span> <span class="o">&amp;</span> <span class="n">intArray</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">gap</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">newElement</span><span class="o">)</span> <span class="o">{</span>

                    <span class="c1">// 해당 값을 뒤 쪽으로 미루어 저장</span>
                    <span class="n">intArray</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">intArray</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">gap</span><span class="o">];</span>

                    <span class="c1">// 반복 비교를 위해 gap만큼 차감</span>
                    <span class="n">j</span> <span class="o">-=</span> <span class="n">gap</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="c1">// 기존에 저장한 배열 값을 저장</span>
                <span class="n">intArray</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">newElement</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intArray</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">intArray</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">){</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">intArray</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">intArray</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="s">", "</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="4-gap-정하는-방법">4. Gap 정하는 방법</h2>

<ul>
  <li>각 회전마다 Gap을 절반으로 줄여나간다.
    <ul>
      <li>즉, 각 회전이 반복될 때마다 하나의 부분 리스트의 속한 값들의 갯수는 증가한다.</li>
    </ul>
  </li>
  <li>Gap은 홀수로 하는 것이좋다.</li>
  <li>Gap을 절반으로 줄여나갈 때 짝수가 된다면 +1 (소수인 경우 반올림) 하여 홀수로 만들어 준다.</li>
  <li>Gap이 1이 될때까지 반복한다.</li>
</ul>

<p><br /></p>

<p>위의 예시에서는 사실 Gap sequence를 단순하게 배열의 크기에서 2로 나누면서 진행해 나갔지만, 실제로 이에 대한 연구 <code class="language-plaintext highlighter-rouge">Best Gap Sequence, Knuth Sequence, Ciura Sequence</code>등에서 좋은 Gap을 얻는 방법은 계속해서 찾아내는 중이다.</p>

<p>이에 대한 내용은 구글 검색을 통해 알아보도록 하고 셸 정렬에 대한 내용은 여기서 마치겠다.</p>

<p><br /></p>

<h3 id="5-정렬-간-시간복잡도-비교">5. 정렬 간 시간복잡도 비교</h3>

<table>
  <thead>
    <tr>
      <th>정렬 방식</th>
      <th>Average</th>
      <th>Worst</th>
      <th>Memory</th>
      <th>Stable 여부</th>
      <th>In-Place 여부</th>
      <th>Run-time(정수 60,000개) 단위: sec</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Bubble 정렬</td>
      <td>O(n<sup>2</sup>)</td>
      <td>O(n<sup>2</sup>)</td>
      <td>O(1)</td>
      <td>O</td>
      <td>O</td>
      <td>7.438</td>
    </tr>
    <tr>
      <td>Selection 정렬</td>
      <td>O(n<sup>2</sup>)</td>
      <td>O(n<sup>2</sup>)</td>
      <td>O(1)</td>
      <td>X</td>
      <td>O</td>
      <td>10.842</td>
    </tr>
    <tr>
      <td>Insertion 정렬</td>
      <td>O(n<sup>2</sup>)</td>
      <td>O(n<sup>2</sup>)</td>
      <td>O(1)</td>
      <td>O</td>
      <td>O</td>
      <td>22.894</td>
    </tr>
    <tr>
      <td>Shell 정렬</td>
      <td>O(nlog<sub>2</sub>n)</td>
      <td>O(n<sup>2</sup>)</td>
      <td>O(1)</td>
      <td>X</td>
      <td>O</td>
      <td>0.056</td>
    </tr>
    <tr>
      <td><mark>Merge 정렬</mark></td>
      <td><strong>O(nlog<sub>2</sub>n)</strong></td>
      <td><strong>O(nlog<sub>2</sub>n)</strong></td>
      <td><strong>O(n)</strong></td>
      <td><strong>O</strong></td>
      <td><strong>X</strong></td>
      <td><strong>0.014</strong></td>
    </tr>
    <tr>
      <td>Quick 정렬</td>
      <td>O(nlog<sub>2</sub>n)</td>
      <td>O(n<sup>2</sup>)</td>
      <td>O(1)</td>
      <td>X</td>
      <td>O</td>
      <td>0.034</td>
    </tr>
    <tr>
      <td>Heap 정렬</td>
      <td>O(nlog<sub>2</sub>n)</td>
      <td>O(nlog<sub>2</sub>n)</td>
      <td>O(1)</td>
      <td>X</td>
      <td>O</td>
      <td>0.026</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p><strong>정렬(Sorting)</strong>의 설명은 <a href="https://speardragon.github.io/lecture/data%20structure%20and%20algorithms/algorithm/sorting/Algorithm-Sorting(%EC%A0%95%EB%A0%AC)/"><u><span style="color:blue">이곳</span></u></a>을 참조<br /></p>

<p><strong>Bubble 정렬</strong>의 설명은 <a href="https://speardragon.github.io/lecture/data%20structure%20and%20algorithms/algorithm/sorting/Algorithm-Bubble-Sort(%EB%B2%84%EB%B8%94-%EC%A0%95%EB%A0%AC)/"><u><span style="color:blue">이곳</span></u></a>을 참조<br /></p>

<p><strong>Shell 정렬</strong>의 설명은 <a href=""><u><span style="color:blue">이곳</span></u></a>을 참조<br /></p>

<p><strong>Insertion 정렬</strong>의 설명은 <a href="https://speardragon.github.io/lecture/data%20structure%20and%20algorithms/algorithm/sorting/Algorithm-Insert-Sort(%EC%82%BD%EC%9E%85-%EC%A0%95%EB%A0%AC)/"><u><span style="color:blue">이곳</span></u></a>을 참조<br /></p>

<p><strong>Quick 정렬</strong>의 설명은 <a href="https://speardragon.github.io/lecture/data%20structure%20and%20algorithms/algorithm/sorting/Algorithm-Quick-Sort(%ED%80%B5-%EC%A0%95%EB%A0%AC)/"><u><span style="color:blue">이곳</span></u></a>을 참조<br /></p>

<p><strong>Heap 정렬</strong>은 우선순위 큐에서 사용하는 정렬이므로 해당 포스팅 <a href="https://speardragon.github.io/lecture/data%20structure%20and%20algorithms/algorithm/heap/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-Heap-&amp;-Priority-Queue(%ED%9E%99%EA%B3%BC-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90)/"><u><span style="color:blue">이곳</span></u></a>을 참조<br /></p>

<p><strong>Topological 정렬</strong>의 설명은 <a href="https://speardragon.github.io/lecture/data%20structure%20and%20algorithms/algorithm/graph/Algorithm-Topological-Sorting(%EC%9C%84%EC%83%81-%EC%A0%95%EB%A0%AC)/"><u><span style="color:blue">이곳</span></u></a>을 참조<br /></p>

<p><strong>Merge 정렬</strong>의 설명은 <a href="https://speardragon.github.io/lecture/data%20structure%20and%20algorithms/algorithm/sorting/Algorithm-Merge-Sort(%ED%95%A9%EB%B3%91-%EC%A0%95%EB%A0%AC)/"><u><span style="color:blue">이곳</span></u></a>을 참조<br /></p>
:ET