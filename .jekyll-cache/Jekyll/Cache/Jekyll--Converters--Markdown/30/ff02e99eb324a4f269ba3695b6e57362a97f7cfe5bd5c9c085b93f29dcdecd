I"<p>ArrayList에서 했던 것과 마찬가지로 LinkedList에서의 데이터 삽입, 데이터 삭제, 리스트 검색 등의 기능에 대해서 다뤄보도록 하겠다.</p>

<p><img src="https://user-images.githubusercontent.com/79521972/153141261-49abcef4-65b2-455f-a4d4-b4fbd4de24ee.png" alt="image" /></p>

<p>LinkedList는 Node라는 객체로 이루어져 있는데 Node는 <span style="color:red">데이터를 저장하는 field</span>와 <span style="color:blue">다음 노드를 가리킬 수 있는 next pointer field</span>로 구성이 되어있습니다.</p>

<p>즉 이때, 이 노드들이 연결된 형태의 자료구조를 바로 LinkedList라고 하는 것이다.</p>

<p>예를 들어, 학교에서 한 반의 모든 학생들의 데이터를 저장한다고 했을 때, 학생 한명한명의 신상정보 자료를 노드로 만들고, 1번 학생의 신상정보 자료에 2번 신상정보 자료가 어디 있는 지 표시를 해 놓는 방식이다. 쉽게 말해서 줄줄이 소세지마냥 자료를 엮어 놓은 것이라고 생각하면 된다.</p>

<p><img src="https://user-images.githubusercontent.com/79521972/155269770-85d6d480-754d-492d-84f3-28ec70044d25.png" alt="image" style="zoom:67%;" /></p>

<p>반면 배열은 학생들의 데이터를 한 곳에 쭉 쌓아 올린 모양새 라고 생각하면 된다.</p>

<p><img src="https://user-images.githubusercontent.com/79521972/155270072-2e4651ff-3819-491e-8158-f89224a644f4.png" alt="image" style="zoom:80%;" /></p>

<p>그래서 전에 말했듯이 데이터를 추가나 삭제를 할 때는 쌓아 올린 수가 많은 만큼 어려울 것인데 이 LinkedList는 엮여 있는 pointer만 조금씩 수정해 주면 쉽게 가능하여 시간 소모가 둘이 다른 것이다.</p>

<p><br /></p>

<p>노드 중에서는 고유한 노드가 존재하며 이 노드들은 다음과 같다.</p>

<p><strong>Head</strong>: 가장 앞에 위치한 노드</p>

<ul>
  <li>LinkedList의 값이 있더라도 Head 노드는 반드시 비어있다. 따라서 head 노드에는 무조건 null값을 주게 된다. 그래서 head node는 보통 dummy node라고 불리기도 한다.(아무런 값이 존재하지 않고 그저 수단으로만 사용되기 때문)</li>
</ul>

<p><strong>Tail</strong>: 가장 뒤에 위치한 노드</p>

<ul>
  <li>Tail은 자신의 다음에 가리킬 노드가 없기 때문에 Tail의 next pointer 또한 null이다.</li>
  <li>단순 연결 리스트에서는 노드가 뒤에 계속 추가 된다면 tail 노드는 바뀔 수 있지만, 이중 연결 리스트에서는 tail노드를 따로 지정을 해두기 때문에(이름이 ‘이중’인 이유) tail노드가 바뀌지 않는다.</li>
</ul>

<p><br /></p>

<h2 id="검색">검색</h2>

<p><img src="https://user-images.githubusercontent.com/79521972/153141969-65edd7e3-4584-411d-9be4-c48577cb0c0c.png" alt="image" /></p>

<p>LinkedList에서의 검색은 ArrayList의 검색과 마찬가지로 head 노드에서부터 tail 노드까지 순차적으로 순회하면서 데이터를 찾아간다. 그렇기 때문에 마찬가지로 O(N)의 시간 복잡도를 가진다.</p>

<p>ArrayList는 대신 index로 검색을 하는 경우 Randon Access(임의 접근 방식)가 가능하여 데이터를 처음부터 찾을 필요가 없어 O(1)의 시간 복잡도를 갖는다.</p>

<h2 id="추가">추가</h2>

<p><strong>‘추가’</strong>는 원하는 노드를 하나 만들고 그 노드와 Tail노드의 next pointer를 연결하는 작업이다.</p>

<p>마찬가지로 처음부터 끝까지 순회하면서 마지막 노드가 가리키고 있는 Null 위치에 우리가 원하고자 하는 노드를 추가 시키는 개념이다.</p>

<p>ArrayList와는 달리, 끝 노드를 찾아야 하지 않아도 되고 그저 tail노드에서 새로운 노드를 추가하는 것이기 때문에 <mark>O(1)</mark>의 시간 복잡도를 갖는다.</p>

<h2 id="삽입">삽입</h2>

<p>삽입은 제일 끝이 아니라 중간에 넣는 경우를 말하며 LinkedList는 ArrayList와는 다르게 데이터를 뒤로 한 칸씩 전부 밀어줄 필요가 없습니다. 그냥 간단히 pointer만 바꿔주면 되기 때문에 논리는 간단하지만 삽입 위치를 찾기 위해서는 순회를 통해 찾아야 하기 때문에 시간복잡도는 <mark>O(N)</mark>이다.</p>

<ol>
  <li>삽입을 원하는 노드를 생성하고</li>
</ol>

<p><img src="https://user-images.githubusercontent.com/79521972/153142796-987f7ffd-d456-41d3-b94e-da0f4fec36b6.png" alt="image" /></p>

<p><br /></p>

<ol>
  <li>해당 노드의 previous(이전의) node의 next 포인터를 본인 노드와 연결하고 previous node의 next pointer가 가리키고 있던 노드를 본인 노드의 next pointer로 가리킴로써 연결을 삽입을 마무리한다.</li>
</ol>

<p><img src="https://user-images.githubusercontent.com/79521972/153142590-7d96166a-b85e-4ff9-91a0-fc213f3c5708.png" alt="image" /></p>

<p><br /></p>

<h2 id="삭제">삭제</h2>

<p>LinkedList에서 삭제하고자 하는 노드가 있을 때는 그 위치를 찾아가야 하기 때문에 결정되는 시간복잡도는 O(N)입니다.</p>

<ul>
  <li>head와 tail노드로 무작정 알아낼 수 없기 때문</li>
</ul>

<p>ArrayList에서는 삭제할 위치를 찾고 뒤의 데이터들을 앞으로 한 칸씩 당기는데 또 시간이 O(N)만큼 소요가 됐다면,</p>

<p>LinkedList는  데이터를 당겨오지 않고 pointer만 조금 바꾸어 주면 삭제 과정이 자동으로 이루어 지게 된다.</p>

<p><img src="https://user-images.githubusercontent.com/79521972/153144288-98c0091d-3f35-42b0-a6bb-4f078033769e.png" alt="image" /></p>

<p>빨간 점선으로 된 노드를 삭제해야 한다고 하자. 앞으로 삭제하고자 하는 노드를 삭제노드, 그 노드의 이전 노드는 이전노드 다음 노드는 다음노드라 부르겠다.</p>

<p><br /></p>

<p><img src="https://user-images.githubusercontent.com/79521972/153144407-7e8b6da6-ce01-4cb9-b81b-63b11680aa72.png" alt="image" /></p>

<p>이전 노드의 next pointer는 삭제 노드의 next pointer가 가리키고 있던 노드를 가리키게 되고  삭제 노드의 next pointer는 아무것도 가리키지 않는 상태인 null 상태가 되게 한다.</p>

<p>즉, node.next = null;</p>

<p><br /></p>

<p><img src="https://user-images.githubusercontent.com/79521972/153144493-52d3c684-c3d0-4ecc-9bc1-50f128507a9b.png" alt="image" /></p>

<p>그 이후 자바에서는 garbage collector에 의해 붕떠 있던 삭제 노드는 알아서 사라지게 됩니다. 그리하여 LinkedList의 삭제를 한 후 연결이 잘 되어 있음을 볼 수 있다.</p>

<p><br /></p>

<p><strong>장점</strong></p>

<ul>
  <li>배열의 복사나 재할당 없이 데이터 추가 가능 / 유연한 공간
    <ul>
      <li>ArrayList는 배열이 꽉 차있는 경우 크기를 늘려 준 다음 데이터를 다시 추가해 주는 과정을 진행해야 했는데 LinkedList는 쓰는 공간만큼만 크기가 늘었다 줄었다 하기 때문에 메모리 측면에서 훨씬 효율적임.</li>
    </ul>
  </li>
</ul>

<p><strong>단점</strong></p>

<ul>
  <li>데이터 접근에 대한 시간이 늘어남
    <ul>
      <li>Random Access가 되지 않기 때문에 원하는 노드를 찾아야 하는 경우 O(N)의 시간복잡도가 발생한다는 점이 단점이라면 단점이겠습니다.</li>
    </ul>
  </li>
</ul>

<h2 id="linkedlist-vs-array">LinkedList vs. Array</h2>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>LinkedList</th>
      <th>Array</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>추가</td>
      <td>O(1)</td>
      <td>O(1),O(N)</td>
    </tr>
    <tr>
      <td>삽입</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
    <tr>
      <td>삭제</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
    <tr>
      <td>검색</td>
      <td>O(N)</td>
      <td>O(1)</td>
    </tr>
  </tbody>
</table>

<p>위 표를 통해 LinkedList와 ArrayList의 장단점을 한번에 볼 수 있으며 어느 상황에 어떤 자료구조를 사용해야 할 지를 생각해 보면 좋을 것 같습니다.</p>

<p>예를 들어, 리스트를 읽기만 할 때는 ArrayList가 압도적으로 좋지만 리스트의 추가, 삭제, 삽입을 한다면 LinkedList가 시간 복잡도 측면에서 더 좋은 경우가 있겠습니다.</p>

<h1 id="linkedlist-구현">LinkedList 구현</h1>

<p>지난 시간 만들었던 IList 인터페이스를 구현 상속한 MyLinkedList 클래스를 구현해 보도록 할 것이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">list</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyLinkedList</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">IList</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="생성자">생성자</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
<span class="kd">private</span> <span class="nc">Node</span> <span class="n">head</span><span class="o">;</span>

<span class="kd">public</span> <span class="nf">MyLinkedList</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">size</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">head</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// dummy node</span>
<span class="o">}</span>
</code></pre></div></div>

<p>먼저 MyLinkedList클래스의 멤버 변수로 크기를 나타내는 size변수와 head 노드를 선언한다.</p>

<p>그리고 생성자에는 이 크기(size)와 헤드노드를 각각 0과 null로 초기화 시켰다.</p>

<p><br /></p>

<h2 id="노드-클래스">노드 클래스</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="no">T</span> <span class="n">data</span><span class="o">;</span>
    <span class="nc">Node</span> <span class="n">next</span><span class="o">;</span>
    
    <span class="nc">Node</span><span class="o">(</span><span class="no">T</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="nc">Node</span><span class="o">(</span><span class="no">T</span> <span class="n">data</span><span class="o">,</span> <span class="nc">Node</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>           
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>LinkedList는 노드 기반이기 때문에 사용할 노드 또한 만든다.</p>

<p>앞서 말했듯 노드에는 데이터를 담기 위한 data 변수와, 다음 node를 가리키기 위한 pointer 객체(next)가 필요하다.</p>

<p>또한 구현을 더 편하게 하기 위해서 노드의 생성자를 만들어주었는데 인자를 data 하나만 받는 경우와 data와 next pointer객체 두 가지를 받는 경우를 나누어 각각 경우에 맞게 초기화 시키는 생성자들을 만들어 주었다.</p>

<p><br /></p>

<h2 id="add">add</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span> 
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
   	<span class="nc">Node</span> <span class="n">curr</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">head</span><span class="o">;</span>
    <span class="k">while</span><span class="o">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nc">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
    <span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">size</span><span class="o">++;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>curr이라는 노드는 순회를 위해서 현재 위치를 특정짓기 위한 노드이다. head 노드부터 시작해야 되기 때문에 head 노드를 curr노드에 대입합니다. (curr 노드 진입)</p>

<p>순회는 null이전까지 해야 하기 때문에 while 문에 조건을 붙여 반복해 주었다. curr의 next pointer를 curr로 지정하면서 계속해서 앞쪽으로 쭉쭉 순회가 되는 개념이다.</p>

<p>반복문을 빠져나왔을 때는 LinkedList의 끝까지 왔을 때이므로 추가하고자 하는 ‘node’를 새로 만들고 curr의 next pointer가 이 노드를 가리키게 하며 size는 1만큼 증가 시킨다.</p>

<p><br /></p>

<h2 id="insert">insert</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span> 
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="no">T</span> <span class="n">t</span><span class="o">);{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="k">this</span><span class="o">.</span><span class="na">size</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&lt;</span><span class="mi">0</span><span class="o">){</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IndexOutOfBoundsException</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="nc">Node</span> <span class="n">prev</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">head</span><span class="o">;</span>
    <span class="nc">Node</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">prev</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span><span class="o">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nc">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">curr</span><span class="o">);</span>
    <span class="n">prev</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">size</span><span class="o">++;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>insert는 ArrayList와 크게 다르지 않다. 다만 ArrayList와 같이 뒤의 데이터를 전부 밀지 않고 pointer 몇 개만 조금 바꾸어 주면 된다.</p>

<p>먼저 가장 처음의 상태는 prev 노드는 head노드이고 그렇기 때문에 curr노드는 prev노드의 next pointer가 가리키는 노드여야 한다. 즉, head 노드의 next pointer가 가리키고 있는 것은 null이므로 null을 가리키고 있는 것과 같은 상황이다.</p>

<p>삽입하고자 하는 index의 수만큼 순회를 진행할 것인데 반복문이 진행됨에 따라 prev노드와 curr노드를 다음 노드로 계속해서 이동해 주었고 해당 index만큼 반복이 진행 되었을 때는 prev노드와 curr노드에는 <strong>삽입을 원하는 위치의 노드로 초기화</strong>가 진행되어 있을 것이다.</p>

<p>그 이후 삽입하고자 하는 node를 생성하되 인자로 curr노드를 넘겨 node 노드가 생성될 때 이 노드의 next pointer가 가리키는 노드는 curr 노드가 되도록 해준다.</p>

<ul>
  <li>생성한 노드: 데이터 field에는 t를 가지며 next pointer로 curr 노드를 가리키고 있는 노드</li>
</ul>

<p>그리고 prev의 next pointer를 생성한 node로 해서 연결을 마무리 짓는다.</p>

<p>마지막으로 삽입을 진행하였으니 배열의 크기를 1만큼 증가 시켜 준다.</p>

<p><br /></p>

<h2 id="clear">clear</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">clear</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">size</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>ArrayList와 다르게 LinkedList 의 clear에서는 size를 0으로 초기화 시켜주는 것 뿐 아니라 LinkedList의 모든 연결을 끊어 주어야 하는데 head노드의 next pointer가 가리키고 있는 객체를 null로 초기화를 시켜주면 LinkedList의 clear 과정이 진행된다. (상당히 간단하다.)</p>

<ul>
  <li>LinkedList를 타고 들어가는 방법은 오직 head노드를 통한 경로 밖에 없기 때문에 head노드와 다른 노드의 연결을 끊어주는 행위, 즉 null로 초기화 시키는 과정을 진행하면 자연스레 연결리스트의 초기화가 되는 것이다.</li>
</ul>

<p><br /></p>

<h2 id="delete">delete</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">delete</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Node</span> <span class="n">prev</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">head</span><span class="o">;</span>
    <span class="nc">Node</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">prev</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="k">while</span><span class="o">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">curr</span><span class="o">.</span><span class="na">data</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">t</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">prev</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">size</span><span class="o">--;</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>LinkedList에서의 삭제는 마찬가지로 뒤의 데이터를 당겨주는 과정(시간 복잡도: O(N)소모)없이 포인터 몇 개만 조금 바꾸어 주는 것으로 구현할 수 있다.</p>

<p>먼저 기본 세팅은 앞선 기능들과 동일하다.</p>

<p>while문을 통해 노드를 순회하고 조건문을 통해 조건에 맞는 prev노드와 curr노드가 정해졌을 때 curr노드는 삭제하고자 하는 노드이고 prev노드는 삭제하고자 하는 노드의 이전노드 일 것이다.</p>

<p>prev 노드의 next pointer는 가리키고 있는 것은 삭제하고자 하는 curr 노드이기 때문에 이를 curr노드의 next pointer가 가리키고 있던 노드와 연결시킨다.</p>

<p>그러고 나서는 curr의 next pointer는 아무것도 가리키지 않는 상태로 만들어 주기 위하여 null 값으로 초기화 시킨다.</p>

<p>항상 마무리는 리스트의 크기 조정으로 마무리한다. (this.size– : 크기 1 감소)</p>

<p><br /></p>

<h2 id="deletebyindex">deleteByindex</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">deleteByindex</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">){</span>
	<span class="k">if</span><span class="o">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="k">this</span><span class="o">.</span><span class="na">size</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">){</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IndexOutOfBoundsException</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="nc">Node</span> <span class="n">prev</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">head</span><span class="o">;</span>
    <span class="nc">Node</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">prev</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span><span class="o">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="n">prev</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">size</span><span class="o">--;</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>deleteByindex는 index로 노드를 찾아 해당 노드를 삭제시키는 것이기 때문에 인자로 받는 index의 범위가 음수이거나 리스트의 size보다 크거나 같은 경우 false를 리턴할 수도 있겠지만 오류의 내용을 더 명확히 명시하기 위하여 IndexOutOfBound 예외를 출력하게끔 하였다.</p>

<p>deleteByindex 또한 다른 것들과 마찬가지로 prev 노드와 curr노드를 초기화시키고 while 반복문을 index 까지 i를 증가시키면서 진행하고 그 안의 내용으로는 prev 노드와 curr 노드를 다음 노드로 이동하는 과정을 진행한다.</p>

<p>반복문이 종료된 시점에는 curr노드는 index만큼의 노드가 되고 prev 노드는 그 이전의 노드가 되기 때문에 위의 delete에서 했던 것과 동일한 방법으로 삭제시킨다.</p>

<p><br /></p>

<h2 id="get">get</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="no">T</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">){</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="k">this</span><span class="o">.</span><span class="na">size</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IndexOuOfBoundException</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="nc">Node</span> <span class="n">curr</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span><span class="o">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">curr</span><span class="o">.</span><span class="na">data</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>get은 원하는 노드의 data만 얻고 싶은 것이기 때문에 prev노드를 사용하지 않아도 된다.(only data!)</p>

<p>내용은 똑같이 curr 노드를 생성하여 이를 원하는 index까지 이동시켜 그 노드의 data를 리턴하는 식이다.</p>

<ul>
  <li>위 코드에서 curr 노드에 head 노드를 대입시키는 것이 아니라 head 노드의 next pointer가 가리키는 노드를 대입시킨 이유는 head 노드에는 어차피 데이터(값)가 존재하지 않기 때문이다.</li>
</ul>

<p><br /></p>

<h2 id="indexof">indexOf</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">indexOf</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Node</span> <span class="n">curr</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">curr</span><span class="o">.</span><span class="na">data</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">index</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">index</span><span class="o">++;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="o">}</span> 
</code></pre></div></div>

<p>indexOf 메소드는 인자로 받아온 t와 일치하는 노드의 index를 반환하는 메소드이다.</p>

<ul>
  <li>데이터의 index를 리턴하는 메소드</li>
</ul>

<p>curr 노드를 생성하고 while 반복문을 통해 index를 0부터 증가시키면서 리스트의 끝까지 반복시키고 curr 노드를 이동시켜 리스트를 순회한다. 그리고 현재 노드와 인자 t가 일치할 때 그때의 index를 반환하면 된다.</p>

<p><br /></p>

<h2 id="isempty">isEmpty</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span> 
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>ArrayList에서 했던 것처럼 size가 0인 것으로 isEmpty 메소드를 구현해도 되지만 LinkedList스럽게(?) 구현하려면 head 노드의 next pointer가 가리키고 있는 노드가 null이면 연결리스트의 초기 상태, 즉 리스트가 비어있는 것이기 때문에 이 logic을 리턴한다.</p>

<p><br /></p>

<h2 id="contains">contains</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">contains</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Node</span> <span class="n">curr</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="k">while</span><span class="o">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">curr</span><span class="o">.</span><span class="na">data</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>contains 메소드 역시 ArrayList와 마찬가지로 반복문을 통해 하나씩 돌면서 equals 메소드로 리스트의 원소와 일치하면 true(1) 아니면 false(0)을 반환해 주는 알고리즘이다.</p>

<ul>
  <li>이 역시도 노드끼리의 연결을 바꿀 필요가 없기 때문에 prev 노드를 지정해 주지 않고 구현한다.</li>
</ul>

<p><br /></p>

<h2 id="size">size</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">size</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>리스트의 크기를 반환하는 메소드는 사실 반복문을 돌면서 tail 노드까지 접근하면서 index를 증가시키는 방법도 있지만 그렇게 되면 시간복잡도 O(N)이 발생하므로 비효율적이다.</p>

<p>따라서 그냥 <code class="language-plaintext highlighter-rouge">'simple is the best'</code> 란 말처럼 this.size를 반환한다.</p>

<p><br /></p>

<h3 id="자료구조-시간-복잡도-비교">자료구조 시간 복잡도 비교</h3>

<ul>
  <li>평균 시간 복잡도(Average)</li>
</ul>

<table>
  <thead>
    <tr>
      <th>자료구조</th>
      <th>Access</th>
      <th>Search</th>
      <th>Insertion</th>
      <th>Deletion</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Array</td>
      <td>O(1)</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>Stack</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>Queue</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>Singly Linked List</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>Doubly Linked List</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>Hash Table</td>
      <td>O(1)</td>
      <td>O(1)</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>Binary Search Tree</td>
      <td>O(log<sub>2</sub>n)</td>
      <td>O(log<sub>2</sub>n)</td>
      <td>O(log<sub>2</sub>n)</td>
      <td>O(log<sub>2</sub>n)</td>
    </tr>
    <tr>
      <td>AVL Tree</td>
      <td>O(log<sub>2</sub>n)</td>
      <td>O(log<sub>2</sub>n)</td>
      <td>O(log<sub>2</sub>n)</td>
      <td>O(log<sub>2</sub>n)</td>
    </tr>
    <tr>
      <td>B Tree</td>
      <td>O(log<sub>2</sub>n)</td>
      <td>O(log<sub>2</sub>n)</td>
      <td>O(log<sub>2</sub>n)</td>
      <td>O(log<sub>2</sub>n)</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>최악의 경우 시간 복잡도(Worst)</li>
</ul>

<table>
  <thead>
    <tr>
      <th>자료구조</th>
      <th>Access</th>
      <th>Search</th>
      <th>Insertion</th>
      <th>Deletion</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Array</td>
      <td>O(1)</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>Stack</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>Queue</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>Singly Linked List</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>Doubly Linked List</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>Hash Table</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>Binary Search Tree</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>AVL Tree</td>
      <td>O(log<sub>2</sub>n)</td>
      <td>O(log<sub>2</sub>n)</td>
      <td>O(log<sub>2</sub>n)</td>
      <td>O(log<sub>2</sub>n)</td>
    </tr>
    <tr>
      <td>Binary Tree</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>B Tree</td>
      <td>O(log<sub>2</sub>n)</td>
      <td>O(log<sub>2</sub>n)</td>
      <td>O(log<sub>2</sub>n)</td>
      <td>O(log<sub>2</sub>n)</td>
    </tr>
  </tbody>
</table>

:ET